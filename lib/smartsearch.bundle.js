(function umdWrapper(root, factory) {
                    if(typeof exports === "object" && typeof module === "object")
                        module.exports = factory();
                    else if(typeof define === "function" && define.amd)
                        define("SmartSearch", [], function() { return factory(); });
                    else if(typeof exports === "object")
                        exports["SmartSearch"] = factory();
                    else
                        root["SmartSearch"] = factory().SmartSearch;
                })(this, function() {
                return/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./dist/lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/defaults.js":
/*!**************************!*\
  !*** ./dist/defaults.js ***!
  \**************************/
/*! exports provided: VERSION, API_ENDPOINT, PAGINATION_FUNCTION, SEARCH_RESULT_FUNCTION, DID_YOU_MEAN_FUNCTION, AUTOCOMPLETE_DEFAULT_THRESHOLD, CSS_AUTOCOMPLETE_WIDGET, CSS_AUTOCOMPLETE_ACTIVE, CSS_AUTOCOMPLETE_ITEM, CSS_PAGINATION, CSS_NEXT_BUTTON, CSS_PREV_BUTTON, CSS_PAGE_BUTTON, CSS_CURRENT_PAGE, CSS_SEARCH_RESULT_WRAPPER, CSS_SEARCH_RESULT_ELEMENT, CSS_DID_YOU_MEAN_WRAPPER, CSS_DID_YOU_MEAN_ELEMENT */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "API_ENDPOINT", function() { return API_ENDPOINT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PAGINATION_FUNCTION", function() { return PAGINATION_FUNCTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SEARCH_RESULT_FUNCTION", function() { return SEARCH_RESULT_FUNCTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DID_YOU_MEAN_FUNCTION", function() { return DID_YOU_MEAN_FUNCTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AUTOCOMPLETE_DEFAULT_THRESHOLD", function() { return AUTOCOMPLETE_DEFAULT_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_AUTOCOMPLETE_WIDGET", function() { return CSS_AUTOCOMPLETE_WIDGET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_AUTOCOMPLETE_ACTIVE", function() { return CSS_AUTOCOMPLETE_ACTIVE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_AUTOCOMPLETE_ITEM", function() { return CSS_AUTOCOMPLETE_ITEM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_PAGINATION", function() { return CSS_PAGINATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_NEXT_BUTTON", function() { return CSS_NEXT_BUTTON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_PREV_BUTTON", function() { return CSS_PREV_BUTTON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_PAGE_BUTTON", function() { return CSS_PAGE_BUTTON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_CURRENT_PAGE", function() { return CSS_CURRENT_PAGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_SEARCH_RESULT_WRAPPER", function() { return CSS_SEARCH_RESULT_WRAPPER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_SEARCH_RESULT_ELEMENT", function() { return CSS_SEARCH_RESULT_ELEMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_DID_YOU_MEAN_WRAPPER", function() { return CSS_DID_YOU_MEAN_WRAPPER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_DID_YOU_MEAN_ELEMENT", function() { return CSS_DID_YOU_MEAN_ELEMENT; });
var _VERSION = "1.2.0-SNAPSHOT-HPJS-57.2";

/**
 * The default API endpoint to which auto-complete and search queries are sent.
 */
var API_ENDPOINT = "/v1/prepared_search";
/**
 * The default function to render a single pagination element. *The default algorithm is:*
 * ```typescript
 * (value: string): string => {
 *     return value
 * }
 * ```
 *
 * @param value The page value. The first page corresponds to the value 0.
 * @returns The given value without modification.
 */
var PAGINATION_FUNCTION = function (value) {
    return value;
};
/**
 * The default function to render a single search result. *The default algorithm is:*
 * ```typescript
 * (data: Result, highlights: Highlighting): string => {
 *     return `<a href="${data.link}">
 *               <h1>${data.title}</h1>
 *               <p>${highlights.content}</p>
 *             </a>`
 * }
 * ```
 *
 * @param data The search result information like link or title.
 * @param highlights The content to be displayed on the search result page.
 */
var SEARCH_RESULT_FUNCTION = function (data, highlights) {
    return "<a href=\"" + data.link + "\"><h1>" + data.title + "</h1><p>" + highlights.content + "</p></a>";
};
/**
 * The default function to render a single 'Did you mean' suggestion. *The default algorithm is:*
 * ```typescript
 * (value: string): string => {
 *     return value
 * }
 * ```
 *
 * @param value the suggestion.
 */
var DID_YOU_MEAN_FUNCTION = function (value) {
    return "<span>" + value + "</span>";
};
/**
 * Default threshold of characters to type before the first autocomplete request is sent
 */
var AUTOCOMPLETE_DEFAULT_THRESHOLD = 0;
/**
 * Default CSS class for the autocomplete box
 */
var CSS_AUTOCOMPLETE_WIDGET = "smart-search-autocomplete-widget";
/**
 * Default CSS class for the active autocomplete item
 */
var CSS_AUTOCOMPLETE_ACTIVE = "smart-search-autocomplete-active";
/**
 * Default CSS class for an autocomplete item
 */
var CSS_AUTOCOMPLETE_ITEM = "smart-search-autocomplete-item";
/**
 * Default CSS class for the pagination wrapper HTML element.
 */
var CSS_PAGINATION = "smart-search-pagination";
/**
 * Default CSS class for the pagination next button.
 */
var CSS_NEXT_BUTTON = "smart-search-pagination-next";
/**
 * Default CSS class for the pagination prev button.
 */
var CSS_PREV_BUTTON = "smart-search-pagination-prev";
/**
 * Default CSS class for the pagination page buttons.
 */
var CSS_PAGE_BUTTON = "smart-search-pagination-page";
/**
 * Default CSS class for the pagination current page button.
 */
var CSS_CURRENT_PAGE = "smart-search-pagination-current";
/**
 * Default CSS class for the search result wrapper HTML element.
 */
var CSS_SEARCH_RESULT_WRAPPER = "smart-search-search-results";
/**
 * Default CSS class for a single search result inside the wrapper.
 */
var CSS_SEARCH_RESULT_ELEMENT = "smart-search-search-result";
/**
 * Default CSS class for the single 'Did you mean' wrapper.
 */
var CSS_DID_YOU_MEAN_WRAPPER = "smart-search-did-you-mean-wrapper";
/**
 * Default CSS class for a single 'Did you mean' suggestion.
 */
var CSS_DID_YOU_MEAN_ELEMENT = "smart-search-did-you-mean-element";


/***/ }),

/***/ "./dist/lib/autocompleteWidget.js":
/*!****************************************!*\
  !*** ./dist/lib/autocompleteWidget.js ***!
  \****************************************/
/*! exports provided: AutocompleteWidget */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteWidget", function() { return AutocompleteWidget; });
/* harmony import */ var baconjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! baconjs */ "./node_modules/baconjs/dist/Bacon.js");
/* harmony import */ var baconjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(baconjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../defaults */ "./dist/defaults.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


/** @hidden */
var SPECIAL_KEYS = ["Enter", "ArrowUp", "ArrowDown"];
/**
 *  This event is triggered the moment the box is displayed.
 */
var appearedEvent = new CustomEvent("smart-search-widget-appeared", {
    bubbles: true,
    cancelable: true,
});
/**
 *  This event is triggered the moment the box is hidden.
 */
var hiddenEvent = new CustomEvent("smart-search-widget-hidden", {
    bubbles: true,
    cancelable: true,
});
/**
 * The handler listening to this event will clear and hide the autocomplete widget.
 */
var inputEmpty = new CustomEvent("smart-search-input-empty", {
    bubbles: true,
    cancelable: true,
});
/**
 * UI-Widget that can be attached to an input element. Fetches and displays autocomplete suggestions.
 *
 * If you want to render your own HTML and just fetch the autocomplete suggestions, use [[SmartSearch.fetchAutocompleteList]]
 * instead.
 */
var AutocompleteWidget = /** @class */ (function () {
    /**
     * @param autocompleteClient The [[FetchClient]] used to send API calls against the backend.
     * @param options The options used to modify the autocomplete function
     */
    function AutocompleteWidget(autocompleteClient, options) {
        this.autocompleteClient = autocompleteClient;
        this.options = options;
    }
    /**
     * A function meant to be called at every keystroke that returns a list of suggestions for autocompletion.
     *
     * @param prefix All characters typed so far, all strings returned by this function will start with this prefix.
     * @returns The highlighted or default autocomplete list for the given prefix, contains at most 5 elements.
     */
    AutocompleteWidget.prototype.getAutocompleteList = function (prefix, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var params, autocompleteList, error_1;
            var _c;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!options) {
                            //janky hack to work around a typedoc problem with default parameter values
                            options = this.options;
                        }
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, , 4]);
                        params = [
                            {
                                prefix: prefix.toLowerCase(),
                            }
                        ];
                        if ((_a = options) === null || _a === void 0 ? void 0 : _a.language) {
                            params.push({ language: options.language });
                        }
                        this.autocompleteClient.parameterList = (_c = this.autocompleteClient.parameterList).addOrUpdate.apply(_c, params);
                        return [4 /*yield*/, this.autocompleteClient.fetch()];
                    case 2:
                        autocompleteList = (_d.sent());
                        if ((_b = options) === null || _b === void 0 ? void 0 : _b.highlight) {
                            return [2 /*return*/, autocompleteList.map(function (item) { return _this.highlightPrefix(item, prefix); })];
                        }
                        return [2 /*return*/, autocompleteList];
                    case 3:
                        error_1 = _d.sent();
                        console.error("Error fetching autocomplete suggestions", error_1);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, [""]];
                }
            });
        });
    };
    /**
     * Highlights the prefix (typed by the user in the input field) using the html strong tag.
     *
     * @param item An item from the list of autocomplete suggestions.
     * @param prefix The prefix to highlight.
     */
    AutocompleteWidget.prototype.highlightPrefix = function (item, prefix) {
        var suffix = item.substr(item.indexOf(prefix) + prefix.length);
        return "<strong>" + prefix + "</strong>" + suffix;
    };
    AutocompleteWidget.prototype.showBox = function (box) {
        if (box.style.visibility === "hidden") {
            box.style.visibility = "visible";
            box.dispatchEvent(appearedEvent);
        }
    };
    AutocompleteWidget.prototype.hideBox = function (box) {
        box.style.visibility = "hidden";
        box.dispatchEvent(hiddenEvent);
    };
    AutocompleteWidget.prototype.clearAutocompleteBox = function (box) {
        this.hideBox(box);
        box.querySelectorAll("." + _defaults__WEBPACK_IMPORTED_MODULE_1__["CSS_AUTOCOMPLETE_ITEM"]).forEach(function (item) { return item.remove(); });
    };
    AutocompleteWidget.prototype.createAutocompleteBox = function (inputId) {
        var box = document.createElement("div");
        box.setAttribute("id", inputId + " autocomplete-widget");
        box.setAttribute("class", _defaults__WEBPACK_IMPORTED_MODULE_1__["CSS_AUTOCOMPLETE_WIDGET"]);
        return box;
    };
    /**
     * Removes highlights from a highlighted item.
     *
     * @param item A string containing a &lt;strong&gt;-tag.
     */
    AutocompleteWidget.prototype.removeHighlights = function (item) {
        var temp = document.createElement("div");
        temp.innerHTML = item;
        return temp.textContent || "";
    };
    // TODO: The CSS-classes should be configurable.
    /**
     * Marks the active item with the 'smart-search-autocomplete-active' css class.
     *
     * @param autocompleteList The html element containing all the autocomplete suggestions
     * @param cursorIndex
     */
    AutocompleteWidget.prototype.markActiveItem = function (autocompleteList, cursorIndex) {
        var acItems = Array.from(autocompleteList.querySelectorAll("." + _defaults__WEBPACK_IMPORTED_MODULE_1__["CSS_AUTOCOMPLETE_ITEM"]));
        var markedItem = acItems
            .filter(function (item, index) { return index === cursorIndex; })
            .map(function (item) {
            item.classList.add(_defaults__WEBPACK_IMPORTED_MODULE_1__["CSS_AUTOCOMPLETE_ACTIVE"]);
            return item;
        })
            .pop();
        acItems
            .filter(function (item, index) { return index !== cursorIndex; })
            .forEach(function (item) { return item.classList.remove(_defaults__WEBPACK_IMPORTED_MODULE_1__["CSS_AUTOCOMPLETE_ACTIVE"]); });
        return markedItem;
    };
    AutocompleteWidget.prototype.renderItem = function (acItem) {
        var renderedItem = document.createElement("div");
        renderedItem.setAttribute("class", _defaults__WEBPACK_IMPORTED_MODULE_1__["CSS_AUTOCOMPLETE_ITEM"]);
        renderedItem.innerHTML = acItem;
        return renderedItem;
    };
    /**
     * Creates the widget and attaches it to the given HTMLInputElement.
     *
     * @param inputElement The HTML input element to attach the widget to.
     * @param renderTarget The HTML div element to render the widget into
     */
    AutocompleteWidget.prototype.initializeAndAttach = function (inputElement, renderTarget) {
        var _this = this;
        var box = this.createAutocompleteBox(inputElement.id);
        if (renderTarget) {
            renderTarget.appendChild(box);
        }
        else if (inputElement.parentNode) {
            inputElement.parentNode.appendChild(box);
        }
        else {
            throw new Error("Given input element has no parent. Please attach it to an element in the DOM tree.");
        }
        this.hideBox(box);
        //handles the typing
        baconjs__WEBPACK_IMPORTED_MODULE_0__["fromEvent"](inputElement, "keydown")
            .debounce(300)
            .filter(function (event) { return !SPECIAL_KEYS.includes(event.key); })
            .map(function (event) {
            var target = event.target;
            return target.value;
        })
            .skipDuplicates()
            .flatMapLatest(function (prefix) {
            var _a;
            inputElement.addEventListener("smart-search-input-empty", function () { return _this.clearAutocompleteBox(box); }, {
                once: true,
            });
            var threshold = ((_a = _this.options) === null || _a === void 0 ? void 0 : _a.prefixThreshold) || _defaults__WEBPACK_IMPORTED_MODULE_1__["AUTOCOMPLETE_DEFAULT_THRESHOLD"];
            if (prefix.length === 0) {
                dispatchEvent(inputEmpty);
            }
            else if (prefix.length > threshold) {
                return baconjs__WEBPACK_IMPORTED_MODULE_0__["fromPromise"](_this.getAutocompleteList(prefix));
            }
            return [];
        })
            .onValue(function (list) {
            _this.clearAutocompleteBox(box);
            list.forEach(function (item) {
                _this.showBox(box);
                var renderedItem = _this.renderItem(item);
                renderedItem.addEventListener("click", function () {
                    inputElement.value = _this.removeHighlights(item);
                    inputElement.focus();
                    _this.clearAutocompleteBox(box);
                });
                box.appendChild(renderedItem);
            });
        });
        //handles the cursor moved by the arrow keys
        var up = baconjs__WEBPACK_IMPORTED_MODULE_0__["fromEvent"](inputElement, "keydown").filter(function (event) { return event.key === "ArrowUp"; });
        var down = baconjs__WEBPACK_IMPORTED_MODULE_0__["fromEvent"](inputElement, "keydown").filter(function (event) { return event.key === "ArrowDown"; });
        var enter = baconjs__WEBPACK_IMPORTED_MODULE_0__["fromEvent"](inputElement, "keydown").filter(function (event) { return event.key === "Enter"; });
        var reset = baconjs__WEBPACK_IMPORTED_MODULE_0__["fromEvent"](box, "smart-search-widget-appeared");
        baconjs__WEBPACK_IMPORTED_MODULE_0__["update"](-1, [down, function (prev) { return Math.min(prev + 1, 4); }], //the maximum amount of items in the list we get from haupia is 5
        [up, function (prev) { return Math.max(prev - 1, -1); }], //-1 because pressing down for the first time will move the cursor from the input field to the first item
        [reset, function () { return -1; }], [enter, function () { return -1; }]).onValue(function (highlightIndex) {
            var highlightedItem = _this.markActiveItem(box, highlightIndex);
            inputElement.addEventListener("keydown", function (event) {
                var _a;
                if (event.key === "Enter") {
                    (_a = highlightedItem) === null || _a === void 0 ? void 0 : _a.click();
                }
            });
        });
    };
    return AutocompleteWidget;
}());



/***/ }),

/***/ "./dist/lib/facet.js":
/*!***************************!*\
  !*** ./dist/lib/facet.js ***!
  \***************************/
/*! exports provided: Facet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Facet", function() { return Facet; });
/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./page */ "./dist/lib/page.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var Facet = /** @class */ (function () {
    /**
     * @param searchClient The fetch client to send the HTTP requests.
     * @param data The possible values to filter this searchTerm by.
     * @param config The facets configured in the prepared search.
     */
    function Facet(searchClient, data, config) {
        var _this = this;
        this.data = data;
        this.config = config;
        this._filterClient = searchClient;
        this._name = config.baseName;
        this._type = data.name.split("_").pop();
        this._counts = this.data.counts.map(function (counts) {
            counts.filterQuery = _this.getFilterParamName();
            return counts;
        });
    }
    Object.defineProperty(Facet.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Facet.prototype, "counts", {
        /**
         * @returns An array containing the possible values for this facet that can be used in the filter function as well as the number of
         * search results that would be returned if you filtered by value.
         */
        get: function () {
            return this._counts;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Facet.prototype, "filterClient", {
        get: function () {
            return this._filterClient;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Facet.prototype, "displayName", {
        get: function () {
            return this._displayName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Facet.prototype, "selectedValues", {
        get: function () {
            return this._selectedValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Facet.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Facet.prototype.getQueryParam = function (value) {
        var param = {};
        param[this.getFilterParamName()] = "\"" + value + "\"";
        return param;
    };
    Facet.prototype.getFilterParamName = function () {
        return "facet.filter." + this.config.baseName;
    };
    Facet.prototype.getSelectedParameters = function () {
        var _this = this;
        var _a;
        return ((_a = this.selectedValues) === null || _a === void 0 ? void 0 : _a.map(function (value) { return _this.getQueryParam(value); })) || [];
    };
    Facet.prototype.isValueAllowed = function (value) {
        var allowedValues = this.counts.map(function (counts) { return counts.value; });
        return allowedValues.includes(value);
    };
    Facet.prototype.setSelectedValues = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        this._selectedValues = values;
        return this;
    };
    Facet.prototype.setDisplayName = function (name) {
        this._displayName = name;
        return this;
    };
    /**
     * Resets all selected values in this facet.
     * For resetting a single facet we recommend calling filter with no parameters instead.
     *
     * @returns The resetted facet.
     */
    Facet.prototype.reset = function () {
        var parameterList = this.filterClient.parameterList.deleteAll(this.getFilterParamName());
        this.filterClient.parameterList = parameterList;
        this.setSelectedValues.apply(this, []);
        return this;
    };
    /**
     * Filters the search results for this search term using the facet values passed to this function.
     * Allows for the additional usage of custom parameters
     * @param filterValues The facet values to be filtered. Must be an array.
     * @param customParams Additional parameter objects. The key will be the parameter name, the value its value.
     * If the parameters already exist (because you added them as configuration options) they will be overwritten and then deleted.
     */
    Facet.prototype.customFilter = function (filterValues) {
        var customParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            customParams[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var result;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this.filterClient.parameterList = (_a = this.filterClient.parameterList).addOrUpdate.apply(_a, customParams);
                        return [4 /*yield*/, this.filter.apply(this, filterValues)];
                    case 1:
                        result = _c.sent();
                        this.filterClient.parameterList = (_b = this.filterClient.parameterList).delete.apply(_b, customParams);
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Filters the search results for this search term using the facette values passed to this function.
     * @param filterValues The facet values to be filtered.
     * @throws When selected values are not allowed or multiple selections are not allowed.
     */
    Facet.prototype.filter = function () {
        var filterValues = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filterValues[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var filterParams, clientParams;
            var _a;
            var _this = this;
            return __generator(this, function (_b) {
                if (!this.config.multiSelect && filterValues.length > 1) {
                    throw new Error("This is not a multi value facet. You can only pass one value to filter().");
                }
                filterValues.forEach(function (value) {
                    if (_this.type !== typeof value) {
                        throw new Error("The facet " + _this.config.baseName + " is of type " + _this.type + ", but the value that was passed (" + value + ") is of type " + typeof value);
                    }
                    if (!_this.isValueAllowed(value)) {
                        throw new Error("The passed value " + value + " is not allowed in this facette");
                    }
                });
                filterParams = filterValues.map(function (value) { return _this.getQueryParam(value); });
                clientParams = (_a = this.filterClient.parameterList.deleteAll(this.getFilterParamName())).add.apply(_a, filterParams);
                this.filterClient.parameterList = clientParams.updateFirst({ haupia_start: "0" }).updateFirst({ haupia_pageNumber: "0" });
                return [2 /*return*/, this.search()];
            });
        });
    };
    Facet.prototype.search = function () {
        return __awaiter(this, void 0, void 0, function () {
            var json, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.filterClient.fetch()];
                    case 1:
                        json = (_a.sent());
                        return [2 /*return*/, new _page__WEBPACK_IMPORTED_MODULE_0__["Page"](this.filterClient, json)];
                    case 2:
                        error_1 = _a.sent();
                        throw new Error(error_1);
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return Facet;
}());



/***/ }),

/***/ "./dist/lib/fetchClient.js":
/*!*********************************!*\
  !*** ./dist/lib/fetchClient.js ***!
  \*********************************/
/*! exports provided: FetchClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchClient", function() { return FetchClient; });
/* harmony import */ var _urlParamList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./urlParamList */ "./dist/lib/urlParamList.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

/** @hidden */
var requestOptions = {
    cache: "no-cache",
    credentials: "same-origin",
    headers: {
        "Content-Type": "application/json",
    },
    method: "GET",
    mode: "cors",
    redirect: "follow",
    referrerPolicy: "no-referrer",
};
var FetchClient = /** @class */ (function () {
    function FetchClient(url, options) {
        var _a;
        var _b;
        this.url = url;
        this._parameterList = new _urlParamList__WEBPACK_IMPORTED_MODULE_0__["URLParamList"]();
        this._autocomplete = ((_b = options) === null || _b === void 0 ? void 0 : _b.autocomplete) || false;
        if (options) {
            this.parameterList = (_a = this.parameterList.addOrUpdateSearchTerm(options.searchTerm || "")).add.apply(_a, options.customParams || []);
        }
    }
    Object.defineProperty(FetchClient.prototype, "autocomplete", {
        get: function () {
            return this._autocomplete;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FetchClient.prototype, "parameterList", {
        get: function () {
            return this._parameterList;
        },
        set: function (list) {
            this._parameterList = list;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates an execute or autocomplete URL.
     *
     * @param url
     */
    FetchClient.prototype.getUrlWithPath = function (url) {
        var returnUrl = url;
        if (!returnUrl.endsWith("/")) {
            returnUrl += "/";
        }
        if (this.autocomplete) {
            return returnUrl + "autocomplete";
        }
        else {
            return returnUrl + "execute";
        }
    };
    /**
     * Build a fetch resource request.
     *
     * @param url The URL that is used to identify the ressource.
     */
    FetchClient.prototype.buildRequest = function (url) {
        if (url !== this.url) {
            return new Request(url, requestOptions);
        }
        var urlWithoutParams = this.getUrlWithPath(url);
        var urlParams = this.parameterList.toString();
        var requestUrl = new URL(urlWithoutParams + "/?" + urlParams).toString();
        return new Request(requestUrl, requestOptions);
    };
    FetchClient.prototype.handleStatus = function (response) {
        if (!response.ok) {
            throw new Error(response.statusText);
        }
        return response;
    };
    /**
     * Sends a GET request to the SmartSearch API at the given or stored url
     * @param url Overrides the url class field
     */
    FetchClient.prototype.fetch = function (url) {
        if (url === void 0) { url = this.url; }
        return __awaiter(this, void 0, void 0, function () {
            var request, response, handledResponse, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        request = this.buildRequest(url);
                        return [4 /*yield*/, fetch(request)];
                    case 1:
                        response = _a.sent();
                        handledResponse = this.handleStatus(response);
                        return [4 /*yield*/, handledResponse.json()];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        error_1 = _a.sent();
                        throw new Error(error_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    return FetchClient;
}());



/***/ }),

/***/ "./dist/lib/index.js":
/*!***************************!*\
  !*** ./dist/lib/index.js ***!
  \***************************/
/*! exports provided: SmartSearch, Page, Facet, SearchResult, PageRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _smartSearch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./smartSearch */ "./dist/lib/smartSearch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SmartSearch", function() { return _smartSearch__WEBPACK_IMPORTED_MODULE_0__["SmartSearch"]; });

/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./page */ "./dist/lib/page.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Page", function() { return _page__WEBPACK_IMPORTED_MODULE_1__["Page"]; });

/* harmony import */ var _facet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./facet */ "./dist/lib/facet.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Facet", function() { return _facet__WEBPACK_IMPORTED_MODULE_2__["Facet"]; });

/* harmony import */ var _searchResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./searchResult */ "./dist/lib/searchResult.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SearchResult", function() { return _searchResult__WEBPACK_IMPORTED_MODULE_3__["SearchResult"]; });

/* harmony import */ var _pageRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pageRenderer */ "./dist/lib/pageRenderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PageRenderer", function() { return _pageRenderer__WEBPACK_IMPORTED_MODULE_4__["PageRenderer"]; });








/***/ }),

/***/ "./dist/lib/page.js":
/*!**************************!*\
  !*** ./dist/lib/page.js ***!
  \**************************/
/*! exports provided: Page */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Page", function() { return Page; });
/* harmony import */ var _searchResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./searchResult */ "./dist/lib/searchResult.js");
/* harmony import */ var _facet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./facet */ "./dist/lib/facet.js");
/* harmony import */ var _urlParamList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./urlParamList */ "./dist/lib/urlParamList.js");
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};



var PAGINATION_ERROR_MESSAGE = "Invalid pagination parameters defined. Static pagination parameters are required.";
/**
 * This class represents a search engine results page (SERP).
 */
var Page = /** @class */ (function () {
    /**
     * The constructor gets called after [[SmartSearch]] receives search results from the backend.
     *
     * @param fetchClient The [[FetchClient]] used to send API calls against the prepared search.
     * @param responseData The response JSON that may or may not have been filtered.
     * @param options Currently only used to get the template function
     */
    function Page(fetchClient, responseData) {
        var _this = this;
        this.responseData = responseData;
        this._fetchClient = fetchClient;
        this.responseData = responseData;
        this.searchResults = responseData.results.map(function (result) {
            var highlighting = _this.responseData.highlighting;
            return new _searchResult__WEBPACK_IMPORTED_MODULE_0__["SearchResult"](result, highlighting);
        });
        this.paginationParams = this.extractPaginationParams(this.responseData);
        this.facets = this.hasFacets(responseData) ? this.extractFacets(responseData, fetchClient) : [];
    }
    Object.defineProperty(Page.prototype, "numberOfResults", {
        /** The total number of search results matching the search term. */
        get: function () {
            return this.responseData.numRows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "didYouMean", {
        /** Returns alternative search queries if the [[numberOfResults]] value is beneath the threshold configured at the
         *  prepared search in the cockpit. */
        get: function () {
            return this.responseData.didYouMean;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "fetchClient", {
        get: function () {
            return this._fetchClient;
        },
        enumerable: true,
        configurable: true
    });
    Page.prototype.hasFacets = function (responseData) {
        return responseData.facets.length > 0 && responseData.facetConfigs.length > 0;
    };
    Page.prototype.extractFacets = function (responseData, searchClient) {
        return responseData.facets.map(function (responseFacet, index) {
            var facetBaseName = responseData.facetConfigs[index].baseName;
            var previouslyFilteredFacetKey = Object.keys(responseData.requestParameters).find(function (key) {
                return key.includes(facetBaseName);
            });
            var facet = new _facet__WEBPACK_IMPORTED_MODULE_1__["Facet"](searchClient, responseFacet, responseData.facetConfigs[index]);
            if (previouslyFilteredFacetKey) {
                var selectedValues = responseData.requestParameters[previouslyFilteredFacetKey].map(function (value) {
                    return value.replace(/"/g, "");
                });
                return facet.setSelectedValues.apply(facet, selectedValues);
            }
            return facet;
        });
    };
    Page.prototype.extractPaginationParams = function (responseData) {
        var requestParameters = responseData.requestParameters;
        var paginationParams;
        if (this.hasDynamicPaginationParams(requestParameters)) {
            paginationParams = this.extractDynamicPaginationParams(requestParameters);
        }
        else if (this.hasStaticPaginationParams(requestParameters)) {
            paginationParams = this.extractStaticPaginationParams(requestParameters);
        }
        else {
            paginationParams = this.setDefaultStaticPaginationParams(responseData.rows);
        }
        return paginationParams;
    };
    Page.prototype.hasDynamicPaginationParams = function (requestParameters) {
        var hasRows = Object.prototype.hasOwnProperty.call(requestParameters, "haupia_rows");
        var hasStart = Object.prototype.hasOwnProperty.call(requestParameters, "haupia_start");
        return hasRows && hasStart;
    };
    Page.prototype.extractDynamicPaginationParams = function (requestParameters) {
        var rows = Number(requestParameters.haupia_rows);
        var start = Number(requestParameters.haupia_start);
        if (isNaN(rows) || isNaN(start)) {
            throw Error("Invalid pagination parameters.");
        }
        return {
            rows: rows,
            start: start,
        };
    };
    Page.prototype.hasStaticPaginationParams = function (requestParameters) {
        var hasPageNumber = Object.prototype.hasOwnProperty.call(requestParameters, "haupia_pageNumber");
        var hasPageSize = Object.prototype.hasOwnProperty.call(requestParameters, "haupia_pageSize");
        return hasPageNumber && hasPageSize;
    };
    Page.prototype.extractStaticPaginationParams = function (requestParameters) {
        var pageNumber = Number(requestParameters.haupia_pageNumber);
        var pageSize = Number(requestParameters.haupia_pageSize);
        if (isNaN(pageNumber) || isNaN(pageSize)) {
            throw Error("Invalid pagination parameters.");
        }
        return {
            pageNumber: pageNumber,
            pageSize: pageSize,
        };
    };
    Page.prototype.setDefaultStaticPaginationParams = function (rows) {
        return {
            pageNumber: 0,
            pageSize: rows,
        };
    };
    /**
     * @returns The total number of pages.
     */
    Page.prototype.getNumberOfPages = function () {
        if (!this.isStaticPagination(this.paginationParams)) {
            throw Error(PAGINATION_ERROR_MESSAGE);
        }
        return Math.ceil(this.responseData.numRows / this.paginationParams.pageSize);
    };
    /**
     * @returns the facet matching the given name if it exists on this prepared search.
     * @param name The name of the facet as it is displayed in the SmartSearch cockpit under Prepared Search > Facet
     */
    Page.prototype.getFacet = function (name) {
        return this.facets.find(function (facet) { return facet.name === name; }) || null;
    };
    /**
     * Resets all facets on this page
     * @param include An optional list of facet names to reset. If you pass this parameter only the facets that match the names in this list will be resetted.
     * If you pass no parameter, all facets will be resetted.
     * @returns The first page of the new and unfiltered resultset.
     */
    Page.prototype.resetFacets = function (include) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.facets = this.facets
                    .map(function (facet) {
                    var _a;
                    if (include) {
                        if ((_a = include) === null || _a === void 0 ? void 0 : _a.includes(facet.name)) {
                            return facet.reset();
                        }
                        else {
                            return facet;
                        }
                    }
                    else {
                        return facet.reset();
                    }
                });
                if (this.isDynamicPagination(this.paginationParams)) {
                    return [2 /*return*/, this.search({ start: 0, rows: this.paginationParams.rows })];
                }
                else {
                    return [2 /*return*/, this.getFirstPage()];
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * This function doesn't work with [[DynamicPaginationParams]].
     *
     * @returns The first page with the defined pagination options.
     */
    Page.prototype.getFirstPage = function () {
        if (!this.isStaticPagination(this.paginationParams)) {
            throw Error(PAGINATION_ERROR_MESSAGE);
        }
        return this.getPage(0);
    };
    /**
     * This function doesn't work with [[DynamicPaginationParams]].
     *
     * @returns The last page with the defined pagination options.
     */
    Page.prototype.getLastPage = function () {
        var lastPage = this.getNumberOfPages() - 1;
        return this.getPage(lastPage);
    };
    /**
     * This function doesn't work with [[DynamicPaginationParams]].
     *
     * @param pageNumber
     * @returns The specified page with the defined pagination options.
     */
    Page.prototype.getPage = function (pageNumber) {
        return __awaiter(this, void 0, void 0, function () {
            var newPaginationParams;
            return __generator(this, function (_a) {
                if (!this.isStaticPagination(this.paginationParams)) {
                    throw Error(PAGINATION_ERROR_MESSAGE);
                }
                newPaginationParams = this.paginationParams;
                newPaginationParams.pageNumber = pageNumber;
                if (!this.hasPage(pageNumber)) {
                    throw Error("There is no page number: " + pageNumber);
                }
                return [2 /*return*/, this.search(newPaginationParams)];
            });
        });
    };
    /**
     * Checks whether the page with the given page number exists.
     *
     * This function is used internally by the [[getPage]] function.
     *
     * @param pageNumber
     */
    Page.prototype.hasPage = function (pageNumber) {
        var staticPaginationParams = this.paginationParams;
        var numberOfTotalPages = Math.ceil(this.responseData.numRows / staticPaginationParams.pageSize);
        return numberOfTotalPages > pageNumber && pageNumber >= 0;
    };
    /**
     * Checks whether the [[next]] function would send a valid request.
     *
     * This function is used internally by the [[next]] function.
     */
    Page.prototype.hasNext = function () {
        if (this.isDynamicPagination(this.paginationParams) && this.paginationParams.start + this.paginationParams.rows < this.responseData.numRows) {
            return true;
        }
        if (this.isStaticPagination(this.paginationParams) && this.paginationParams.pageSize * (this.paginationParams.pageNumber + 1) < this.responseData.numRows) {
            return true;
        }
        return false;
    };
    /**
     * Checks whether the [[prev]] function would send a valid request.
     *
     * This function is used internally by the [[prev]] function.
     */
    Page.prototype.hasPrev = function () {
        if (this.isStaticPagination(this.paginationParams) && this.paginationParams.pageNumber > 0) {
            return true;
        }
        if (this.isDynamicPagination(this.paginationParams) && this.paginationParams.start >= this.paginationParams.rows) {
            return true;
        }
        return false;
    };
    /**
     * The API response contains the next matches based on the previously set pagination parameters.
     *
     * @returns The [[Page]] containing all the search results for that page.
     */
    Page.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            var nextPaginationParams;
            return __generator(this, function (_a) {
                if (!this.hasNext()) {
                    throw Error("There is no next page.");
                }
                nextPaginationParams = {};
                if (this.isDynamicPagination(this.paginationParams)) {
                    nextPaginationParams = __assign({}, this.paginationParams);
                    nextPaginationParams.start += this.paginationParams.rows;
                }
                if (this.isStaticPagination(this.paginationParams)) {
                    nextPaginationParams = this.paginationParams;
                    nextPaginationParams.pageNumber++;
                }
                return [2 /*return*/, this.search(nextPaginationParams)];
            });
        });
    };
    /**
     * The API response contains the previous matches based on the previously set pagination parameters.
     *
     * @returns The [[Page]] containing all the search results for that page.
     */
    Page.prototype.prev = function () {
        return __awaiter(this, void 0, void 0, function () {
            var prevPaginationParams;
            return __generator(this, function (_a) {
                if (!this.hasPrev()) {
                    throw Error("There is no previous page.");
                }
                prevPaginationParams = {};
                if (this.isStaticPagination(this.paginationParams)) {
                    prevPaginationParams = this.paginationParams;
                    prevPaginationParams.pageNumber--;
                }
                if (this.isDynamicPagination(this.paginationParams)) {
                    prevPaginationParams = this.paginationParams;
                    prevPaginationParams.start -= prevPaginationParams.rows;
                }
                return [2 /*return*/, this.search(prevPaginationParams)];
            });
        });
    };
    /**
     * Adds or updates all facet parameters in the given list and returns a new list containing the selected values of all facets
     * on this page.
     * @param paramList The list to be updated
     */
    Page.prototype.addOrUpdateFacetParams = function (paramList) {
        var returnlist = new _urlParamList__WEBPACK_IMPORTED_MODULE_2__["URLParamList"](paramList.list);
        this.facets.forEach(function (facet) {
            var _a;
            var selectedParams = facet.getSelectedParameters();
            returnlist = (_a = returnlist.deleteAll(facet.getFilterParamName())).add.apply(_a, selectedParams);
        });
        return returnlist;
    };
    Page.prototype.search = function (paginationParams) {
        return __awaiter(this, void 0, void 0, function () {
            var fetchParams, params, json, error_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        fetchParams = this.buildFetchParams(paginationParams);
                        params = (_a = this.fetchClient.parameterList).addOrUpdate.apply(_a, fetchParams);
                        this.fetchClient.parameterList = this.addOrUpdateFacetParams(params);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.fetchClient.fetch()];
                    case 2:
                        json = (_b.sent());
                        return [2 /*return*/, new Page(this.fetchClient, json)];
                    case 3:
                        error_1 = _b.sent();
                        throw new Error(error_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    Page.prototype.buildFetchParams = function (paginationParams) {
        var fetchParams = [];
        var transformedQueryParams = this.transformPaginationParamsToFetchParams(paginationParams);
        fetchParams = fetchParams.concat(transformedQueryParams);
        return fetchParams;
    };
    Page.prototype.transformPaginationParamsToFetchParams = function (queryParams) {
        var transformedParams = [];
        if (this.isDynamicPagination(queryParams)) {
            transformedParams = this.buildDynamicPaginationParams(queryParams);
        }
        if (this.isStaticPagination(queryParams)) {
            transformedParams = this.buildStaticPaginationParams(queryParams);
        }
        return transformedParams;
    };
    Page.prototype.buildDynamicPaginationParams = function (queryParams) {
        var paginationParams = [];
        paginationParams.push({ haupia_rows: queryParams.rows.toString() });
        paginationParams.push({ haupia_start: queryParams.start.toString() });
        return paginationParams;
    };
    Page.prototype.buildStaticPaginationParams = function (queryParams) {
        var paginationParams = [];
        paginationParams.push({ haupia_pageNumber: queryParams.pageNumber.toString() });
        paginationParams.push({ haupia_pageSize: queryParams.pageSize.toString() });
        return paginationParams;
    };
    Page.prototype.isDynamicPagination = function (params) {
        return params.rows !== undefined;
    };
    Page.prototype.isStaticPagination = function (params) {
        return params.pageNumber !== undefined;
    };
    return Page;
}());



/***/ }),

/***/ "./dist/lib/pageRenderer.js":
/*!**********************************!*\
  !*** ./dist/lib/pageRenderer.js ***!
  \**********************************/
/*! exports provided: PageRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PageRenderer", function() { return PageRenderer; });
/* harmony import */ var _templates_didYouMeanTemplate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./templates/didYouMeanTemplate */ "./dist/lib/templates/didYouMeanTemplate.js");
/* harmony import */ var _templates_paginationTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./templates/paginationTemplate */ "./dist/lib/templates/paginationTemplate.js");
/* harmony import */ var _templates_searchResultTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./templates/searchResultTemplate */ "./dist/lib/templates/searchResultTemplate.js");



var PAGINATION_ERROR_MESSAGE = "Static pagination parameters are expected.";
/**
 * This class is responsible for rendering the individual elements of a search result page.
 */
var PageRenderer = /** @class */ (function () {
    /**
     * @param page The corresponding page whose content is to be rendered.
     */
    function PageRenderer(page) {
        this.page = page;
        this._didYouMeanTemplate = new _templates_didYouMeanTemplate__WEBPACK_IMPORTED_MODULE_0__["DidYouMeanTemplate"]();
        this._paginationTemplate = new _templates_paginationTemplate__WEBPACK_IMPORTED_MODULE_1__["PaginationTemplate"]();
        this._searchResultTemplate = new _templates_searchResultTemplate__WEBPACK_IMPORTED_MODULE_2__["SearchResultTemplate"]();
    }
    Object.defineProperty(PageRenderer.prototype, "didYouMeanTemplate", {
        /**
         * The 'Did you mean' template that is used to render alternative search suggestions.
         */
        get: function () {
            return this._didYouMeanTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageRenderer.prototype, "paginationTemplate", {
        /**
         * The pagination template that is used to render a single pagination element.
         */
        get: function () {
            return this._paginationTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageRenderer.prototype, "searchResultTemplate", {
        /**
         * The search result template that is used to render the search results.
         */
        get: function () {
            return this._searchResultTemplate;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Renders a next button (if a next page exists) using the [[paginationTemplate]].
     *
     * @param label The label used to describe the button.
     */
    PageRenderer.prototype.renderNextButton = function (label) {
        if (label === void 0) { label = "Next"; }
        if (!this.page.isStaticPagination(this.page.paginationParams)) {
            throw Error(PAGINATION_ERROR_MESSAGE);
        }
        if (this.page.hasNext()) {
            var staticPaginationParams = this.page.paginationParams;
            var nextPageNumber = staticPaginationParams.pageNumber + 1;
            return this.renderPaginationElement(this._paginationTemplate.cssClasses.nextButton, nextPageNumber, this._paginationTemplate.renderNext, label);
        }
    };
    /**
     * Renders a next button (if a next page exists) using the [[paginationTemplate]] and appends it to the element.
     *
     * @param element The HTML element to which the button is attached.
     * @param label The label used to describe the button.
     */
    PageRenderer.prototype.renderNextButtonToHTMLElement = function (element, label) {
        if (label === void 0) { label = "Next"; }
        var nextButton = this.renderNextButton(label);
        if (nextButton) {
            element.append(nextButton);
        }
    };
    /**
     * Renders a previous button (if a previous page exists) using the [[paginationTemplate]].
     *
     * @param label The label used to describe the button.
     */
    PageRenderer.prototype.renderPrevButton = function (label) {
        if (label === void 0) { label = "Prev"; }
        if (!this.page.isStaticPagination(this.page.paginationParams)) {
            throw Error(PAGINATION_ERROR_MESSAGE);
        }
        if (this.page.hasPrev()) {
            var staticPaginationParams = this.page.paginationParams;
            var prevPageNumber = staticPaginationParams.pageNumber - 1;
            return this.renderPaginationElement(this._paginationTemplate.cssClasses.prevButton, prevPageNumber, this._paginationTemplate.renderPrev, label);
        }
    };
    /**
     * Renders a previous button (if a previous page exists) using the [[paginationTemplate]] and appends it to the
     * element.
     *
     * @param element The HTML element to which the button is attached.
     * @param label The label used to describe the button.
     */
    PageRenderer.prototype.renderPrevButtonToHTMLElement = function (element, label) {
        if (label === void 0) { label = "Prev"; }
        var prevButton = this.renderPrevButton(label);
        if (prevButton) {
            element.append(prevButton);
        }
    };
    /**
     * Renders the buttons that are used to navigate to a specific page using the [[paginationTemplate]].
     *
     * @param amount The number of page buttons that are rendered.
     */
    PageRenderer.prototype.renderPageButtons = function (amount) {
        if (!this.page.isStaticPagination(this.page.paginationParams)) {
            throw Error(PAGINATION_ERROR_MESSAGE);
        }
        var staticPaginationParams = this.page.paginationParams;
        var numberOfPages = Math.ceil(this.page.numberOfResults / staticPaginationParams.pageSize);
        var firstPageNumber = this.calculateFirstPageNumber(amount, numberOfPages);
        var renderedPages = [];
        for (var i = 0; i < amount; i++) {
            var pageNumber = firstPageNumber + i;
            var page = this.renderPaginationElement(this._paginationTemplate.cssClasses.pageButton, pageNumber, this._paginationTemplate.renderPage);
            renderedPages.push(page);
            if (firstPageNumber + i + 1 === numberOfPages) {
                break;
            }
        }
        var currentPageNumber = staticPaginationParams.pageNumber;
        this.highlightCurrentPage(renderedPages, currentPageNumber);
        return renderedPages;
    };
    PageRenderer.prototype.calculateFirstPageNumber = function (amount, numberOfPages) {
        var staticPaginationParams = this.page.paginationParams;
        var currentPageNumber = staticPaginationParams.pageNumber;
        var firstPageNumber = currentPageNumber - Math.floor(amount / 2);
        if (Math.ceil(amount / 2) > numberOfPages - currentPageNumber) {
            firstPageNumber -= Math.ceil(amount / 2) - (numberOfPages - currentPageNumber);
        }
        return Math.max(0, firstPageNumber);
    };
    PageRenderer.prototype.highlightCurrentPage = function (pages, currentPageNumber) {
        var _this = this;
        pages
            .filter(function (page) { return page.getAttribute("smart-search-page-value") === currentPageNumber.toString(); })
            .forEach(function (page) {
            var _a;
            return (_a = page.classList).add.apply(_a, _this._paginationTemplate.cssClasses.currentPage);
        });
    };
    /**
     * Renders the buttons that are used to navigate to a specific page using the [[paginationTemplate]] and appends it
     * to the element.
     *
     * @param element The HTML element to which the button is attached.
     * @param amount The number of page buttons that are rendered.
     */
    PageRenderer.prototype.renderPageButtonsToHTMLElement = function (element, amount) {
        element.append.apply(element, this.renderPageButtons(amount));
    };
    /**
     * Renders the complete navigation (previous button, page buttons and next button) using the [[paginationTemplate]].
     *
     * @param amount The number of page buttons that are rendered.
     */
    PageRenderer.prototype.renderPagination = function (amount) {
        var _a;
        var wrapperElement = document.createElement("ul");
        this.renderPrevButtonToHTMLElement(wrapperElement);
        this.renderPageButtonsToHTMLElement(wrapperElement, amount);
        this.renderNextButtonToHTMLElement(wrapperElement);
        (_a = wrapperElement.classList).add.apply(_a, this._paginationTemplate.cssClasses.pagination);
        return wrapperElement;
    };
    /**
     * Renders the complete navigation (previous button, page buttons and next button) using the [[paginationTemplate]]
     * and appends them to the element.
     *
     * @param element The HTML element to which the button is attached.
     * @param amount The number of page buttons that are rendered.
     */
    PageRenderer.prototype.renderPaginationToHTMLElement = function (element, amount) {
        element.append(this.renderPagination(amount));
    };
    PageRenderer.prototype.renderPaginationElement = function (cssClasses, value, renderFunction, label) {
        var _a;
        var element = document.createElement("li");
        (_a = element.classList).add.apply(_a, cssClasses);
        element.setAttribute("smart-search-page-value", value.toString());
        element.innerHTML = renderFunction(label || (value + 1).toString());
        return element;
    };
    /**
     * Renders all search results into a div-element using the [[searchResultTemplate]].
     *
     * @returns An element for you to place wherever you want in your DOM Tree.
     */
    PageRenderer.prototype.renderSearchResults = function () {
        var _a;
        var _this = this;
        var renderedResults = this.page.searchResults.map(function (result) {
            var _a;
            var resultBox = document.createElement("div");
            resultBox.innerHTML = result.render(_this._searchResultTemplate.templateFunction);
            (_a = resultBox.classList).add.apply(_a, _this._searchResultTemplate.cssClasses.element);
            return resultBox;
        });
        var wrapperElement = document.createElement("div");
        (_a = wrapperElement.classList).add.apply(_a, this._searchResultTemplate.cssClasses.wrapper);
        wrapperElement.append.apply(wrapperElement, renderedResults);
        return wrapperElement;
    };
    /**
     * Renders all search results into a div-element using the [[searchResultTemplate]] and appends it to the
     * element.
     *
     * @param element The html div element to attach the search results to.
     */
    PageRenderer.prototype.renderSearchResultsToHTMLElement = function (element) {
        element.appendChild(this.renderSearchResults());
    };
    /**
     * Renders all 'Did you mean' suggestions into a div-element using the provided [[didYouMeanTemplate]].
     *
     * @throws an error if there are no 'Did you mean' search suggestions.
     *
     * @returns An element for you to place wherever you want in your DOM Tree.
     */
    PageRenderer.prototype.renderDidYouMean = function () {
        var _a;
        var _this = this;
        if (this.page.didYouMean.length === 0) {
            throw Error("There are no search query suggestions.");
        }
        var renderedSuggestions = this.page.didYouMean.map(function (suggestion) { return _this._didYouMeanTemplate.renderDidYouMean(suggestion); });
        var returnDiv = document.createElement("div");
        (_a = returnDiv.classList).add.apply(_a, this._didYouMeanTemplate.cssClasses.wrapper);
        returnDiv.insertAdjacentHTML("afterbegin", renderedSuggestions.join(""));
        Array.from(returnDiv.children)
            .forEach(function (element) {
            var _a;
            return (_a = element.classList).add.apply(_a, _this._didYouMeanTemplate.cssClasses.element);
        });
        return returnDiv;
    };
    /**
     * Renders all 'Did you mean' suggestions into a div-element using the provided [[didYouMeanTemplate]] and appends
     * it to the element.
     *
     * @throws an error if there are no 'Did you mean' search suggestions.
     *
     * @param element The html div element to attach the suggestions to.
     */
    PageRenderer.prototype.renderDidYouMeanToHTMLElement = function (element) {
        element.appendChild(this.renderDidYouMean());
    };
    return PageRenderer;
}());



/***/ }),

/***/ "./dist/lib/searchResult.js":
/*!**********************************!*\
  !*** ./dist/lib/searchResult.js ***!
  \**********************************/
/*! exports provided: SearchResult */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchResult", function() { return SearchResult; });
/**
 * Represents a single SmartSearch search result.
 */
var SearchResult = /** @class */ (function () {
    function SearchResult(searchResult, highlights) {
        this.result = searchResult;
        this.highlights = highlights[searchResult.id];
    }
    /**
     * Renders the search result using the passed function.
     *
     * @param templateFunction
     */
    SearchResult.prototype.render = function (templateFunction) {
        return templateFunction(this.result, this.highlights);
    };
    return SearchResult;
}());



/***/ }),

/***/ "./dist/lib/smartSearch.js":
/*!*********************************!*\
  !*** ./dist/lib/smartSearch.js ***!
  \*********************************/
/*! exports provided: SmartSearch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmartSearch", function() { return SmartSearch; });
/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./page */ "./dist/lib/page.js");
/* harmony import */ var _autocompleteWidget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./autocompleteWidget */ "./dist/lib/autocompleteWidget.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../defaults */ "./dist/defaults.js");
/* harmony import */ var _fetchClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetchClient */ "./dist/lib/fetchClient.js");
/* harmony import */ var _pageRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pageRenderer */ "./dist/lib/pageRenderer.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





/**
 * Wrapper for the SmartSearch prepared search API. Main class and entrypoint for this library.
 */
var SmartSearch = /** @class */ (function () {
    /**
     * @param host The hostname including protocol (eg.: https://my.smartsearch.backend).
     * @param preparedSearch The name of the prepared search to address.
     * @param options The additional options to override the default parameters of the API endpoint, the render function
     *  and autocomplete function.
     */
    function SmartSearch(host, preparedSearch, options) {
        var _a, _b, _c;
        this.host = host;
        this.preparedSearch = preparedSearch;
        this.options = options;
        this.apiEndpoint = ((_a = options) === null || _a === void 0 ? void 0 : _a.apiEndpoint) || _defaults__WEBPACK_IMPORTED_MODULE_2__["API_ENDPOINT"];
        var baseURL = "" + this.host + this.apiEndpoint + "/" + this.preparedSearch + "/";
        var fetchClientOptions = {};
        if ((_b = options) === null || _b === void 0 ? void 0 : _b.customParams) {
            if (!Array.isArray(options.customParams)) {
                throw new Error("The customParams property must be an Array");
            }
            fetchClientOptions.customParams = options.customParams;
        }
        this._searchClient = new _fetchClient__WEBPACK_IMPORTED_MODULE_3__["FetchClient"](baseURL, fetchClientOptions);
        var autocompleteWidgetOptions = (_c = options) === null || _c === void 0 ? void 0 : _c.autocompleteOptions;
        var autocompleteClientOptions = fetchClientOptions;
        autocompleteClientOptions.autocomplete = true;
        var autocompleteClient = new _fetchClient__WEBPACK_IMPORTED_MODULE_3__["FetchClient"](baseURL, autocompleteClientOptions);
        this._autocompleteWidget = new _autocompleteWidget__WEBPACK_IMPORTED_MODULE_1__["AutocompleteWidget"](autocompleteClient, autocompleteWidgetOptions);
    }
    Object.defineProperty(SmartSearch.prototype, "searchClient", {
        get: function () {
            return this._searchClient;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SmartSearch.prototype, "autocompleteWidget", {
        get: function () {
            return this._autocompleteWidget;
        },
        enumerable: true,
        configurable: true
    });
    SmartSearch.version = function () {
        return _defaults__WEBPACK_IMPORTED_MODULE_2__["VERSION"];
    };
    /**
     * Sends a search request with the given query term.
     *
     * @param queryTerm The search term to use in the api request.
     * @param customParams One time use only parameters to append to this request
     * @returns The [[Page]] containing all the search results for that page.
     */
    SmartSearch.prototype.search = function (queryTerm) {
        var customParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            customParams[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var params, responseData, error_1;
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        params = (_a = this.searchClient.parameterList
                            .addOrUpdateSearchTerm(queryTerm)).add.apply(_a, customParams);
                        this.searchClient.parameterList = params;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.searchClient.fetch()];
                    case 2:
                        responseData = (_b.sent());
                        this.searchClient.parameterList = params.delete.apply(params, customParams);
                        return [2 /*return*/, new _page__WEBPACK_IMPORTED_MODULE_0__["Page"](this.searchClient, responseData)];
                    case 3:
                        error_1 = _b.sent();
                        this.searchClient.parameterList = params.delete.apply(params, customParams);
                        throw new Error(error_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    SmartSearch.prototype.mapPages = function (responseData, groupField, queryTerm) {
        var groupByField = responseData.groups.find(function (group) { return group.name === groupField; });
        if (groupByField === undefined) {
            throw Error("Searched group not found!");
        }
        var mappedPages = new Map();
        var params = this.searchClient.parameterList.addOrUpdateSearchTerm(queryTerm);
        this.searchClient.parameterList = params;
        for (var _i = 0, _a = groupByField.groups; _i < _a.length; _i++) {
            var group = _a[_i];
            var response = JSON.parse(JSON.stringify(responseData));
            response.results = group.results;
            response.numRows = group.numRows;
            var page = new _page__WEBPACK_IMPORTED_MODULE_0__["Page"](this.searchClient, response);
            mappedPages.set(group.value, page);
        }
        return mappedPages;
    };
    /**
     * Sends a search request with the query term and the grouping options. For the method to work, the following groovy
     * script must be added to the prepared search.
     *
     * <pre><code>
     * def grouping = "off"
     * grouping = parameter.get("grouping")?.get(0)
     * def groupField = parameter.get("groupField")?.get(0)
     * def groupLimit = parameter.get("groupLimit")?.get(0)
     *
     * if (grouping?.equals("on")) {
     *     solrQuery.set("group", true)
     *     solrQuery.set("group.field", groupField)
     *     solrQuery.set("group.limit", groupLimit)
     * }
     * </code></pre>
     *
     * @param queryTerm The search term to use in the api request.
     * @param groupField The name of the field by which to group results.
     * @param groupLimit The number of results to return for each group.
     * @param customParams
     * @returns A map consisting of the group value and the corresponding [[Page]] that contains the search results.
     */
    SmartSearch.prototype.searchWithGroup = function (queryTerm, groupField, groupLimit) {
        var customParams = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            customParams[_i - 3] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var queryParams, params, responseData, error_2;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        queryParams = [
                            { query: queryTerm },
                            { grouping: "on" },
                            { groupField: groupField },
                            { groupLimit: groupLimit.toString() },
                        ];
                        params = (_a = (_b = this.searchClient.parameterList).addOrUpdate.apply(_b, queryParams)).add.apply(_a, customParams);
                        this.searchClient.parameterList = params;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.searchClient.fetch()];
                    case 2:
                        responseData = (_c.sent());
                        this.searchClient.parameterList = params.delete.apply(params, customParams);
                        return [2 /*return*/, this.mapPages(responseData, groupField, queryTerm)];
                    case 3:
                        error_2 = _c.sent();
                        this.searchClient.parameterList = params.delete.apply(params, customParams);
                        throw new Error(error_2);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Fetches the autocomplete suggestions matching the given prefix from the backend. The resulting array always has
     * the length <strong>5</strong> and is sorted by relevance.
     *
     * @param prefix What the user typed so far.
     * @param options
     */
    SmartSearch.prototype.fetchAutocompleteList = function (prefix, options) {
        return this.autocompleteWidget.getAutocompleteList(prefix, options);
    };
    // TODO: The CSS-classes should be configurable. The API comment should then be moved to the newly created constant.
    /**
     * This function attaches an autocomplete widget to the given input element. The css styling classes are:
     *
     * <code>.smart-search-autocomplete-widget</code> will be attached to the div-container displaying the list of autocomplete
     *  suggestions.<br>
     * <code>.smart-search-autocomplete-active</code> will be attached to the cursor for the actively selected autocomplete widget
     *  .<br>
     * <code>.smart-search-autocomplete-item</code> will be attached to a single autocomplete suggestion.<br>
     * <code>#inputElement.id autocomplete-widget</code> will be attached to the autocomplete-list.
     *
     * @param inputElement The input element to attach this widget to
     * @param renderTarget Optional. A div to attach the autocomplete widget to. If this parameter is left empty,
     * the widget will be attached to the parent of the input element.
     */
    SmartSearch.prototype.attachAutocompleteWidget = function (inputElement, renderTarget) {
        this.autocompleteWidget.initializeAndAttach(inputElement, renderTarget);
    };
    /**
     * Returns a page renderer object that provides functions to render pagination and search results
     * @param page the page to berendered
     */
    SmartSearch.prototype.getPageRenderer = function (page) {
        return new _pageRenderer__WEBPACK_IMPORTED_MODULE_4__["PageRenderer"](page);
    };
    return SmartSearch;
}());



/***/ }),

/***/ "./dist/lib/templates/didYouMeanTemplate.js":
/*!**************************************************!*\
  !*** ./dist/lib/templates/didYouMeanTemplate.js ***!
  \**************************************************/
/*! exports provided: DidYouMeanTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DidYouMeanTemplate", function() { return DidYouMeanTemplate; });
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../defaults */ "./dist/defaults.js");

/**
 * Represents the desired shape of the 'Did you mean' search query suggestions.
 */
var DidYouMeanTemplate = /** @class */ (function () {
    function DidYouMeanTemplate() {
        this.cssClasses = this.initDefaultClasses();
        this.renderDidYouMean = _defaults__WEBPACK_IMPORTED_MODULE_0__["DID_YOU_MEAN_FUNCTION"];
    }
    DidYouMeanTemplate.prototype.initDefaultClasses = function () {
        return {
            wrapper: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_DID_YOU_MEAN_WRAPPER"]],
            element: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_DID_YOU_MEAN_ELEMENT"]],
        };
    };
    return DidYouMeanTemplate;
}());



/***/ }),

/***/ "./dist/lib/templates/paginationTemplate.js":
/*!**************************************************!*\
  !*** ./dist/lib/templates/paginationTemplate.js ***!
  \**************************************************/
/*! exports provided: PaginationTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PaginationTemplate", function() { return PaginationTemplate; });
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../defaults */ "./dist/defaults.js");

/**
 * Represents the users desired shape of the pagination. If you want to change the appearance of the pagination buttons
 * you can write and use your custom render function. The default appearance would be
 * ```
 * prev 1 2 3 4 5 next
 * ```
 * If you wanted your pagination to instead look like this
 * ```
 * < 1 2 3 4 5 >
 * ```
 * You would have to write custom renderNext and renderPrev functions like this
 * ```
 * page.paginationTemplate.renderNext = (value) => {
 *      return `>`
 * }
 * page.paginationTemplate.renderPrev = (value) => {
 *      return `<`
 * }
 * ```
 * Whatever gets returned by your function will be wrapped in a \<li> tag
 */
var PaginationTemplate = /** @class */ (function () {
    /**
     * @param renderPaginationFunction The function to render a single pagination element, eg. the previous button.
     * @param cssClasses The CSS classes that are attached to the elements.
     */
    function PaginationTemplate() {
        this.cssClasses = this.initDefaultClasses();
        this.renderNext = _defaults__WEBPACK_IMPORTED_MODULE_0__["PAGINATION_FUNCTION"];
        this.renderPage = _defaults__WEBPACK_IMPORTED_MODULE_0__["PAGINATION_FUNCTION"];
        this.renderPrev = _defaults__WEBPACK_IMPORTED_MODULE_0__["PAGINATION_FUNCTION"];
    }
    PaginationTemplate.prototype.initDefaultClasses = function () {
        return {
            pagination: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_PAGINATION"]],
            nextButton: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_NEXT_BUTTON"]],
            prevButton: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_PREV_BUTTON"]],
            pageButton: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_PAGE_BUTTON"]],
            currentPage: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_CURRENT_PAGE"]],
        };
    };
    return PaginationTemplate;
}());



/***/ }),

/***/ "./dist/lib/templates/searchResultTemplate.js":
/*!****************************************************!*\
  !*** ./dist/lib/templates/searchResultTemplate.js ***!
  \****************************************************/
/*! exports provided: SearchResultTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SearchResultTemplate", function() { return SearchResultTemplate; });
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../defaults */ "./dist/defaults.js");

/**
 * Represents the users desired shape of the [[SearchResult]] data.
 */
var SearchResultTemplate = /** @class */ (function () {
    function SearchResultTemplate() {
        this.cssClasses = this.initDefaultClasses();
        this.templateFunction = _defaults__WEBPACK_IMPORTED_MODULE_0__["SEARCH_RESULT_FUNCTION"];
    }
    SearchResultTemplate.prototype.initDefaultClasses = function () {
        return {
            wrapper: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_SEARCH_RESULT_WRAPPER"]],
            element: [_defaults__WEBPACK_IMPORTED_MODULE_0__["CSS_SEARCH_RESULT_ELEMENT"]],
        };
    };
    return SearchResultTemplate;
}());



/***/ }),

/***/ "./dist/lib/urlParamList.js":
/*!**********************************!*\
  !*** ./dist/lib/urlParamList.js ***!
  \**********************************/
/*! exports provided: URLParamList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "URLParamList", function() { return URLParamList; });
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immutable */ "./node_modules/immutable/dist/immutable.es.js");

/**
 * This class represents the URL parameters used within each request sent to the SmartSearch backend.
 */
var URLParamList = /** @class */ (function () {
    function URLParamList(params) {
        this._list = Object(immutable__WEBPACK_IMPORTED_MODULE_0__["List"])([]).concat(params || []);
    }
    Object.defineProperty(URLParamList.prototype, "list", {
        /**
         * Contains the parameters that are going to be referenced in the methods down below.
         */
        get: function () {
            return this._list;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the given parameters or updates them if they already exist.
     *
     * If there are multiple parameters with the same key, only the first parameter is updated. If you want to update
     * multiple parameters with the same key use the [[deleteAll]] function first then add the new parameters using
     * [[add]]
     *
     * @param parameters The parameters to add or to update.
     *
     * @returns A new list with the new or modified parameters.
     */
    URLParamList.prototype.addOrUpdate = function () {
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        var updatedList = new URLParamList(this.list);
        for (var _a = 0, parameters_1 = parameters; _a < parameters_1.length; _a++) {
            var parameter = parameters_1[_a];
            var key = this.convert(parameter)[0];
            var index = updatedList.getIndexForKey(key);
            if (index !== -1) {
                updatedList = new URLParamList(updatedList.list.set(index, parameter));
            }
            else {
                updatedList = updatedList.add(parameter);
            }
        }
        return updatedList;
    };
    /**
     * Adds a search term as parameter (with the key *query*) or updates it if a search term already exists.
     *
     * @param searchTerm The search term to add or update.
     *
     * @returns A new list with the new or modified search term. If the search term is empty, a copy of the original
     * list will be returned.
     */
    URLParamList.prototype.addOrUpdateSearchTerm = function (searchTerm) {
        var list = this.list;
        if (!searchTerm) {
            return new URLParamList(list);
        }
        return this.addOrUpdate({ query: searchTerm });
    };
    /**
     * Adds all given parameters.
     *
     * @param parameters The parameters to add.
     *
     * @returns A new list with the new parameters.
     */
    URLParamList.prototype.add = function () {
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        var list = this.list.concat(parameters);
        return new URLParamList(list);
    };
    /**
     * Converts a single [[URLParam]] into a string array of length 2, with key at position 0 and value at position 1.
     *
     * @param parameter The parameter to convert.
     */
    URLParamList.prototype.convert = function (parameter) {
        var key = Object.keys(parameter)[0];
        var value = parameter[key];
        return [key, value];
    };
    /**
     * Returns the first parameter matching the given key.
     *
     * @param key The key of the searched parameter.
     */
    URLParamList.prototype.getOne = function (key) {
        return this.list.find(function (parameter) { return Object.keys(parameter)[0] === key; }) || null;
    };
    /**
     * Returns all parameters matching the given key.
     *
     * @param key The key of the searched parameters.
     */
    URLParamList.prototype.getMany = function (key) {
        var _this = this;
        return this.list.filter(function (parameter) {
            var parameterKey = _this.convert(parameter)[0];
            return key === parameterKey;
        });
    };
    /**
     * Deletes all parameters matching the given key.
     *
     * @param key The key of the parameters to be deleted.
     *
     * @returns A new list without the deleted parameters.
     */
    URLParamList.prototype.deleteAll = function (key) {
        return new URLParamList(this.list.filter(function (parameter) { return Object.keys(parameter)[0] !== key; }));
    };
    /**
     * Deletes all parameters matching both keys and values.
     *
     * @param parameters The parameters to be deleted.
     *
     * @return A new list without the deleted parameters.
     */
    URLParamList.prototype.delete = function () {
        var parameters = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            parameters[_i] = arguments[_i];
        }
        var updatedList = new URLParamList(this.list);
        parameters.forEach(function (parameter) {
            var index = updatedList.getIndexForParameter(parameter);
            updatedList = new URLParamList(updatedList.list.delete(index));
        });
        return updatedList;
    };
    /**
     * Converts the stored parameters into a string that can be appended to a URL.
     */
    URLParamList.prototype.toString = function () {
        var _this = this;
        var searchParams = new URLSearchParams();
        this.list.forEach(function (parameter) {
            var key = _this.convert(parameter)[0];
            searchParams.append(key, parameter[key]);
        });
        return searchParams.toString();
    };
    URLParamList.prototype.toArray = function () {
        return this.list.toArray();
    };
    /**
     * Updates the first parameter matching the key if it exists.
     *
     * Use this only if you know your parameter is unique. For updating all parameters with the same key, delete them
     * first using [[deleteAll]] and then add the new ones.
     *
     * @param parameter The parameter to update.
     *
     * @returns A new list with the updated parameter. If the parameter's key doesn't exist, a copy of the original list
     * will be returned.
     */
    URLParamList.prototype.updateFirst = function (parameter) {
        var list = this.list;
        var key = this.convert(parameter)[0];
        var index = this.getIndexForKey(key);
        if (index !== -1) {
            return new URLParamList(list.set(index, parameter));
        }
        return new URLParamList(list);
    };
    /**
     * Updates a specific parameter matching both key and value with the given new parameter.
     *
     * @param oldParameter The parameter to update.
     * @param newParameter The new parameter to update to.
     *
     * @returns A new list with the updated parameter.
     */
    URLParamList.prototype.update = function (oldParameter, newParameter) {
        var list = this.list;
        var index = this.getIndexForParameter(oldParameter);
        return new URLParamList(list.set(index, newParameter));
    };
    /** @hidden */
    URLParamList.prototype.getIndexForKey = function (key) {
        return this.list.findIndex(function (listParam) {
            var listParamKey = Object.keys(listParam)[0];
            return listParamKey === key;
        });
    };
    /** @hidden */
    URLParamList.prototype.getIndexForParameter = function (parameter) {
        var _this = this;
        return this.list.findIndex(function (listParam) {
            var _a = _this.convert(listParam), listParamKey = _a[0], listParamValue = _a[1];
            var _b = _this.convert(parameter), key = _b[0], value = _b[1];
            return listParamKey === key && listParamValue === value;
        });
    };
    return URLParamList;
}());



/***/ }),

/***/ "./node_modules/baconjs/dist/Bacon.js":
/*!********************************************!*\
  !*** ./node_modules/baconjs/dist/Bacon.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
 true ? factory(exports) :
undefined;
}(this, function (exports) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/** @hidden */
function nop() { }
/** @hidden */
var isArray = Array.isArray || function (xs) { return xs instanceof Array; };
/** @hidden */
function isObservable(x) {
    return x && x._isObservable;
}

/** @hidden */
function all(xs, f) {
    for (var i = 0, x; i < xs.length; i++) {
        x = xs[i];
        if (!f(x)) {
            return false;
        }
    }
    return true;
}
/** @hidden */
function always(x) { return function () { return x; }; }
/** @hidden */
function any(xs, f) {
    for (var i = 0, x; i < xs.length; i++) {
        x = xs[i];
        if (f(x)) {
            return true;
        }
    }
    return false;
}
/** @hidden */
function bind(fn, me) {
    return function () { return fn.apply(me, arguments); };
}
/** @hidden */
function contains(xs, x) { return indexOf(xs, x) !== -1; }
/** @hidden */
function each(xs, f) {
    for (var key in xs) {
        if (Object.prototype.hasOwnProperty.call(xs, key)) {
            var value = xs[key];
            f(key, value);
        }
    }
}
/** @hidden */
function empty(xs) { return xs.length === 0; }
/** @hidden */
function filter(f, xs) {
    var filtered = [];
    for (var i = 0, x; i < xs.length; i++) {
        x = xs[i];
        if (f(x)) {
            filtered.push(x);
        }
    }
    return filtered;
}
/** @hidden */
function flatMap(f, xs) {
    return fold(xs, [], (function (ys, x) {
        return ys.concat(f(x));
    }));
}
/** @hidden */
function flip(f) {
    return function (a, b) { return f(b, a); };
}
/** @hidden */
function fold(xs, seed, f) {
    for (var i = 0, x; i < xs.length; i++) {
        x = xs[i];
        seed = f(seed, x);
    }
    return seed;
}
/** @hidden */
function head(xs) {
    return xs[0];
}
/** @hidden */
function id(x) { return x; }
/** @hidden */
function indexOfDefault(xs, x) { return xs.indexOf(x); }
/** @hidden */
function indexOfFallback(xs, x) {
    for (var i = 0, y; i < xs.length; i++) {
        y = xs[i];
        if (x === y) {
            return i;
        }
    }
    return -1;
}
/** @hidden */
var indexOf = Array.prototype.indexOf ? indexOfDefault : indexOfFallback;
/** @hidden */
function indexWhere(xs, f) {
    for (var i = 0, y; i < xs.length; i++) {
        y = xs[i];
        if (f(y)) {
            return i;
        }
    }
    return -1;
}
/** @hidden */
function isFunction(f) { return typeof f === "function"; }
/** @hidden */
function last(xs) { return xs[xs.length - 1]; }
/** @hidden */
function map(f, xs) {
    var result = [];
    for (var i = 0, x; i < xs.length; i++) {
        x = xs[i];
        result.push(f(x));
    }
    return result;
}
/** @hidden */
function negate(f) { return function (x) { return !f(x); }; }
/** @hidden */
function remove(x, xs) {
    var i = indexOf(xs, x);
    if (i >= 0) {
        return xs.splice(i, 1);
    }
}
/** @hidden */
function tail(xs) {
    return xs.slice(1, xs.length);
}
/** @hidden */
function toArray(xs) { return (isArray(xs) ? xs : [xs]); }
/** @hidden */
function toFunction(f) {
    if (typeof f == "function") {
        return f;
    }
    return function (x) { return f; };
}
/** @hidden */
function toString(obj) {
    var hasProp = {}.hasOwnProperty;
    try {
        recursionDepth++;
        if (obj == null) {
            return "undefined";
        }
        else if (isFunction(obj)) {
            return "function";
        }
        else if (isArray(obj)) {
            if (recursionDepth > 5) {
                return "[..]";
            }
            return "[" + map(toString, obj).toString() + "]";
        }
        else if (((obj != null ? obj.toString : void 0) != null) && obj.toString !== Object.prototype.toString) {
            return obj.toString();
        }
        else if (typeof obj === "object") {
            if (recursionDepth > 5) {
                return "{..}";
            }
            var results = [];
            for (var key in obj) {
                if (!hasProp.call(obj, key))
                    continue;
                var value = (function () {
                    try {
                        return obj[key];
                    }
                    catch (error) {
                        return error;
                    }
                })();
                results.push(toString(key) + ":" + toString(value));
            }
            return "{" + results + "}";
        }
        else {
            return obj;
        }
    }
    finally {
        recursionDepth--;
    }
}
/** @hidden */
function without(x, xs) {
    return filter((function (y) { return y !== x; }), xs);
}
var _ = {
    indexOf: indexOf,
    indexWhere: indexWhere,
    head: head,
    always: always,
    negate: negate,
    empty: empty,
    tail: tail,
    filter: filter,
    map: map,
    each: each,
    toArray: toArray,
    contains: contains,
    id: id,
    last: last,
    all: all,
    any: any,
    without: without,
    remove: remove,
    fold: fold,
    flatMap: flatMap,
    bind: bind,
    isFunction: isFunction,
    toFunction: toFunction,
    toString: toString
};
var recursionDepth = 0;

/**
 * Reply for "more data, please".
 */
var more = undefined;
/**
 * Reply for "no more data, please".
 */
var noMore = "<no-more>";

/** @hidden */
function assert(message, condition) {
    if (!condition) {
        throw new Error(message);
    }
}
/** @hidden */
function assertEventStream(event) {
    if (!(event != null ? event._isEventStream : void 0)) {
        throw new Error("not an EventStream : " + event);
    }
}
/** @hidden */
function assertObservable(observable) {
    if (!(observable != null ? observable._isObservable : void 0)) {
        throw new Error("not an Observable : " + observable);
    }
}
/** @hidden */
function assertFunction(f) {
    return assert("not a function : " + f, _.isFunction(f));
}
/** @hidden */
function assertArray(xs) {
    if (!isArray(xs)) {
        throw new Error("not an array : " + xs);
    }
}
/** @hidden */
function assertNoArguments(args) {
    return assert("no arguments supported", args.length === 0);
}

/** @hidden */
var defaultScheduler = {
    setTimeout: function (f, d) { return setTimeout(f, d); },
    setInterval: function (f, i) { return setInterval(f, i); },
    clearInterval: function (id) { return clearInterval(id); },
    clearTimeout: function (id) { return clearTimeout(id); },
    now: function () { return new Date().getTime(); }
};
var GlobalScheduler = {
    scheduler: defaultScheduler
};
function getScheduler() {
    return GlobalScheduler.scheduler;
}
function setScheduler(newScheduler) {
    GlobalScheduler.scheduler = newScheduler;
}

var rootEvent = undefined;
var waiterObs = [];
var waiters = {};
var aftersStack = [];
var aftersStackHeight = 0;
var flushed = {};
var processingAfters = false;
function toString$1() {
    return _.toString({ rootEvent: rootEvent, processingAfters: processingAfters, waiterObs: waiterObs, waiters: waiters, aftersStack: aftersStack, aftersStackHeight: aftersStackHeight, flushed: flushed });
}
function ensureStackHeight(h) {
    if (h <= aftersStackHeight)
        return;
    if (!aftersStack[h - 1]) {
        aftersStack[h - 1] = [[], 0];
    }
    aftersStackHeight = h;
}
function isInTransaction() {
    return rootEvent !== undefined;
}
function soonButNotYet(obs, f) {
    if (rootEvent) {
        // If in transaction -> perform within transaction
        //console.log('in tx')
        whenDoneWith(obs, f);
    }
    else {
        // Otherwise -> perform with timeout
        //console.log('with timeout')
        GlobalScheduler.scheduler.setTimeout(f, 0);
    }
}
function afterTransaction(obs, f) {
    if (rootEvent || processingAfters) {
        ensureStackHeight(1);
        var stackIndexForThisObs = 0;
        while (stackIndexForThisObs < aftersStackHeight - 1) {
            if (containsObs(obs, aftersStack[stackIndexForThisObs][0])) {
                // this observable is already being processed at this stack index -> use this index
                break;
            }
            stackIndexForThisObs++;
        }
        var listFromStack = aftersStack[stackIndexForThisObs][0];
        listFromStack.push([obs, f]);
        if (!rootEvent) {
            processAfters(); // wouldn't be called otherwise
        }
    }
    else {
        return f();
    }
}
function containsObs(obs, aftersList) {
    for (var i = 0; i < aftersList.length; i++) {
        if (aftersList[i][0].id == obs.id)
            return true;
    }
    return false;
}
function processAfters() {
    var stackSizeAtStart = aftersStackHeight;
    if (!stackSizeAtStart)
        return;
    var isRoot = !processingAfters;
    processingAfters = true;
    try {
        while (aftersStackHeight >= stackSizeAtStart) { // to prevent sinking to levels started by others
            var topOfStack = aftersStack[aftersStackHeight - 1];
            if (!topOfStack)
                throw new Error("Unexpected stack top: " + topOfStack);
            var topAfters = topOfStack[0], index = topOfStack[1];
            if (index < topAfters.length) {
                var _a = topAfters[index], after = _a[1];
                topOfStack[1]++; // increase index already here to indicate that this level is being processed
                ensureStackHeight(aftersStackHeight + 1); // to ensure there's a new level for recursively added afters
                var callSuccess = false;
                try {
                    after();
                    callSuccess = true;
                    while (aftersStackHeight > stackSizeAtStart && aftersStack[aftersStackHeight - 1][0].length == 0) {
                        aftersStackHeight--;
                    }
                }
                finally {
                    if (!callSuccess) {
                        aftersStack = [];
                        aftersStackHeight = 0; // reset state to prevent stale updates after error
                    }
                }
            }
            else {
                topOfStack[0] = [];
                topOfStack[1] = 0; // reset this level
                break;
            }
        }
    }
    finally {
        if (isRoot)
            processingAfters = false;
    }
}
function whenDoneWith(obs, f) {
    if (rootEvent) {
        var obsWaiters = waiters[obs.id];
        if (obsWaiters === undefined) {
            obsWaiters = waiters[obs.id] = [f];
            return waiterObs.push(obs);
        }
        else {
            return obsWaiters.push(f);
        }
    }
    else {
        return f();
    }
}
function flush() {
    while (waiterObs.length > 0) {
        flushWaiters(0, true);
    }
    flushed = {};
}
function flushWaiters(index, deps) {
    var obs = waiterObs[index];
    var obsId = obs.id;
    var obsWaiters = waiters[obsId];
    waiterObs.splice(index, 1);
    delete waiters[obsId];
    if (deps && waiterObs.length > 0) {
        flushDepsOf(obs);
    }
    for (var i = 0, f; i < obsWaiters.length; i++) {
        f = obsWaiters[i];
        f();
    }
}
function flushDepsOf(obs) {
    if (flushed[obs.id])
        return;
    var deps = obs.internalDeps();
    for (var i = 0, dep; i < deps.length; i++) {
        dep = deps[i];
        flushDepsOf(dep);
        if (waiters[dep.id]) {
            var index = _.indexOf(waiterObs, dep);
            flushWaiters(index, false);
        }
    }
    flushed[obs.id] = true;
}
function inTransaction(event, context, f, args) {
    if (rootEvent) {
        //console.log("in tx")
        return f.apply(context, args);
    }
    else {
        //console.log("start tx")
        rootEvent = event;
        try {
            var result = f.apply(context, args);
            //console.log("done with tx")
            flush();
        }
        finally {
            rootEvent = undefined;
            processAfters();
        }
        return result;
    }
}
function currentEventId() {
    return rootEvent ? rootEvent.id : undefined;
}
function wrappedSubscribe(obs, subscribe, sink) {
    assertFunction(sink);
    var unsubd = false;
    var shouldUnsub = false;
    var doUnsub = function () {
        shouldUnsub = true;
    };
    var unsub = function () {
        unsubd = true;
        doUnsub();
    };
    doUnsub = subscribe(function (event) {
        afterTransaction(obs, function () {
            if (!unsubd) {
                var reply = sink(event);
                if (reply === noMore) {
                    unsub();
                }
            }
        });
        return more;
    });
    if (shouldUnsub) {
        doUnsub();
    }
    return unsub;
}
function hasWaiters() { return waiterObs.length > 0; }
var UpdateBarrier = { toString: toString$1, whenDoneWith: whenDoneWith, hasWaiters: hasWaiters, inTransaction: inTransaction, currentEventId: currentEventId, wrappedSubscribe: wrappedSubscribe, afterTransaction: afterTransaction, soonButNotYet: soonButNotYet, isInTransaction: isInTransaction };

var Desc = /** @class */ (function () {
    function Desc(context, method, args) {
        if (args === void 0) { args = []; }
        /** @hidden */
        this._isDesc = true;
        //assert("context missing", context)
        //assert("method missing", method)
        //assert("args missing", args)
        this.context = context;
        this.method = method;
        this.args = args;
    }
    Desc.prototype.deps = function () {
        if (!this.cachedDeps) {
            this.cachedDeps = findDeps([this.context].concat(this.args));
        }
        return this.cachedDeps;
    };
    Desc.prototype.toString = function () {
        var args = _.map(_.toString, this.args);
        return _.toString(this.context) + "." + _.toString(this.method) + "(" + args + ")";
    };
    return Desc;
}());
/** @hidden */
function describe(context, method) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    var ref = context || method;
    if (ref && ref._isDesc) {
        return context || method;
    }
    else {
        return new Desc(context, method, args);
    }
}
/** @hidden */
function findDeps(x) {
    if (isArray(x)) {
        return _.flatMap(findDeps, x);
    }
    else if (isObservable(x)) {
        return [x];
    }
    else if ((typeof x !== "undefined" && x !== null) ? x._isSource : undefined) {
        return [x.obs];
    }
    else {
        return [];
    }
}

/** @hidden */
var nullSink = function () { return more; };
/** @hidden */
var nullVoidSink = function () { return more; };

/** @hidden */
function withStateMachine(initState, f, src) {
    return src.transform(withStateMachineT(initState, f), new Desc(src, "withStateMachine", [initState, f]));
}
function withStateMachineT(initState, f) {
    var state = initState;
    return function (event, sink) {
        var fromF = f(state, event);
        var newState = fromF[0], outputs = fromF[1];
        state = newState;
        var reply = more;
        for (var i = 0; i < outputs.length; i++) {
            var output = outputs[i];
            reply = sink(output);
            if (reply === noMore) {
                return reply;
            }
        }
        return reply;
    };
}

/** @hidden */
var Some = /** @class */ (function () {
    function Some(value) {
        this._isSome = true;
        this.isDefined = true;
        this.value = value;
    }
    Some.prototype.getOrElse = function (arg) { return this.value; };
    Some.prototype.get = function () { return this.value; };
    Some.prototype.filter = function (f) {
        if (f(this.value)) {
            return new Some(this.value);
        }
        else {
            return None;
        }
    };
    Some.prototype.map = function (f) {
        return new Some(f(this.value));
    };
    Some.prototype.forEach = function (f) {
        f(this.value);
    };
    Some.prototype.toArray = function () { return [this.value]; };
    Some.prototype.inspect = function () { return "Some(" + this.value + ")"; };
    Some.prototype.toString = function () { return this.inspect(); };
    return Some;
}());
/** @hidden */
var None = {
    _isNone: true,
    getOrElse: function (value) { return value; },
    get: function () { throw new Error("None.get()"); },
    filter: function () { return None; },
    map: function () { return None; },
    forEach: function () { },
    isDefined: false,
    toArray: function () { return []; },
    inspect: function () { return "None"; },
    toString: function () { return this.inspect(); }
};
function none() { return None; }
function toOption(v) {
    if (v && (v._isSome || v._isNone)) {
        return v;
    }
    else {
        return new Some(v);
    }
}
function isNone(object) {
    return ((typeof object !== "undefined" && object !== null) ? object._isNone : false);
}

/** @hidden */
var eventIdCounter = 0;
/**
 * Base class for all events passed through [EventStreams](eventstream.html) and [Properties](property.html).
 */
var Event = /** @class */ (function () {
    function Event() {
        this.id = ++eventIdCounter;
        /** @hidden */
        this.isEvent = true;
        /** @hidden */
        this._isEvent = true;
        this.isEnd = false;
        this.isInitial = false;
        this.isNext = false;
        this.isError = false;
        this.hasValue = false;
    }
    /** @hidden */
    Event.prototype.filter = function (f) { return true; };
    /** @hidden */
    Event.prototype.inspect = function () { return this.toString(); };
    /** @hidden */
    Event.prototype.log = function () { return this.toString(); };
    /** @hidden */
    Event.prototype.toNext = function () { return this; };
    return Event;
}());
/**
 *  Base class for all [Events](event.html) carrying a value.
 *
 *  Can be distinguished from other events using [hasValue](../globals.html#hasvalue)
 **/
var Value = /** @class */ (function (_super) {
    __extends(Value, _super);
    function Value(value) {
        var _this = _super.call(this) || this;
        _this.hasValue = true;
        if (value instanceof Event) {
            throw new Error$1("Wrapping an event inside other event");
        }
        _this.value = value;
        return _this;
    }
    /** @hidden */
    Value.prototype.fmap = function (f) {
        return this.apply(f(this.value));
    };
    /** @hidden */
    Value.prototype.filter = function (f) { return f(this.value); };
    /** @hidden */
    Value.prototype.toString = function () { return _.toString(this.value); };
    //toString(): string { return "<value " + this.id + ">" + _.toString(this.value) }
    /** @hidden */
    Value.prototype.log = function () { return this.value; };
    return Value;
}(Event));
/**
 *  Indicates a new value in an [EventStream](eventstream.html) or a [Property](property.html).
 *
 *  Can be distinguished from other events using [isNext](../globals.html#isnext)
 */
var Next = /** @class */ (function (_super) {
    __extends(Next, _super);
    function Next(value) {
        var _this = _super.call(this, value) || this;
        _this.isNext = true;
        /** @hidden */
        _this._isNext = true; // some compatibility stuff?
        return _this;
    }
    /** @hidden */
    Next.prototype.apply = function (value) { return new Next(value); };
    return Next;
}(Value));
/**
 * An event carrying the initial value of a [Property](classes/property.html). This event can be emitted by a property
 * immediately when subscribing to it.
 *
 * Can be distinguished from other events using [isInitial](../globals.html#isinitial)
 */
var Initial = /** @class */ (function (_super) {
    __extends(Initial, _super);
    function Initial(value) {
        var _this = _super.call(this, value) || this;
        _this.isInitial = true;
        /** @hidden */
        _this._isInitial = true;
        return _this;
    }
    /** @hidden */
    Initial.prototype.apply = function (value) { return new Initial(value); };
    /** @hidden */
    Initial.prototype.toNext = function () { return new Next(this.value); };
    return Initial;
}(Value));
/**
 * Base class for events not carrying a value.
 */
var NoValue = /** @class */ (function (_super) {
    __extends(NoValue, _super);
    function NoValue() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    /** @hidden */
    NoValue.prototype.fmap = function (f) {
        return this;
    };
    return NoValue;
}(Event));
/**
 * An event that indicates the end of an [EventStream](classes/eventstream.html) or a [Property](classes/property.html).
 * No more events can be emitted after this one.
 *
 * Can be distinguished from other events using [isEnd](../globals.html#isend)
 */
var End = /** @class */ (function (_super) {
    __extends(End, _super);
    function End() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isEnd = true;
        return _this;
    }
    /** @hidden */
    End.prototype.toString = function () { return "<end>"; };
    return End;
}(NoValue));
/**
 *  An event carrying an error. You can use [onError](observable.html#onerror) to subscribe to errors.
 */
var Error$1 = /** @class */ (function (_super) {
    __extends(Error, _super);
    function Error(error) {
        var _this = _super.call(this) || this;
        _this.isError = true;
        _this.error = error;
        return _this;
    }
    /** @hidden */
    Error.prototype.toString = function () {
        return "<error> " + _.toString(this.error);
    };
    return Error;
}(NoValue));
/** @hidden */
function initialEvent(value) { return new Initial(value); }
/** @hidden */
function nextEvent(value) { return new Next(value); }
/** @hidden */
function endEvent() { return new End(); }
/** @hidden */
function toEvent(x) {
    if (x && x._isEvent) {
        return x;
    }
    else {
        return nextEvent(x);
    }
}
/**
 * Returns true if the given object is an [Event](classes/event.html).
 */
function isEvent(e) {
    return e && e._isEvent;
}
/**
 * Returns true if the given event is an [Initial](classes/initial.html) value of a [Property](classes/property.html).
 */
function isInitial(e) {
    return e && e._isInitial;
}
/**
 * Returns true if the given event is an [Error](classes/error.html) event of an [Observable](classes/observable.html).
 */
function isError(e) {
    return e.isError;
}
/**
 * Returns true if the given event is a [Value](classes/value.html), i.e. a [Next](classes/next.html) or
 * an [Initial](classes/error.html) value of an [Observable](classes/observable.html).
 */
function hasValue(e) {
    return e.hasValue;
}
/**
 * Returns true if the given event is an [End](classes/end.html)
 */
function isEnd(e) {
    return e.isEnd;
}
/**
 * Returns true if the given event is a [Next](classes/next.html)
 */
function isNext(e) {
    return e.isNext;
}

/** @hidden */
function equals(a, b) { return a === b; }
/** @hidden */
function skipDuplicates(src, isEqual) {
    if (isEqual === void 0) { isEqual = equals; }
    var desc = new Desc(src, "skipDuplicates", []);
    return withStateMachine(none(), function (prev, event) {
        if (!hasValue(event)) {
            return [prev, [event]];
        }
        else if (event.isInitial || isNone(prev) || !isEqual(prev.get(), event.value)) {
            return [new Some(event.value), [event]];
        }
        else {
            return [prev, []];
        }
    }, src).withDesc(desc);
}

/** @hidden */
function take(count, src, desc) {
    return src.transform(takeT(count), desc || new Desc(src, "take", [count]));
}
/** @hidden */
function takeT(count) {
    return function (e, sink) {
        if (!e.hasValue) {
            return sink(e);
        }
        else {
            count--;
            if (count > 0) {
                return sink(e);
            }
            else {
                if (count === 0) {
                    sink(e);
                }
                sink(endEvent());
                return noMore;
            }
        }
    };
}

/** @hidden */
function log(args, src) {
    src.subscribe(function (event) {
        if (typeof console !== "undefined" && typeof console.log === "function") {
            console.log.apply(console, args.concat([event.log()]));
        }
        return more;
    });
}

/** @hidden */
function doLogT(args) {
    return function (event, sink) {
        if (typeof console !== "undefined" && console !== null && typeof console.log === "function") {
            console.log.apply(console, args.concat([event.log()]));
        }
        return sink(event);
    };
}

/** @hidden */
function doErrorT(f) {
    return function (event, sink) {
        if (isError(event)) {
            f(event.error);
        }
        return sink(event);
    };
}

/** @hidden */
function doActionT(f) {
    return function (event, sink) {
        if (hasValue(event)) {
            f(event.value);
        }
        return sink(event);
    };
}

/** @hidden */
function doEndT(f) {
    return function (event, sink) {
        if (isEnd(event)) {
            f();
        }
        return sink(event);
    };
}

/** @hidden */
function scan(src, seed, f) {
    var resultProperty;
    var acc = seed;
    var initHandled = false;
    var subscribe = function (sink) {
        var initSent = false;
        var unsub = nop;
        var reply = more;
        var sendInit = function () {
            if (!initSent) {
                initSent = initHandled = true;
                reply = sink(new Initial(acc));
                if (reply === noMore) {
                    unsub();
                    unsub = nop;
                }
            }
            return reply;
        };
        unsub = src.subscribeInternal(function (event) {
            if (hasValue(event)) {
                if (initHandled && event.isInitial) {
                    //console.log "skip INITIAL"
                    return more; // init already sent, skip this one
                }
                else {
                    if (!event.isInitial) {
                        sendInit();
                    }
                    initSent = initHandled = true;
                    var prev = acc;
                    var next = f(prev, event.value);
                    //console.log prev , ",", event.value, "->", next
                    acc = next;
                    return sink(event.apply(next));
                }
            }
            else {
                if (event.isEnd) {
                    reply = sendInit();
                }
                if (reply !== noMore) {
                    return sink(event);
                }
                return reply;
            }
        });
        UpdateBarrier.whenDoneWith(resultProperty, sendInit);
        return unsub;
    };
    return resultProperty = new Property(new Desc(src, "scan", [seed, f]), subscribe);
}

/** @hidden */
function mapEndT(f) {
    var theF = _.toFunction(f);
    return function (event, sink) {
        if (isEnd(event)) {
            sink(nextEvent(theF(event)));
            sink(endEvent());
            return noMore;
        }
        else {
            return sink(event);
        }
    };
}

/** @hidden */
function mapErrorT(f) {
    var theF = _.toFunction(f);
    return function (event, sink) {
        if (isError(event)) {
            return sink(nextEvent(theF(event.error)));
        }
        else {
            return sink(event);
        }
    };
}

/** @hidden */
function skipErrors(src) {
    return src.transform(function (event, sink) {
        if (isError(event)) {
            return more;
        }
        else {
            return sink(event);
        }
    }, new Desc(src, "skipErrors", []));
}

/** @hidden */
function last$1(src) {
    var lastEvent;
    return src.transform(function (event, sink) {
        if (isEnd(event)) {
            if (lastEvent) {
                sink(lastEvent);
            }
            sink(endEvent());
            return noMore;
        }
        else if (hasValue(event)) {
            lastEvent = event;
            return more;
        }
        else {
            return sink(event);
        }
    }).withDesc(new Desc(src, "last", []));
}

/** @hidden */
var CompositeUnsubscribe = /** @class */ (function () {
    function CompositeUnsubscribe(ss) {
        if (ss === void 0) { ss = []; }
        this.unsubscribed = false;
        this.unsubscribe = _.bind(this.unsubscribe, this);
        this.unsubscribed = false;
        this.subscriptions = [];
        this.starting = [];
        for (var i = 0, s; i < ss.length; i++) {
            s = ss[i];
            this.add(s);
        }
    }
    CompositeUnsubscribe.prototype.add = function (subscription) {
        var _this = this;
        if (!this.unsubscribed) {
            var ended = false;
            var unsub = nop;
            this.starting.push(subscription);
            var unsubMe = function () {
                if (_this.unsubscribed) {
                    return;
                }
                ended = true;
                _this.remove(unsub);
                _.remove(subscription, _this.starting);
            };
            unsub = subscription(this.unsubscribe, unsubMe);
            if (!(this.unsubscribed || ended)) {
                this.subscriptions.push(unsub);
            }
            else {
                unsub();
            }
            _.remove(subscription, this.starting);
        }
    };
    CompositeUnsubscribe.prototype.remove = function (unsub) {
        if (this.unsubscribed) {
            return;
        }
        if ((_.remove(unsub, this.subscriptions)) !== undefined) {
            return unsub();
        }
    };
    CompositeUnsubscribe.prototype.unsubscribe = function () {
        if (this.unsubscribed) {
            return;
        }
        this.unsubscribed = true;
        var iterable = this.subscriptions;
        for (var i = 0; i < iterable.length; i++) {
            iterable[i]();
        }
        this.subscriptions = [];
        this.starting = [];
    };
    CompositeUnsubscribe.prototype.count = function () {
        if (this.unsubscribed) {
            return 0;
        }
        return this.subscriptions.length + this.starting.length;
    };
    CompositeUnsubscribe.prototype.empty = function () {
        return this.count() === 0;
    };
    return CompositeUnsubscribe;
}());

/** @hidden */
function streamSubscribeToPropertySubscribe(initValue, streamSubscribe) {
    //assertFunction(streamSubscribe)
    return function (sink) {
        var initSent = false;
        var subbed = false;
        var unsub = nop;
        var reply = more;
        var sendInit = function () {
            if (!initSent) {
                return initValue.forEach(function (value) {
                    initSent = true;
                    reply = sink(new Initial(value));
                    if (reply === noMore) {
                        unsub();
                        unsub = nop;
                        return nop;
                    }
                });
            }
        };
        unsub = streamSubscribe(function (event) {
            if (event instanceof Value) {
                if (event.isInitial && !subbed) {
                    initValue = new Some(event.value);
                    return more;
                }
                else {
                    if (!event.isInitial) {
                        sendInit();
                    }
                    initSent = true;
                    initValue = new Some(event.value);
                    return sink(event);
                }
            }
            else {
                if (event.isEnd) {
                    reply = sendInit();
                }
                if (reply !== noMore) {
                    return sink(event);
                }
                return reply;
            }
        });
        subbed = true;
        sendInit();
        return unsub;
    };
}

/** @hidden */
function propertyFromStreamSubscribe(desc, subscribe) {
    assertFunction(subscribe);
    return new Property(desc, streamSubscribeToPropertySubscribe(none(), subscribe));
}

/**
 Creates an EventStream that delivers the given
 single value for the first subscriber. The stream will end immediately
 after this value. You can also send an [`Bacon.Error`](#bacon-error) event instead of a
 value: `Bacon.once(new Bacon.Error("fail"))`.

 @param   value   the value or event to emit
 @typeparam V Type of stream elements
 */
function once(value) {
    var s = new EventStream(new Desc("Bacon", "once", [value]), function (sink) {
        UpdateBarrier.soonButNotYet(s, function () {
            sink(toEvent(value));
            sink(endEvent());
        });
        return nop;
    });
    return s;
}

/** @hidden */
function flatMap_(spawner, src, params) {
    if (params === void 0) { params = {}; }
    var root = src;
    var rootDep = [root];
    var childDeps = [];
    var isProperty = src._isProperty;
    var ctor = (isProperty ? propertyFromStreamSubscribe : newEventStreamAllowSync);
    var initialSpawned = false;
    var desc = params.desc || new Desc(src, "flatMap_", [spawner]);
    var result = ctor(desc, function (sink) {
        var composite = new CompositeUnsubscribe();
        var queue = [];
        function spawn(event) {
            if (isProperty && event.isInitial) {
                if (initialSpawned) {
                    return more;
                }
                initialSpawned = true;
            }
            var child = makeObservable(spawner(event));
            childDeps.push(child);
            return composite.add(function (unsubAll, unsubMe) {
                return child.subscribeInternal(function (event) {
                    if (event.isEnd) {
                        _.remove(child, childDeps);
                        checkQueue();
                        checkEnd(unsubMe);
                        return noMore;
                    }
                    else {
                        event = event.toNext(); // To support Property as the spawned stream
                        var reply = sink(event);
                        if (reply === noMore) {
                            unsubAll();
                        }
                        return reply;
                    }
                });
            });
        }
        function checkQueue() {
            var event = queue.shift();
            if (event) {
                spawn(event);
            }
        }
        function checkEnd(unsub) {
            unsub();
            if (composite.empty()) {
                return sink(endEvent());
            }
            return more;
        }
        composite.add(function (__, unsubRoot) {
            return root.subscribeInternal(function (event) {
                if (event.isEnd) {
                    return checkEnd(unsubRoot);
                }
                else if (event.isError && !params.mapError) {
                    return sink(event);
                }
                else if (params.firstOnly && composite.count() > 1) {
                    return more;
                }
                else {
                    if (composite.unsubscribed) {
                        return noMore;
                    }
                    if (params.limit && composite.count() > params.limit) {
                        queue.push(event);
                    }
                    else {
                        spawn(event);
                    }
                    return more;
                }
            });
        });
        return composite.unsubscribe;
    });
    result.internalDeps = function () {
        if (childDeps.length) {
            return rootDep.concat(childDeps);
        }
        else {
            return rootDep;
        }
    };
    return result;
}
/** @hidden */
function handleEventValueWith(f) {
    if (typeof f == "function") {
        return (function (event) {
            if (hasValue(event)) {
                return f(event.value);
            }
            return event;
        });
    }
    return (function (event) { return f; });
}
/** @hidden */
function makeObservable(x) {
    if (isObservable(x)) {
        return x;
    }
    else {
        return once(x);
    }
}

/** @hidden */
function flatMapEvent(src, f) {
    return flatMap_(f, src, {
        mapError: true,
        desc: new Desc(src, "flatMapEvent", [f])
    });
}

/** @hidden */
function endAsValue(src) {
    return src.transform(function (event, sink) {
        if (isEnd(event)) {
            sink(nextEvent({}));
            sink(endEvent());
            return noMore;
        }
        return more;
    });
}

/** @hidden */
function endOnError(src, predicate) {
    if (predicate === void 0) { predicate = function (x) { return true; }; }
    return src.transform(function (event, sink) {
        if (isError(event) && predicate(event.error)) {
            sink(event);
            return sink(endEvent());
        }
        else {
            return sink(event);
        }
    }, new Desc(src, "endOnError", []));
}

/** @hidden */
var Source = /** @class */ (function () {
    function Source(obs, sync) {
        this._isSource = true;
        this.flatten = true;
        this.ended = false;
        this.obs = obs;
        this.sync = sync;
    }
    Source.prototype.subscribe = function (sink) {
        return this.obs.subscribeInternal(sink);
    };
    Source.prototype.toString = function () {
        return this.obs.toString();
    };
    Source.prototype.markEnded = function () {
        this.ended = true;
    };
    Source.prototype.mayHave = function (count) { return true; };
    return Source;
}());
/** @hidden */
var DefaultSource = /** @class */ (function (_super) {
    __extends(DefaultSource, _super);
    function DefaultSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultSource.prototype.consume = function () {
        return this.value;
    };
    DefaultSource.prototype.push = function (x) {
        this.value = x;
    };
    DefaultSource.prototype.hasAtLeast = function (c) {
        return !!this.value;
    };
    return DefaultSource;
}(Source));
/** @hidden */
var ConsumingSource = /** @class */ (function (_super) {
    __extends(ConsumingSource, _super);
    function ConsumingSource(obs, sync) {
        var _this = _super.call(this, obs, sync) || this;
        _this.flatten = false;
        _this.queue = [];
        return _this;
    }
    ConsumingSource.prototype.consume = function () {
        return this.queue.shift();
    };
    ConsumingSource.prototype.push = function (x) {
        this.queue.push(x);
    };
    ConsumingSource.prototype.mayHave = function (count) {
        return !this.ended || this.queue.length >= count;
    };
    ConsumingSource.prototype.hasAtLeast = function (count) {
        return this.queue.length >= count;
    };
    return ConsumingSource;
}(Source));
/** @hidden */
var BufferingSource = /** @class */ (function (_super) {
    __extends(BufferingSource, _super);
    function BufferingSource(obs) {
        var _this = _super.call(this, obs, true) || this;
        _this.queue = [];
        return _this;
    }
    BufferingSource.prototype.consume = function () {
        var values = this.queue;
        this.queue = [];
        return {
            value: values
        };
    };
    BufferingSource.prototype.push = function (x) {
        return this.queue.push(x.value);
    };
    BufferingSource.prototype.hasAtLeast = function (count) {
        return true;
    };
    return BufferingSource;
}(Source));
/** @hidden */
function isTrigger(s) {
    if (s == null)
        return false;
    if (s._isSource) {
        return s.sync;
    }
    else {
        return s._isEventStream;
    }
}
/** @hidden */
function fromObservable(s) {
    if (s != null && s._isSource) {
        return s;
    }
    else if (s != null && s._isProperty) {
        return new DefaultSource(s, false);
    }
    else {
        return new ConsumingSource(s, true);
    }
}

/**
 Creates an EventStream that immediately ends.
 @typeparam V Type of stream elements
 */
function never() {
    return new EventStream(describe("Bacon", "never"), function (sink) {
        sink(endEvent());
        return nop;
    });
}

/**
 The `when` method provides a generalization of the [`zip`](classes/observable.html#zip) function. While zip
 synchronizes events from multiple streams pairwse, the join patterns used in `when` allow
 the implementation of more advanced synchronization patterns.

 Consider implementing a game with discrete time ticks. We want to
 handle key-events synchronized on tick-events, with at most one key
 event handled per tick. If there are no key events, we want to just
 process a tick.

 ```js
 Bacon.when(
 [tick, keyEvent, function(_, k) { handleKeyEvent(k); return handleTick(); }],
 [tick, handleTick])
 ```

 Order is important here. If the [tick] patterns had been written
 first, this would have been tried first, and preferred at each tick.

 Join patterns are indeed a generalization of zip, and for EventStreams, zip is
 equivalent to a single-rule join pattern. The following observables
 have the same output, assuming that all sources are EventStreams.

 ```js
 Bacon.zipWith(a,b,c, combine)
 Bacon.when([a,b,c], combine)
 ```

 Note that [`Bacon.when`](#bacon-when) does not trigger updates for events from Properties though;
 if you use a Property in your pattern, its value will be just sampled when all the
 other sources (EventStreams) have a value. This is useful when you need a value of a Property
 in your calculations. If you want your pattern to fire for a Property too, you can
 convert it into an EventStream using [`property.changes()`](#property-changes) or [`property.toEventStream()`](#property-toeventstream)

 * @param {Pattern<O>} patterns Join patterns
 * @typeparam O result type
 */
function when() {
    var patterns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        patterns[_i] = arguments[_i];
    }
    return when_(newEventStream, patterns);
}
/** @hidden */
function whenP() {
    var patterns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        patterns[_i] = arguments[_i];
    }
    return when_(propertyFromStreamSubscribe, patterns);
}
/** @hidden */
function when_(ctor, patterns) {
    if (patterns.length === 0) {
        return never();
    }
    var _a = processRawPatterns(extractRawPatterns(patterns)), sources = _a[0], ixPats = _a[1];
    if (!sources.length) {
        return never();
    }
    var needsBarrier = (any(sources, function (s) { return s.flatten; })) && containsDuplicateDeps(map((function (s) { return s.obs; }), sources));
    var desc = new Desc("Bacon", "when", Array.prototype.slice.call(patterns));
    var resultStream = ctor(desc, function (sink) {
        var triggers = [];
        var ends = false;
        function match(p) {
            for (var i = 0; i < p.ixs.length; i++) {
                var ix = p.ixs[i];
                if (!sources[ix.index].hasAtLeast(ix.count)) {
                    return false;
                }
            }
            return true;
        }
        function cannotMatch(p) {
            for (var i = 0; i < p.ixs.length; i++) {
                var ix = p.ixs[i];
                if (!sources[ix.index].mayHave(ix.count)) {
                    return true;
                }
            }
            return false;
        }
        function nonFlattened(trigger) { return !trigger.source.flatten; }
        function part(source) {
            return function (unsubAll) {
                function flushLater() {
                    return UpdateBarrier.whenDoneWith(resultStream, flush);
                }
                function flushWhileTriggers() {
                    var trigger;
                    if ((trigger = triggers.pop()) !== undefined) {
                        var reply = more;
                        for (var i = 0, p; i < ixPats.length; i++) {
                            p = ixPats[i];
                            if (match(p)) {
                                var values = [];
                                for (var j = 0; j < p.ixs.length; j++) {
                                    var event_1 = sources[p.ixs[j].index].consume();
                                    if (!event_1)
                                        throw new Error("Event was undefined");
                                    values.push(event_1.value);
                                }
                                //console.log("flushing values", values)
                                var applied = p.f.apply(null, values);
                                //console.log('sinking', applied)
                                reply = sink((trigger).e.apply(applied));
                                if (triggers.length) {
                                    triggers = filter(nonFlattened, triggers);
                                }
                                if (reply === noMore) {
                                    return reply;
                                }
                                else {
                                    return flushWhileTriggers();
                                }
                            }
                        }
                    }
                    return more;
                }
                function flush() {
                    //console.log "flushing", _.toString(resultStream)
                    var reply = flushWhileTriggers();
                    if (ends) {
                        //console.log "ends detected"
                        if (all(sources, cannotSync) || all(ixPats, cannotMatch)) {
                            //console.log "actually ending"
                            reply = noMore;
                            sink(endEvent());
                        }
                    }
                    if (reply === noMore) {
                        unsubAll();
                    }
                }
                return source.subscribe(function (e) {
                    var reply = more;
                    if (e.isEnd) {
                        //console.log "got end"
                        ends = true;
                        source.markEnded();
                        flushLater();
                    }
                    else if (e.isError) {
                        reply = sink(e);
                    }
                    else {
                        var valueEvent = e;
                        //console.log "got value", e.value
                        source.push(valueEvent);
                        if (source.sync) {
                            //console.log "queuing", e.toString(), toString(resultStream)
                            triggers.push({ source: source, e: valueEvent });
                            if (needsBarrier || UpdateBarrier.hasWaiters()) {
                                flushLater();
                            }
                            else {
                                flush();
                            }
                        }
                    }
                    if (reply === noMore) {
                        unsubAll();
                    }
                    return reply;
                });
            };
        }
        return new CompositeUnsubscribe(map(part, sources)).unsubscribe;
    });
    return resultStream;
}
function processRawPatterns(rawPatterns) {
    var sources = [];
    var pats = [];
    for (var i = 0; i < rawPatterns.length; i++) {
        var _a = rawPatterns[i], patSources = _a[0], f = _a[1];
        var pat = { f: f, ixs: [] };
        var triggerFound = false;
        for (var j = 0, s; j < patSources.length; j++) {
            s = patSources[j];
            var index = indexOf(sources, s);
            if (!triggerFound) {
                triggerFound = isTrigger(s);
            }
            if (index < 0) {
                sources.push(s);
                index = sources.length - 1;
            }
            for (var k = 0; k < pat.ixs.length; k++) {
                var ix = pat.ixs[k];
                if (ix.index === index) {
                    ix.count++;
                }
            }
            pat.ixs.push({ index: index, count: 1 });
        }
        if (patSources.length > 0 && !triggerFound) {
            throw new Error("At least one EventStream required, none found in " + patSources);
        }
        if (patSources.length > 0) {
            pats.push(pat);
        }
    }
    return [map(fromObservable /* sorry */, sources), pats];
}
function extractLegacyPatterns(sourceArgs) {
    var i = 0;
    var len = sourceArgs.length;
    var rawPatterns = [];
    while (i < len) {
        var patSources = toArray(sourceArgs[i++]);
        var f = toFunction(sourceArgs[i++]);
        rawPatterns.push([patSources, f]);
    }
    var usage = "when: expecting arguments in the form (Observable+,function)+";
    assert(usage, (len % 2 === 0));
    return rawPatterns;
}
function isTypedOrRawPattern(pattern) {
    return (pattern instanceof Array) && (!isObservable(pattern[pattern.length - 1]));
}
function isRawPattern(pattern) {
    return pattern[0] instanceof Array;
}
/** @hidden */
function extractRawPatterns(patterns) {
    var rawPatterns = [];
    for (var i = 0; i < patterns.length; i++) {
        var pattern = patterns[i];
        if (!isTypedOrRawPattern(pattern)) {
            // Fallback to legacy patterns
            return extractLegacyPatterns(patterns);
        }
        if (isRawPattern(pattern)) {
            rawPatterns.push([pattern[0], toFunction(pattern[1])]);
        }
        else { // typed pattern, then
            var sources = pattern.slice(0, pattern.length - 1);
            var f = toFunction(pattern[pattern.length - 1]);
            rawPatterns.push([sources, f]);
        }
    }
    return rawPatterns;
}
function containsDuplicateDeps(observables, state) {
    if (state === void 0) { state = []; }
    function checkObservable(obs) {
        if (contains(state, obs)) {
            return true;
        }
        else {
            var deps = obs.internalDeps();
            if (deps.length) {
                state.push(obs);
                return any(deps, checkObservable);
            }
            else {
                state.push(obs);
                return false;
            }
        }
    }
    return any(observables, checkObservable);
}
function cannotSync(source) {
    return !source.sync || source.ended;
}

/** @hidden */
function withLatestFromE(sampler, samplee, f) {
    var result = when([new DefaultSource(samplee.toProperty(), false), new DefaultSource(sampler, true), flip(f)]);
    return result.withDesc(new Desc(sampler, "withLatestFrom", [samplee, f]));
}
/** @hidden */
function withLatestFromP(sampler, samplee, f) {
    var result = whenP([new DefaultSource(samplee.toProperty(), false), new DefaultSource(sampler, true), flip(f)]);
    return result.withDesc(new Desc(sampler, "withLatestFrom", [samplee, f]));
}
/** @hidden */
function withLatestFrom(sampler, samplee, f) {
    if (sampler instanceof Property) {
        return withLatestFromP(sampler, samplee, f);
    }
    else if (sampler instanceof EventStream) {
        return withLatestFromE(sampler, samplee, f);
    }
    else {
        throw new Error("Unknown observable: " + sampler);
    }
}

/** @hidden */
function map$1(src, f) {
    if (f instanceof Property) {
        return withLatestFrom(src, f, function (a, b) { return b; });
    }
    return src.transform(mapT(f), new Desc(src, "map", [f]));
}
/** @hidden */
function mapT(f) {
    var theF = _.toFunction(f);
    return function (e, sink) {
        return sink(e.fmap(theF));
    };
}

/**
 Creates a constant property with value `x`.
 */
function constant(x) {
    return new Property(new Desc("Bacon", "constant", [x]), function (sink) {
        sink(initialEvent(x));
        sink(endEvent());
        return nop;
    });
}

/** @hidden */
function argumentsToObservables(args) {
    args = (Array.prototype.slice.call(args));
    return _.flatMap(singleToObservables, args);
}
function singleToObservables(x) {
    if (isObservable(x)) {
        return [x];
    }
    else if (isArray(x)) {
        return argumentsToObservables(x);
    }
    else {
        return [constant(x)];
    }
}
/** @hidden */
function argumentsToObservablesAndFunction(args) {
    if (_.isFunction(args[0])) {
        return [argumentsToObservables(Array.prototype.slice.call(args, 1)), args[0]];
    }
    else {
        return [argumentsToObservables(Array.prototype.slice.call(args, 0, args.length - 1)), _.last(args)];
    }
}

/** @hidden */
function groupSimultaneous() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    return groupSimultaneous_(argumentsToObservables(streams));
}
// TODO: type is not exactly correct, because different inputs may have different types.
// Result values are arrays where each element is the list from each input observable. Type this.
/** @hidden */
function groupSimultaneous_(streams, options) {
    var sources = _.map(function (stream) { return new BufferingSource(stream); }, streams);
    var ctor = function (desc, subscribe) { return new EventStream(desc, subscribe, undefined, options); };
    return when_(ctor, [sources, (function () {
            var xs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                xs[_i] = arguments[_i];
            }
            return xs;
        })]).withDesc(new Desc("Bacon", "groupSimultaneous", streams));
}

/** @hidden */
function awaiting(src, other) {
    return groupSimultaneous_([src, other], allowSync)
        .map(function (values) { return values[1].length === 0; })
        .toProperty(false)
        .skipDuplicates()
        .withDesc(new Desc(src, "awaiting", [other]));
}

/**
 Combines Properties, EventStreams and constant values so that the result Property will have an array of the latest
 values from all sources as its value. The inputs may contain both Properties and EventStreams.


 ```js
 property = Bacon.constant(1)
 stream = Bacon.once(2)
 constant = 3
 Bacon.combineAsArray(property, stream, constant)
 # produces the value [1,2,3]
 ```

 * @param streams streams and properties to combine
 */
function combineAsArray() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    streams = argumentsToObservables(streams);
    if (streams.length) {
        var sources = [];
        for (var i = 0; i < streams.length; i++) {
            var stream = (isObservable(streams[i])
                ? streams[i]
                : constant(streams[i]));
            sources.push(wrap(stream));
        }
        return whenP([sources, function () {
                var xs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    xs[_i] = arguments[_i];
                }
                return xs;
            }]).withDesc(new Desc("Bacon", "combineAsArray", streams));
    }
    else {
        return constant([]);
    }
}
/**
  Combines given *n* Properties,
  EventStreams and constant values using the given n-ary function `f(v1, v2 ...)`.

  To calculate the current sum of three numeric Properties, you can do

```js
function sum3(x,y,z) { return x + y + z }
Bacon.combineWith(sum3, p1, p2, p3)
```
*/
function combineWith(f) {
    var streams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        streams[_i - 1] = arguments[_i];
    }
    // TODO: untyped
    var _a = argumentsToObservablesAndFunction(arguments), streams = _a[0], f = _a[1];
    var desc = new Desc("Bacon", "combineWith", [f].concat(streams));
    return combineAsArray(streams).map(function (values) {
        return f.apply(void 0, values);
    }).withDesc(desc);
}
/** @hidden */
function combine(left, right, f) {
    return whenP([[wrap(left), wrap(right)], f]).withDesc(new Desc(left, "combine", [right, f]));
}
function wrap(obs) {
    return new DefaultSource(obs, true);
}

/** @hidden */
function skip(src, count) {
    return src.transform(function (event, sink) {
        if (!event.hasValue) {
            return sink(event);
        }
        else if (count > 0) {
            count--;
            return more;
        }
        else {
            return sink(event);
        }
    }, new Desc(src, "skip", [count]));
}

/** @hidden */
function flatMapConcat(src, f) {
    return flatMap_(handleEventValueWith(f), src, {
        desc: new Desc(src, "flatMapConcat", [f]),
        limit: 1
    });
}

/**
 If none of the other factory methods above apply, you may of course roll your own EventStream by using `fromBinder`.

 <a name="bacon-frombinder"></a>
 [`Bacon.fromBinder(subscribe)`](#bacon-frombinder "Bacon.fromBinder(subscribe)") The parameter `subscribe` is a function that accepts a `sink` which is a function that your `subscribe` function can "push" events to.

 For example:

 ```js
 var stream = Bacon.fromBinder(function(sink) {
  sink("first value")
  sink([new Bacon.Next("2nd"), new Bacon.Next("3rd")])
  sink(new Bacon.Error("oops, an error"))
  sink(new Bacon.End())
  return function() {
     // unsub functionality here, this one's a no-op
  }
})
 stream.log()
 ```

 As shown in the example, you can push

 - A plain value, like `"first value"`
 - An [`Event`](#event) object including [`Bacon.Error`](#bacon-error) (wraps an error) and [`Bacon.End`](#bacon-end) (indicates
 stream end).
 - An array of [event](#event) objects at once

 Other examples can be found on [JSFiddle](http://jsfiddle.net/PG4c4/) and the
 [Bacon.js blog](http://baconjs.blogspot.fi/2013/12/wrapping-things-in-bacon.html).

 The `subscribe` function must return a function. Let's call that function
 `unsubscribe`. The returned function can be used by the subscriber (directly or indirectly) to
 unsubscribe from the EventStream. It should release all resources that the subscribe function reserved.

 The `sink` function may return [`Bacon.noMore`](#bacon-nomore) (as well as [`Bacon.more`](#bacon-more)
 or any other value). If it returns [`Bacon.noMore`](#bacon-nomore), no further events will be consumed
 by the subscriber. The `subscribe` function may choose to clean up all resources at this point (e.g.,
 by calling `unsubscribe`). This is usually not necessary, because further calls to `sink` are ignored,
 but doing so can increase performance in [rare cases](https://github.com/baconjs/bacon.js/issues/484).

 The EventStream will wrap your `subscribe` function so that it will
 only be called when the first stream listener is added, and the `unsubscribe`
 function is called only after the last listener has been removed.
 The subscribe-unsubscribe cycle may of course be repeated indefinitely,
 so prepare for multiple calls to the subscribe function.


 @param  binder
 @param  eventTransformer
 @typeparam V Type of stream elements

 */
function fromBinder(binder, eventTransformer) {
    if (eventTransformer === void 0) { eventTransformer = _.id; }
    var desc = new Desc("Bacon", "fromBinder", [binder, eventTransformer]);
    return new EventStream(desc, function (sink) {
        var unbound = false;
        var shouldUnbind = false;
        var unbind = function () {
            if (!unbound) {
                if ((typeof unbinder !== "undefined" && unbinder !== null)) {
                    unbinder();
                    return unbound = true;
                }
                else {
                    return shouldUnbind = true;
                }
            }
        };
        var unbinder = binder(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var value_ = eventTransformer.apply(void 0, args);
            var valueArray = isArray(value_) && isEvent(_.last(value_))
                ? value_
                : [value_];
            var reply = more;
            for (var i = 0; i < valueArray.length; i++) {
                var event_1 = toEvent(valueArray[i]);
                reply = sink(event_1);
                if (reply === noMore || event_1.isEnd) {
                    // defer if binder calls handler in sync before returning unbinder
                    unbind();
                    return reply;
                }
            }
            return reply;
        });
        if (shouldUnbind) {
            unbind();
        }
        return unbind;
    });
}

/**
 Polls given function with given interval.
 Function should return Events: either [`Bacon.Next`](classes/next.html) or [`Bacon.End`](classes/end.html). Polling occurs only
 when there are subscribers to the stream. Polling ends permanently when
 `f` returns [`Bacon.End`](classes/end.html).
 * @param delay poll interval in milliseconds
 * @param poll function to be polled
 * @typeparam V Type of stream elements
 */
function fromPoll(delay, poll) {
    var desc = new Desc("Bacon", "fromPoll", [delay, poll]);
    return fromBinder((function (handler) {
        var id = GlobalScheduler.scheduler.setInterval(handler, delay);
        return function () {
            return GlobalScheduler.scheduler.clearInterval(id);
        };
    }), poll).withDesc(desc);
}

/**
 Repeats the single element indefinitely with the given interval (in milliseconds)

 @param   delay   Repeat delay in milliseconds
 @param   value   The single value to repeat
 @typeparam V Type of stream elements
 */
function interval(delay, value) {
    return fromPoll(delay, function () {
        return nextEvent(value);
    }).withDesc(new Desc("Bacon", "interval", [delay, value]));
}

function makeCombinator(combinator) {
    if (typeof combinator == "function") {
        return combinator;
    }
    else {
        return _.id;
    }
}
/** @hidden */
function sampledBy(samplee, sampler, f) {
    if (samplee instanceof EventStream) {
        return sampledByE(samplee, sampler, f);
    }
    else {
        return sampledByP(samplee, sampler, f);
    }
}
/** @hidden */
function sampledByP(samplee, sampler, f) {
    var combinator = makeCombinator(f);
    var result = withLatestFrom(sampler, samplee, flip(combinator));
    return result.withDesc(new Desc(samplee, "sampledBy", [sampler]));
}
/** @hidden */
function sampledByE(samplee, sampler, f) {
    return sampledByP(samplee.toProperty(), sampler, f).withDesc(new Desc(samplee, "sampledBy", [sampler]));
}
/** @hidden */
function sampleP(samplee, samplingInterval) {
    return sampledByP(samplee, interval(samplingInterval, {}), function (a, b) { return a; }).withDesc(new Desc(samplee, "sample", [samplingInterval]));
}

/** @hidden */
function transformP(src, transformer, desc) {
    return new Property(new Desc(src, "transform", [transformer]), function (sink) {
        return src.subscribeInternal(function (e) {
            return transformer(e, sink);
        });
    }).withDesc(desc);
}
/** @hidden */
function transformE(src, transformer, desc) {
    return new EventStream(new Desc(src, "transform", [transformer]), function (sink) {
        return src.subscribeInternal(function (e) {
            return transformer(e, sink);
        });
    }, undefined, allowSync).withDesc(desc);
}
/** @hidden */
function composeT(t1, t2) {
    var finalSink; // mutation used to avoid closure creation while dispatching events
    var sink2 = function (event) {
        return t2(event, finalSink);
    };
    return function (event, sink) {
        finalSink = sink;
        return t1(event, sink2);
    };
}

/** @hidden */
function toPredicate(f) {
    if (typeof f == "boolean") {
        return _.always(f);
    }
    else if (typeof f != "function") {
        throw new Error("Not a function: " + f);
    }
    else {
        return f;
    }
}
/** @hidden */
function withPredicate(src, f, predicateTransformer, desc) {
    if (f instanceof Property) {
        return withLatestFrom(src, f, function (p, v) { return [p, v]; })
            .transform(composeT(predicateTransformer((function (tuple) { return tuple[1]; })), mapT(function (tuple) { return tuple[0]; })), desc);
        // the `any` type above is needed because the type argument for Predicate2Transformer is fixed. We'd need higher-kinded types to be able to express this properly, I think.
    }
    return src.transform(predicateTransformer(toPredicate(f)), desc);
}

/** @hidden */
function filter$1(src, f) {
    return withPredicate(src, f, filterT, new Desc(src, "filter", [f]));
}
/** @hidden */
function filterT(f) {
    return function (e, sink) {
        if (e.filter(f)) {
            return sink(e);
        }
        else {
            return more;
        }
    };
}

/** @hidden */
function not(src) {
    return src.map(function (x) { return !x; }).withDesc(new Desc(src, "not", []));
}
/** @hidden */
function and(left, right) {
    return left.combine(toProperty(right), function (x, y) { return !!(x && y); }).withDesc(new Desc(left, "and", [right]));
}
/** @hidden */
function or(left, right) {
    return left.combine(toProperty(right), function (x, y) { return x || y; }).withDesc(new Desc(left, "or", [right]));
}
function toProperty(x) {
    if (isProperty(x)) {
        return x;
    }
    return constant(x);
}

/** @hidden */
function flatMapFirst(src, f) {
    return flatMap_(handleEventValueWith(f), src, {
        firstOnly: true,
        desc: new Desc(src, "flatMapFirst", [f])
    });
}

/** @hidden */
function concatE(left, right, options) {
    return new EventStream(new Desc(left, "concat", [right]), function (sink) {
        var unsubRight = nop;
        var unsubLeft = left.dispatcher.subscribe(function (e) {
            if (e.isEnd) {
                unsubRight = right.toEventStream().dispatcher.subscribe(sink);
                return more;
            }
            else {
                return sink(e);
            }
        });
        return function () {
            return unsubLeft(), unsubRight();
        };
    }, undefined, options);
}
/**
 Concatenates given array of EventStreams or Properties. Works by subcribing to the first source, and listeing to that
 until it ends. Then repeatedly subscribes to the next source, until all sources have ended.

 See [`concat`](#observable-concat)
 */
function concatAll() {
    var streams_ = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams_[_i] = arguments[_i];
    }
    var streams = argumentsToObservables(streams_);
    return (streams.length
        ? fold(tail(streams), head(streams).toEventStream(), function (a, b) { return a.concat(b); })
        : never()).withDesc(new Desc("Bacon", "concatAll", streams));
}

/** @hidden */
function transformPropertyChanges(property, f, desc) {
    var initValue;
    var comboSink;
    // Create a `changes` stream to be transformed, which also snatches the Initial value for later use.
    var changes = new EventStream(describe(property, "changes", []), function (sink) { return property.dispatcher.subscribe(function (event) {
        if (!initValue && isInitial(event)) {
            initValue = event;
            UpdateBarrier.whenDoneWith(combo, function () {
                if (!comboSink) {
                    throw new Error("Init sequence fail");
                }
                comboSink(initValue);
            });
        }
        if (!event.isInitial) {
            return sink(event);
        }
        return more;
    }); }, undefined, allowSync);
    var transformedChanges = f(changes);
    var combo = propertyFromStreamSubscribe(desc, function (sink) {
        comboSink = sink;
        return transformedChanges.dispatcher.subscribe(function (event) {
            sink(event);
        });
    });
    return combo;
}

/** @hidden */
function fold$1(src, seed, f) {
    return src.scan(seed, f)
        .last()
        .withDesc(new Desc(src, "fold", [seed, f]));
}

/** @hidden */
function startWithE(src, seed) {
    return once(seed).concat(src).withDesc(new Desc(src, "startWith", [seed]));
}
/** @hidden */
function startWithP(src, seed) {
    return src.scan(seed, function (prev, next) { return next; }).withDesc(new Desc(src, "startWith", [seed]));
}

/** @hidden */
var endMarker = {};
/** @hidden */
function takeUntil(src, stopper) {
    var endMapped = src.mapEnd(endMarker);
    var withEndMarker = groupSimultaneous_([endMapped, stopper.skipErrors()], allowSync);
    if (src instanceof Property)
        withEndMarker = withEndMarker.toProperty();
    return withEndMarker.transform(function (event, sink) {
        if (hasValue(event)) {
            var _a = event.value, data = _a[0], stopper = _a[1];
            if (stopper.length) {
                return sink(endEvent());
            }
            else {
                var reply = more;
                for (var i = 0; i < data.length; i++) {
                    var value = data[i];
                    if (value === endMarker) {
                        return sink(endEvent());
                    }
                    else {
                        reply = sink(nextEvent(value));
                    }
                }
                return reply;
            }
        }
        else {
            return sink(event);
        }
    }, new Desc(src, "takeUntil", [stopper]));
}

/** @hidden */
function flatMap$1(src, f) {
    return flatMap_(handleEventValueWith(f), src, { desc: new Desc(src, "flatMap", [f]) });
}

/** @hidden */
function flatMapError(src, f) {
    return flatMap_(function (x) {
        if (x instanceof Error$1) {
            var error = x.error;
            return f(error); // I don't understand why I need this little lie
        }
        else {
            return x;
        }
    }, src, {
        mapError: true,
        desc: new Desc(src, "flatMapError", [f])
    });
}

var spies = [];
var running = false;
/** @hidden */
function registerObs(obs) {
    if (spies.length) {
        if (!running) {
            try {
                running = true;
                spies.forEach(function (spy) {
                    spy(obs);
                });
            }
            finally {
                running = false;
            }
        }
    }
}
/**
 Adds your function as a "spy" that will get notified on all new Observables.
 This will allow a visualization/analytics tool to spy on all Bacon activity.
 */
var spy = function (spy) { return spies.push(spy); };

/** @hidden */
function flatMapLatest(src, f_) {
    var f = _.toFunction(f_);
    var stream = isProperty(src) ? src.toEventStream(allowSync) : src;
    var flatMapped = flatMap$1(stream, function (value) { return makeObservable(f(value)).takeUntil(stream); });
    if (isProperty(src))
        flatMapped = flatMapped.toProperty();
    return flatMapped.withDesc(new Desc(src, "flatMapLatest", [f]));
}

/** @hidden */
var Dispatcher = /** @class */ (function () {
    function Dispatcher(observable, _subscribe, _handleEvent) {
        this.pushing = false;
        this.ended = false;
        this.prevError = undefined;
        this.unsubSrc = undefined;
        this._subscribe = _subscribe;
        this._handleEvent = _handleEvent;
        this.subscribe = _.bind(this.subscribe, this);
        this.handleEvent = _.bind(this.handleEvent, this);
        this.subscriptions = [];
        this.observable = observable;
        this.queue = [];
    }
    Dispatcher.prototype.hasSubscribers = function () {
        return this.subscriptions.length > 0;
    };
    Dispatcher.prototype.removeSub = function (subscription) {
        this.subscriptions = _.without(subscription, this.subscriptions);
        return this.subscriptions;
    };
    Dispatcher.prototype.push = function (event) {
        if (event.isEnd) {
            this.ended = true;
        }
        return UpdateBarrier.inTransaction(event, this, this.pushIt, [event]);
    };
    Dispatcher.prototype.pushToSubscriptions = function (event) {
        try {
            var tmp = this.subscriptions;
            var len = tmp.length;
            for (var i = 0; i < len; i++) {
                var sub = tmp[i];
                var reply = sub.sink(event);
                if (reply === noMore || event.isEnd) {
                    this.removeSub(sub);
                }
            }
            return true;
        }
        catch (error) {
            this.pushing = false;
            this.queue = []; // ditch queue in case of exception to avoid unexpected behavior
            throw error;
        }
    };
    Dispatcher.prototype.pushIt = function (event) {
        if (!this.pushing) {
            if (event === this.prevError) {
                return;
            }
            if (event.isError) {
                this.prevError = event;
            }
            this.pushing = true;
            this.pushToSubscriptions(event);
            this.pushing = false;
            while (true) {
                var e = this.queue.shift();
                if (e) {
                    this.push(e);
                }
                else {
                    break;
                }
            }
            if (this.hasSubscribers()) {
                return more;
            }
            else {
                this.unsubscribeFromSource();
                return noMore;
            }
        }
        else {
            this.queue.push(event);
            return more;
        }
    };
    Dispatcher.prototype.handleEvent = function (event) {
        if (this._handleEvent) {
            return this._handleEvent(event);
        }
        else {
            return this.push(event);
        }
    };
    Dispatcher.prototype.unsubscribeFromSource = function () {
        if (this.unsubSrc) {
            this.unsubSrc();
        }
        this.unsubSrc = undefined;
    };
    Dispatcher.prototype.subscribe = function (sink) {
        var _this = this;
        if (this.ended) {
            sink(endEvent());
            return nop;
        }
        else {
            assertFunction(sink);
            var subscription_1 = {
                sink: sink
            };
            this.subscriptions.push(subscription_1);
            if (this.subscriptions.length === 1) {
                this.unsubSrc = this._subscribe(this.handleEvent);
                assertFunction(this.unsubSrc);
            }
            return function () {
                _this.removeSub(subscription_1);
                if (!_this.hasSubscribers()) {
                    return _this.unsubscribeFromSource();
                }
            };
        }
    };
    Dispatcher.prototype.inspect = function () {
        return this.observable.toString();
    };
    return Dispatcher;
}());

/** @hidden */
var PropertyDispatcher = /** @class */ (function (_super) {
    __extends(PropertyDispatcher, _super);
    function PropertyDispatcher(property, subscribe, handleEvent) {
        var _this = _super.call(this, property, subscribe, handleEvent) || this;
        _this.current = none();
        _this.propertyEnded = false;
        _this.subscribe = _.bind(_this.subscribe, _this);
        return _this;
    }
    PropertyDispatcher.prototype.push = function (event) {
        //console.log("dispatch", event, "from",  this)
        if (event.isEnd) {
            this.propertyEnded = true;
        }
        if (event instanceof Value) {
            //console.log("setting current")
            this.current = new Some(event);
            this.currentValueRootId = UpdateBarrier.currentEventId();
        }
        else if (event.hasValue) {
            console.error("Unknown event, two Bacons loaded?", event.constructor);
        }
        return _super.prototype.push.call(this, event);
    };
    PropertyDispatcher.prototype.maybeSubSource = function (sink, reply) {
        if (reply === noMore) {
            return nop;
        }
        else if (this.propertyEnded) {
            sink(endEvent());
            return nop;
        }
        else {
            return _super.prototype.subscribe.call(this, sink);
        }
    };
    PropertyDispatcher.prototype.subscribe = function (sink) {
        var _this = this;
        // init value is "bounced" here because the base Dispatcher class
        // won't add more than one subscription to the underlying observable.
        // without bouncing, the init value would be missing from all new subscribers
        // after the first one
        var reply = more;
        if (this.current.isDefined && (this.hasSubscribers() || this.propertyEnded)) {
            // should bounce init value
            var dispatchingId = UpdateBarrier.currentEventId();
            var valId = this.currentValueRootId;
            if (!this.propertyEnded && valId && dispatchingId && dispatchingId !== valId) {
                // when subscribing while already dispatching a value and this property hasn't been updated yet
                // we cannot bounce before this property is up to date.
                //console.log("bouncing with possibly stale value", event.value, "root at", valId, "vs", dispatchingId)
                UpdateBarrier.whenDoneWith(this.observable, function () {
                    if (_this.currentValueRootId === valId) {
                        //console.log("bouncing", this.current.get().value)
                        return sink(initialEvent(_this.current.get().value));
                    }
                });
                // the subscribing thing should be defered
                return this.maybeSubSource(sink, reply);
            }
            else {
                //console.log("bouncing immdiately", this.current.get().value)
                UpdateBarrier.inTransaction(undefined, this, function () {
                    reply = sink(initialEvent(_this.current.get().value));
                    return reply;
                }, []);
                return this.maybeSubSource(sink, reply);
            }
        }
        else {
            //console.log("normal subscribe", this)
            return this.maybeSubSource(sink, reply);
        }
    };
    PropertyDispatcher.prototype.inspect = function () {
        return this.observable + " current= " + this.current;
    };
    return PropertyDispatcher;
}(Dispatcher));

/** @hidden */
function flatMapWithConcurrencyLimit(src, limit, f) {
    return flatMap_(handleEventValueWith(f), src, {
        desc: new Desc(src, "flatMapWithConcurrencyLimit", [limit, f]),
        limit: limit
    });
}

/** @hidden */
function bufferWithTime(src, delay) {
    return bufferWithTimeOrCount(src, delay, Number.MAX_VALUE).withDesc(new Desc(src, "bufferWithTime", [delay]));
}
/** @hidden */
function bufferWithCount(src, count) {
    return bufferWithTimeOrCount(src, undefined, count).withDesc(new Desc(src, "bufferWithCount", [count]));
}
/** @hidden */
function bufferWithTimeOrCount(src, delay, count) {
    var delayFunc = toDelayFunction(delay);
    function flushOrSchedule(buffer) {
        if (buffer.values.length === count) {
            //console.log Bacon.scheduler.now() + ": count-flush"
            return buffer.flush();
        }
        else if (delayFunc !== undefined) {
            return buffer.schedule(delayFunc);
        }
    }
    var desc = new Desc(src, "bufferWithTimeOrCount", [delay, count]);
    return buffer(src, flushOrSchedule, flushOrSchedule).withDesc(desc);
}
var Buffer = /** @class */ (function () {
    function Buffer(onFlush, onInput) {
        this.push = function (e) { return more; };
        this.scheduled = null;
        this.end = undefined;
        this.values = [];
        this.onFlush = onFlush;
        this.onInput = onInput;
    }
    Buffer.prototype.flush = function () {
        if (this.scheduled) {
            GlobalScheduler.scheduler.clearTimeout(this.scheduled);
            this.scheduled = null;
        }
        if (this.values.length > 0) {
            //console.log Bacon.scheduler.now() + ": flush " + @values
            var valuesToPush = this.values;
            this.values = [];
            var reply = this.push(nextEvent(valuesToPush));
            if ((this.end != null)) {
                return this.push(this.end);
            }
            else if (reply !== noMore) {
                return this.onFlush(this);
            }
        }
        else {
            if ((this.end != null)) {
                return this.push(this.end);
            }
        }
    };
    Buffer.prototype.schedule = function (delay) {
        var _this = this;
        if (!this.scheduled) {
            return this.scheduled = delay(function () {
                //console.log Bacon.scheduler.now() + ": scheduled flush"
                return _this.flush();
            });
        }
    };
    return Buffer;
}());
function toDelayFunction(delay) {
    if (delay === undefined) {
        return undefined;
    }
    if (typeof delay === "number") {
        var delayMs = delay;
        return function (f) {
            //console.log Bacon.scheduler.now() + ": schedule for " + (Bacon.scheduler.now() + delayMs)
            return GlobalScheduler.scheduler.setTimeout(f, delayMs);
        };
    }
    return delay;
}
/** @hidden */
function buffer(src, onInput, onFlush) {
    if (onInput === void 0) { onInput = nop; }
    if (onFlush === void 0) { onFlush = nop; }
    var reply = more;
    var buffer = new Buffer(onFlush, onInput);
    return src.transform(function (event, sink) {
        buffer.push = sink;
        if (hasValue(event)) {
            buffer.values.push(event.value);
            //console.log Bacon.scheduler.now() + ": input " + event.value
            onInput(buffer);
        }
        else if (isError(event)) {
            reply = sink(event);
        }
        else if (isEnd(event)) {
            buffer.end = event;
            if (!buffer.scheduled) {
                //console.log Bacon.scheduler.now() + ": end-flush"
                buffer.flush();
            }
        }
        return reply;
    }).withDesc(new Desc(src, "buffer", []));
}

/** @hidden */
function asyncWrapSubscribe(obs, subscribe) {
    //assertFunction(subscribe)
    var subscribing = false;
    return function wrappedSubscribe(sink) {
        //assertFunction(sink)
        var inTransaction = UpdateBarrier.isInTransaction();
        subscribing = true;
        var asyncDeliveries;
        function deliverAsync() {
            //console.log("delivering async", obs, asyncDeliveries)
            var toDeliverNow = asyncDeliveries || [];
            asyncDeliveries = undefined;
            for (var i = 0; i < toDeliverNow.length; i++) {
                var event = toDeliverNow[i];
                sink(event);
            }
        }
        try {
            return subscribe(function wrappedSink(event) {
                if (subscribing || asyncDeliveries) {
                    // Deliver async if currently subscribing
                    // Also queue further events until async delivery has been completed
                    //console.log("Stream responded synchronously", obs)
                    if (!asyncDeliveries) {
                        asyncDeliveries = [event];
                        if (inTransaction) {
                            UpdateBarrier.soonButNotYet(obs, deliverAsync);
                        }
                        else {
                            GlobalScheduler.scheduler.setTimeout(deliverAsync, 0);
                        }
                    }
                    else {
                        asyncDeliveries.push(event);
                    }
                    return more;
                }
                else {
                    return sink(event);
                }
            });
        }
        finally {
            subscribing = false;
        }
    };
}

/**
 Merges given array of EventStreams or Properties, by collecting the values from all of the sources into a single
 EventStream.

 See also [`merge`](classes/eventstream.html#merge).
 */
function mergeAll() {
    var streams = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        streams[_i] = arguments[_i];
    }
    var flattenedStreams = argumentsToObservables(streams);
    if (flattenedStreams.length) {
        return new EventStream(new Desc("Bacon", "mergeAll", flattenedStreams), function (sink) {
            var ends = 0;
            var smartSink = function (obs) {
                return function (unsubBoth) {
                    return obs.subscribeInternal(function (event) {
                        if (event.isEnd) {
                            ends++;
                            if (ends === flattenedStreams.length) {
                                return sink(endEvent());
                            }
                            else {
                                return more;
                            }
                        }
                        else {
                            event = event.toNext();
                            var reply = sink(event);
                            if (reply === noMore) {
                                unsubBoth();
                            }
                            return reply;
                        }
                    });
                };
            };
            var sinks = map(smartSink, flattenedStreams);
            return new CompositeUnsubscribe(sinks).unsubscribe;
        });
    }
    else {
        return never();
    }
}

/**

 Creates a single-element stream that emits given value after given delay and ends.

 @param delay delay in milliseconds
 @param value value to be emitted
 @typeparam V Type of stream elements

 */
function later(delay, value) {
    return fromBinder(function (sink) {
        var sender = function () {
            return sink([toEvent(value), endEvent()]);
        };
        var id = GlobalScheduler.scheduler.setTimeout(sender, delay);
        return function () {
            return GlobalScheduler.scheduler.clearTimeout(id);
        };
    }).withDesc(new Desc("Bacon", "later", [delay, value]));
}

/** @hidden */
function delay(src, delay) {
    return src.transformChanges(new Desc(src, "delay", [delay]), function (changes) {
        return changes.flatMap(function (value) {
            return later(delay, value);
        });
    });
}

/** @hidden */
function debounce(src, delay) {
    return src.transformChanges(new Desc(src, "debounce", [delay]), function (changes) {
        return changes.flatMapLatest(function (value) {
            return later(delay, value);
        });
    });
}
/** @hidden */
function debounceImmediate(src, delay) {
    return src.transformChanges(new Desc(src, "debounceImmediate", [delay]), function (changes) {
        return changes.flatMapFirst(function (value) {
            return once(value).concat(later(delay, value).errors());
        });
    });
}

/** @hidden */
function throttle(src, delay) {
    return src.transformChanges(new Desc(src, "throttle", [delay]), function (changes) {
        return changes.bufferWithTime(delay).map(function (values) { return values[values.length - 1]; });
    });
}

/** @hidden */
function bufferingThrottle(src, minimumInterval) {
    var desc = new Desc(src, "bufferingThrottle", [minimumInterval]);
    return src.transformChanges(desc, function (changes) { return changes.flatMapConcat(function (x) {
        return once(x).concat(later(minimumInterval, x).errors());
    }); });
}

/** @hidden */
function takeWhile(src, f) {
    return withPredicate(src, f, takeWhileT, new Desc(src, "takeWhile", [f]));
}
function takeWhileT(f) {
    return function (event, sink) {
        if (event.filter(f)) {
            return sink(event);
        }
        else {
            sink(endEvent());
            return noMore;
        }
    };
}

/** @hidden */
function skipUntil(src, starter) {
    var started = starter
        .transform(composeT(takeT(1), mapT(true)))
        .toProperty()
        .startWith(false);
    return src.filter(started).withDesc(new Desc(src, "skipUntil", [starter]));
}

/** @hidden */
function skipWhile(src, f) {
    return withPredicate(src, f, skipWhileT, new Desc(src, "skipWhile", [f]));
}
/** @hidden */
function skipWhileT(f) {
    var started = false;
    return function (event, sink) {
        if (started || !hasValue(event) || !f(event.value)) {
            if (event.hasValue) {
                started = true;
            }
            return sink(event);
        }
        else {
            return more;
        }
    };
}

/** @hidden */
function groupBy(src, keyF, limitF) {
    if (limitF === void 0) { limitF = _.id; }
    var streams = {};
    return src.transform(composeT(filterT(function (x) { return !streams[keyF(x)]; }), mapT(function (firstValue) {
        var key = keyF(firstValue);
        var similarValues = src.changes().filter(function (x) { return keyF(x) === key; });
        var data = once(firstValue).concat(similarValues);
        var limited = limitF(data, firstValue).toEventStream().transform(function (event, sink) {
            var reply = sink(event);
            if (event.isEnd) {
                delete streams[key];
            }
            return reply;
        });
        streams[key] = limited;
        return limited;
    })));
}

/** @hidden */
function slidingWindow(src, maxValues, minValues) {
    if (minValues === void 0) { minValues = 0; }
    return src.scan([], (function (window, value) {
        return window.concat([value]).slice(-maxValues);
    }))
        .filter((function (values) {
        return values.length >= minValues;
    })).withDesc(new Desc(src, "slidingWindow", [maxValues, minValues]));
}

var nullMarker = {};
/** @hidden */
function diff(src, start, f) {
    return transformP(scan(src, [start, nullMarker], (function (prevTuple, next) { return [next, f(prevTuple[0], next)]; })), composeT(filterT(function (tuple) { return tuple[1] !== nullMarker; }), mapT(function (tuple) { return tuple[1]; })), new Desc(src, "diff", [start, f]));
}

/** @hidden */
function flatScan(src, seed, f) {
    var current = seed;
    return src.flatMapConcat(function (next) {
        return makeObservable(f(current, next)).doAction(function (updated) { return current = updated; });
    }).toProperty().startWith(seed).withDesc(new Desc(src, "flatScan", [seed, f]));
}

/** @hidden */
function holdWhen(src, valve) {
    var onHold = false;
    var bufferedValues = [];
    var srcIsEnded = false;
    return new EventStream(new Desc(src, "holdWhen", [valve]), function (sink) {
        var composite = new CompositeUnsubscribe();
        var subscribed = false;
        var endIfBothEnded = function (unsub) {
            if (unsub) {
                unsub();
            }
            if (composite.empty() && subscribed) {
                return sink(endEvent());
            }
            return more;
        };
        composite.add(function (unsubAll, unsubMe) {
            return valve.subscribeInternal(function (event) {
                if (hasValue(event)) {
                    onHold = event.value;
                    var result = more;
                    if (!onHold) {
                        var toSend = bufferedValues;
                        bufferedValues = [];
                        for (var i = 0; i < toSend.length; i++) {
                            result = sink(nextEvent(toSend[i]));
                        }
                        if (srcIsEnded) {
                            sink(endEvent());
                            unsubMe();
                            result = noMore;
                        }
                    }
                    return result;
                }
                else if (event.isEnd) {
                    return endIfBothEnded(unsubMe);
                }
                else {
                    return sink(event);
                }
            });
        });
        composite.add(function (unsubAll, unsubMe) {
            return src.subscribeInternal(function (event) {
                if (onHold && hasValue(event)) {
                    bufferedValues.push(event.value);
                    return more;
                }
                else if (event.isEnd && bufferedValues.length) {
                    srcIsEnded = true;
                    return endIfBothEnded(unsubMe);
                }
                else {
                    return sink(event);
                }
            });
        });
        subscribed = true;
        endIfBothEnded();
        return composite.unsubscribe;
    });
}

/**
 Zips the array of EventStreams / Properties in to a new
 EventStream that will have an array of values from each source as
 its value. Zipping means that events from each source are combined
 pairwise so that the 1st event from each source is published first, then
 the 2nd event from each. The results will be published as soon as there
 is a value from each source.

 Be careful not to have too much "drift" between streams. If one stream
 produces many more values than some other excessive buffering will
 occur inside the zipped observable.

 Example:

 ```js
 x = Bacon.fromArray([1,2,3])
 y = Bacon.fromArray([10, 20, 30])
 z = Bacon.fromArray([100, 200, 300])
 Bacon.zipAsArray(x, y, z)

 # produces values [1, 10, 100], [2, 20, 200] and [3, 30, 300]
 ```

 */
function zipAsArray() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var streams = _.map((function (s) { return s.toEventStream(); }), argumentsToObservables(args));
    return when([streams, function () {
            var xs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                xs[_i] = arguments[_i];
            }
            return xs;
        }]).withDesc(new Desc("Bacon", "zipAsArray", args));
}
/**
 Like [`zipAsArray`](#bacon-zipasarray) but uses the given n-ary
 function to combine the n values from n sources, instead of returning them in an Array.
 */
function zipWith(f) {
    var streams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        streams[_i - 1] = arguments[_i];
    }
    var _a = argumentsToObservablesAndFunction(arguments), streams = _a[0], f = _a[1];
    streams = _.map((function (s) { return s.toEventStream(); }), streams);
    return when([streams, f]).withDesc(new Desc("Bacon", "zipWith", [f].concat(streams)));
}
/** @hidden */
function zip(left, right, f) {
    return zipWith(f || Array, left, right).withDesc(new Desc(left, "zip", [right]));
}

function combineTemplate(template) {
    function current(ctxStack) { return ctxStack[ctxStack.length - 1]; }
    function setValue(ctxStack, key, value) {
        current(ctxStack)[key] = value;
        return value;
    }
    function applyStreamValue(key, index) {
        return function (ctxStack, values) {
            setValue(ctxStack, key, values[index]);
        };
    }
    function constantValue(key, value) {
        return function (ctxStack) {
            setValue(ctxStack, key, value);
        };
    }
    function mkContext(template) {
        return isArray(template) ? [] : {};
    }
    function pushContext(key, value) {
        return function (ctxStack) {
            var newContext = mkContext(value);
            setValue(ctxStack, key, newContext);
            ctxStack.push(newContext);
        };
    }
    function containsObservables(value) {
        if (isObservable(value)) {
            return true;
        }
        else if (value && (value.constructor == Object || value.constructor == Array)) {
            for (var key in value) {
                if (Object.prototype.hasOwnProperty.call(value, key)) {
                    var child = value[key];
                    if (containsObservables(child))
                        return true;
                }
            }
        }
    }
    function compile(key, value) {
        if (isObservable(value)) {
            streams.push(value);
            funcs.push(applyStreamValue(key, streams.length - 1));
        }
        else if (containsObservables(value)) {
            var popContext = function (ctxStack) { ctxStack.pop(); };
            funcs.push(pushContext(key, value));
            compileTemplate(value);
            funcs.push(popContext);
        }
        else {
            funcs.push(constantValue(key, value));
        }
    }
    function combinator(values) {
        var rootContext = mkContext(template);
        var ctxStack = [rootContext];
        for (var i = 0, f; i < funcs.length; i++) {
            f = funcs[i];
            f(ctxStack, values);
        }
        return rootContext;
    }
    function compileTemplate(template) { _.each(template, compile); }
    var funcs = [];
    var streams = [];
    var resultProperty = containsObservables(template)
        ? (compileTemplate(template), combineAsArray(streams).map(combinator))
        : constant(template);
    return resultProperty.withDesc(new Desc("Bacon", "combineTemplate", [template]));
}

/** @hidden */
function decode(src, cases) {
    return src.combine(combineTemplate(cases), function (key, values) { return values[key]; })
        .withDesc(new Desc(src, "decode", [cases]));
}

/** @hidden */
function firstToPromise(src, PromiseCtr) {
    // Can't do in the global scope, as shim can be applied after Bacon is loaded.
    if (typeof PromiseCtr !== "function") {
        if (typeof Promise === "function") {
            PromiseCtr = function (f) { return new Promise(f); };
        }
        else {
            throw new Error("There isn't default Promise, use shim or parameter");
        }
    }
    return new PromiseCtr(function (resolve, reject) {
        return src.subscribe(function (event) {
            if (hasValue(event)) {
                resolve(event.value);
            }
            if (isError(event)) {
                reject(event.error);
            }
            // One event is enough
            return noMore;
        });
    });
}
/** @hidden */
function toPromise(src, PromiseCtr) {
    return src.last().firstToPromise(PromiseCtr);
}

var idCounter = 0;
/**
 Observable is the base class for [EventsStream](eventstream.html) and [Property](property.html)

 @typeparam V   Type of the elements/values in the stream/property
 */
var Observable = /** @class */ (function () {
    function Observable(desc) {
        /**
         * Unique numeric id of this Observable. Implemented using a simple counter starting from 1.
         */
        this.id = ++idCounter;
        /** @hidden */
        this._isObservable = true;
        this.desc = desc;
        this.initialDesc = desc;
    }
    /**
  Creates a Property that indicates whether
  `observable` is awaiting `otherObservable`, i.e. has produced a value after the latest
  value from `otherObservable`. This is handy for keeping track whether we are
  currently awaiting an AJAX response:
  
  ```js
  var showAjaxIndicator = ajaxRequest.awaiting(ajaxResponse)
  ```
  
     */
    Observable.prototype.awaiting = function (other) {
        return awaiting(this, other);
    };
    /**
  Throttles the observable using a buffer so that at most one value event in minimumInterval is issued.
  Unlike [`throttle`](#observable-throttle), it doesn't discard the excessive events but buffers them instead, outputting
  them with a rate of at most one value per minimumInterval.
  
  Example:
  
  ```js
  var throttled = source.bufferingThrottle(2)
  ```
  
  ```
  source:    asdf----asdf----
  throttled: a-s-d-f-a-s-d-f-
  ```
     */
    Observable.prototype.bufferingThrottle = function (minimumInterval) {
        return bufferingThrottle(this, minimumInterval);
    };
    /**
  Combines the latest values of the two
  streams or properties using a two-arg function. Similarly to [`scan`](#scan), you can use a
  method name instead, so you could do `a.combine(b, ".concat")` for two
  properties with array value. The result is a [Property](property.html).
     */
    Observable.prototype.combine = function (right, f) {
        return combine(this, right, f);
    };
    /**
  Throttles stream/property by given amount
  of milliseconds, but so that event is only emitted after the given
  "quiet period". Does not affect emitting the initial value of a [Property](property.html).
  The difference of [`throttle`](#throttle) and [`debounce`](#debounce) is the same as it is in the
  same methods in jQuery.
  
  Example:
  
  ```
  source:             asdf----asdf----
  source.debounce(2): -----f-------f--
  ```
  
     */
    Observable.prototype.debounce = function (minimumInterval) {
        return debounce(this, minimumInterval);
    };
    /**
  Passes the first event in the
  stream through, but after that, only passes events after a given number
  of milliseconds have passed since previous output.
  
  Example:
  
  ```
  source:                      asdf----asdf----
  source.debounceImmediate(2): a-d-----a-d-----
  ```
     */
    Observable.prototype.debounceImmediate = function (minimumInterval) {
        return debounceImmediate(this, minimumInterval);
    };
    /**
  Decodes input using the given mapping. Is a
  bit like a switch-case or the decode function in Oracle SQL. For
  example, the following would map the value 1 into the string "mike"
  and the value 2 into the value of the `who` property.
  
  ```js
  property.decode({1 : "mike", 2 : who})
  ```
  
  This is actually based on [`combineTemplate`](#combinetemplate) so you can compose static
  and dynamic data quite freely, as in
  
  ```js
  property.decode({1 : { type: "mike" }, 2 : { type: "other", whoThen : who }})
  ```
  
  The return value of [`decode`](#decode) is always a [`Property`](property.html).
  
     */
    //decode<T extends Record<any, any>>(src: Observable<keyof T>, cases: T): Property<DecodedValueOf<T>>
    Observable.prototype.decode = function (cases) {
        return decode(this, cases);
    };
    /**
  Delays the stream/property by given amount of milliseconds. Does not delay the initial value of a [`Property`](property.html).
  
  ```js
  var delayed = source.delay(2)
  ```
  
  ```
  source:    asdf----asdf----
  delayed:   --asdf----asdf--
  ```
  
     */
    Observable.prototype.delay = function (delayMs) {
        return delay(this, delayMs);
    };
    /**
     * Returns the an array of dependencies that the Observable has. For instance, for `a.map(function() {}).deps()`, would return `[a]`.
     This method returns the "visible" dependencies only, skipping internal details.  This method is thus suitable for visualization tools.
     Internally, many combinator functions depend on other combinators to create intermediate Observables that the result will actually depend on.
     The `deps` method will skip these internal dependencies. See also: [internalDeps](#internaldeps)
     */
    Observable.prototype.deps = function () {
        return this.desc.deps();
    };
    /**
  Returns a Property that represents the result of a comparison
  between the previous and current value of the Observable. For the initial value of the Observable,
  the previous value will be the given start.
  
  Example:
  
  ```js
  var distance = function (a,b) { return Math.abs(b - a) }
  Bacon.sequentially(1, [1,2,3]).diff(0, distance)
  ```
  
  This would result to following elements in the result stream:
  
      1 - 0 = 1
      2 - 1 = 1
      3 - 2 = 1
  
     */
    Observable.prototype.diff = function (start, f) {
        return diff(this, start, f);
    };
    /**
  Returns a stream/property where the function f
  is executed for each value, before dispatching to subscribers. This is
  useful for debugging, but also for stuff like calling the
  `preventDefault()` method for events. In fact, you can
  also use a property-extractor string instead of a function, as in
  `".preventDefault"`.
  
  Please note that for Properties, it's not guaranteed that the function will be called exactly once
  per event; when a Property loses all of its subscribers it will re-emit its current value when a
  new subscriber is added.
     */
    Observable.prototype.doAction = function (f) {
        return this.transform(doActionT(f), new Desc(this, "doAction", [f]));
    };
    Observable.prototype.doEnd = function (f) {
        return this.transform(doEndT(f), new Desc(this, "doEnd", [f]));
    };
    /**
  Returns a stream/property where the function f
  is executed for each error, before dispatching to subscribers.
  That is, same as [`doAction`](#observable-doaction) but for errors.
     */
    Observable.prototype.doError = function (f) {
        return this.transform(doErrorT(f), new Desc(this, "doError", [f]));
    };
    /**
  Logs each value of the Observable to the console. doLog() behaves like [`log`](#log)
  but does not subscribe to the event stream. You can think of doLog() as a
  logger function that – unlike log() – is safe to use in production. doLog() is
  safe, because it does not cause the same surprising side-effects as log()
  does.
     */
    Observable.prototype.doLog = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return this.transform(doLogT(args), new Desc(this, "doLog", args));
    };
    Observable.prototype.endAsValue = function () {
        return endAsValue(this);
    };
    /**
    Returns a stream/property that ends the on first [`Error`](error.html) event. The
    error is included in the output of the returned Observable.
    
    @param  predicate   optional predicate function to determine whether to end on a given error
     */
    Observable.prototype.endOnError = function (predicate) {
        if (predicate === void 0) { predicate = function (x) { return true; }; }
        return endOnError(this, predicate);
    };
    /**
  Returns a stream containing [`Error`](error.html) events only.
  Same as filtering with a function that always returns false.
     */
    Observable.prototype.errors = function () {
        return this.filter(function (x) { return false; }).withDesc(new Desc(this, "errors"));
    };
    /**
  Filters values using given predicate function.
  Instead of a function, you can use a constant value (`true` to include all, `false` to exclude all).
  
  You can also filter values based on the value of a
  property. Event will be included in output [if and only if](http://en.wikipedia.org/wiki/If_and_only_if) the property holds `true`
  at the time of the event.
     */
    Observable.prototype.filter = function (f) {
        return filter$1(this, f);
    };
    /**
  Takes the first element from the stream. Essentially `observable.take(1)`.
     */
    Observable.prototype.first = function () {
        return take(1, this, new Desc(this, "first"));
    };
    /**
  Returns a Promise which will be resolved with the first event coming from an Observable.
  Like [`toPromise`](#topromise), the global ES6 promise implementation will be used unless a promise
  constructor is given.
     */
    Observable.prototype.firstToPromise = function (PromiseCtr) {
        return firstToPromise(this, PromiseCtr);
    };
    /**
  Works like [`scan`](#scan) but only emits the final
  value, i.e. the value just before the observable ends. Returns a
  [`Property`](property.html).
     */
    Observable.prototype.fold = function (seed, f) {
        return fold$1(this, seed, f);
    };
    /**
     An alias for [onValue](#onvalue).
  
     Subscribes a given handler function to the observable. Function will be called for each new value (not for errors or stream end).
     */
    Observable.prototype.forEach = function (f) {
        if (f === void 0) { f = nullSink; }
        // TODO: inefficient alias. Also, similar assign alias missing.
        return this.onValue(f);
    };
    /**
  Pauses and buffers the event stream if last event in valve is truthy.
  All buffered events are released when valve becomes falsy.
     */
    Observable.prototype.holdWhen = function (valve) {
        return holdWhen(this, valve);
    };
    Observable.prototype.inspect = function () { return this.toString(); };
    /**
     * Returns the true dependencies of the observable, including the intermediate "hidden" Observables.
     This method is for Bacon.js internal purposes but could be useful for debugging/analysis tools as well.
     See also: [deps](#deps)
     */
    Observable.prototype.internalDeps = function () {
        return this.initialDesc.deps();
    };
    /**
  Takes the last element from the stream. None, if stream is empty.
  
  
  *Note:* `neverEndingStream.last()` creates the stream which doesn't produce any events and never ends.
     */
    Observable.prototype.last = function () {
        return last$1(this);
    };
    /**
  Logs each value of the Observable to the console.
  It optionally takes arguments to pass to console.log() alongside each
  value. To assist with chaining, it returns the original Observable. Note
  that as a side-effect, the observable will have a constant listener and
  will not be garbage-collected. So, use this for debugging only and
  remove from production code. For example:
  
  ```js
  myStream.log("New event in myStream")
  ```
  
  or just
  
  ```js
  myStream.log()
  ```
  
     */
    Observable.prototype.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        log(args, this);
        return this;
    };
    /**
  Adds an extra [`Next`](next.html) event just before End. The value is created
  by calling the given function when the source stream ends. Instead of a
  function, a static value can be used.
     */
    // TODO: mapEnd and mapError signatures should allow V|V2
    Observable.prototype.mapEnd = function (f) {
        return this.transform(mapEndT(f), new Desc(this, "mapEnd", [f]));
    };
    /**
  Maps errors using given function. More
  specifically, feeds the "error" field of the error event to the function
  and produces a [`Next`](next.html) event based on the return value.
     */
    Observable.prototype.mapError = function (f) {
        return this.transform(mapErrorT(f), new Desc(this, "mapError", [f]));
    };
    /**
  Sets the name of the observable. Overrides the default
  implementation of [`toString`](#tostring) and `inspect`.
  Returns the same observable, with mutated name.
     */
    Observable.prototype.name = function (name) {
        this._name = name;
        return this;
    };
    /**
  Subscribes a callback to stream end. The function will be called when the stream ends.
  Just like `subscribe`, this method returns a function for unsubscribing.
     */
    Observable.prototype.onEnd = function (f) {
        if (f === void 0) { f = nullVoidSink; }
        return this.subscribe(function (event) {
            if (event.isEnd) {
                return f();
            }
            return more;
        });
    };
    /**
  Subscribes a handler to error events. The function will be called for each error in the stream.
  Just like `subscribe`, this method returns a function for unsubscribing.
     */
    Observable.prototype.onError = function (f) {
        if (f === void 0) { f = nullSink; }
        return this.subscribe(function (event) {
            if (isError(event)) {
                return f(event.error);
            }
            return more;
        });
    };
    /**
  Subscribes a given handler function to the observable. Function will be called for each new value.
  This is the simplest way to assign a side-effect to an observable. The difference
  to the `subscribe` method is that the actual stream values are
  received, instead of [`Event`](event) objects.
  Just like `subscribe`, this method returns a function for unsubscribing.
  `stream.onValue` and `property.onValue` behave similarly, except that the latter also
  pushes the initial value of the property, in case there is one.
     */
    Observable.prototype.onValue = function (f) {
        if (f === void 0) { f = nullSink; }
        return this.subscribe(function (event) {
            if (hasValue(event)) {
                return f(event.value);
            }
            return more;
        });
    };
    /**
  Like [`onValue`](#onvalue), but splits the value (assuming its an array) as function arguments to `f`.
  Only applicable for observables with arrays as values.
     */
    Observable.prototype.onValues = function (f) {
        return this.onValue(function (args) { return f.apply(void 0, args); });
    };
    /** A synonym for [scan](#scan).
     */
    Observable.prototype.reduce = function (seed, f) {
        return fold$1(this, seed, f);
    };
    Observable.prototype.sampledBy = function (sampler) {
        return sampledBy(this, sampler, arguments[1]); // TODO: combinator
    };
    /**
  Scans stream/property with given seed value and
  accumulator function, resulting to a Property. For example, you might
  use zero as seed and a "plus" function as the accumulator to create
  an "integral" property. Instead of a function, you can also supply a
  method name such as ".concat", in which case this method is called on
  the accumulator value and the new stream value is used as argument.
  
  Example:
  
  ```js
  var plus = function (a,b) { return a + b }
  Bacon.sequentially(1, [1,2,3]).scan(0, plus)
  ```
  
  This would result to following elements in the result stream:
  
      seed value = 0
      0 + 1 = 1
      1 + 2 = 3
      3 + 3 = 6
  
  When applied to a Property as in `r = p.scan(seed, f)`, there's a (hopefully insignificant) catch:
  The starting value for `r` depends on whether `p` has an
  initial value when scan is applied. If there's no initial value, this works
  identically to EventStream.scan: the `seed` will be the initial value of
  `r`. However, if `r` already has a current/initial value `x`, the
  seed won't be output as is. Instead, the initial value of `r` will be `f(seed, x)`. This makes sense,
  because there can only be 1 initial value for a Property at a time.
     */
    Observable.prototype.scan = function (seed, f) {
        return scan(this, seed, f);
    };
    /**
  Skips the first n elements from the stream
     */
    Observable.prototype.skip = function (count) {
        return skip(this, count);
    };
    /**
  Drops consecutive equal elements. So,
  from `[1, 2, 2, 1]` you'd get `[1, 2, 1]`. Uses the `===` operator for equality
  checking by default. If the isEqual argument is supplied, checks by calling
  isEqual(oldValue, newValue). For instance, to do a deep comparison,you can
  use the isEqual function from [underscore.js](http://underscorejs.org/)
  like `stream.skipDuplicates(_.isEqual)`.
     */
    Observable.prototype.skipDuplicates = function (isEqual) {
        return skipDuplicates(this, isEqual);
    };
    /**
     * Returns a new stream/property which excludes all [Error](error.html) events in the source
     */
    Observable.prototype.skipErrors = function () {
        return skipErrors(this);
    };
    /**
     Skips elements from the source, until a value event
     appears in the given `starter` stream/property. In other words, starts delivering values
     from the source after first value appears in `starter`.
     */
    Observable.prototype.skipUntil = function (starter) {
        return skipUntil(this, starter);
    };
    /**
     Skips elements until the given predicate function returns falsy once, and then
     lets all events pass through. Instead of a predicate you can also pass in a `Property<boolean>` to skip elements
     while the Property holds a truthy value.
     */
    Observable.prototype.skipWhile = function (f) {
        return skipWhile(this, f);
    };
    /**
  Returns a Property that represents a
  "sliding window" into the history of the values of the Observable. The
  result Property will have a value that is an array containing the last `n`
  values of the original observable, where `n` is at most the value of the
  `max` argument, and at least the value of the `min` argument. If the
  `min` argument is omitted, there's no lower limit of values.
  
  For example, if you have a stream `s` with value a sequence 1 - 2 - 3 - 4 - 5, the
  respective values in `s.slidingWindow(2)` would be [] - [1] - [1,2] -
  [2,3] - [3,4] - [4,5]. The values of `s.slidingWindow(2,2)`would be
  [1,2] - [2,3] - [3,4] - [4,5].
  
     */
    Observable.prototype.slidingWindow = function (maxValues, minValues) {
        if (minValues === void 0) { minValues = 0; }
        return slidingWindow(this, maxValues, minValues);
    };
    /**
     * subscribes given handler function to event stream. Function will receive [event](event.html) objects
     for all new value, end and error events in the stream.
     The subscribe() call returns a `unsubscribe` function that you can call to unsubscribe.
     You can also unsubscribe by returning [`Bacon.noMore`](../globals.html#nomore) from the handler function as a reply
     to an Event.
     `stream.subscribe` and `property.subscribe` behave similarly, except that the latter also
     pushes the initial value of the property, in case there is one.
  
     * @param {EventSink<V>} sink the handler function
     * @returns {Unsub}
     */
    Observable.prototype.subscribe = function (sink) {
        var _this = this;
        if (sink === void 0) { sink = nullSink; }
        return UpdateBarrier.wrappedSubscribe(this, function (sink) { return _this.subscribeInternal(sink); }, sink);
    };
    /**
  Takes at most n values from the stream and then ends the stream. If the stream has
  fewer than n values then it is unaffected.
  Equal to [`Bacon.never()`](../globals.html#never) if `n <= 0`.
     */
    Observable.prototype.take = function (count) {
        return take(count, this);
    };
    /**
  Takes elements from source until a value event appears in the other stream.
  If other stream ends without value, it is ignored.
     */
    Observable.prototype.takeUntil = function (stopper) {
        return takeUntil(this, stopper);
    };
    /**
  Takes while given predicate function holds true, and then ends. Alternatively, you can supply a boolean Property to take elements while the Property holds `true`.
     */
    Observable.prototype.takeWhile = function (f) {
        return takeWhile(this, f);
    };
    /**
  Throttles stream/property by given amount
  of milliseconds. Events are emitted with the minimum interval of
  [`delay`](#observable-delay). The implementation is based on [`stream.bufferWithTime`](#stream-bufferwithtime).
  Does not affect emitting the initial value of a [`Property`](#property).
  
  Example:
  
  ```js
  var throttled = source.throttle(2)
  ```
  
  ```
  source:    asdf----asdf----
  throttled: --s--f----s--f--
  ```
     */
    Observable.prototype.throttle = function (minimumInterval) {
        return throttle(this, minimumInterval);
    };
    /**
  Returns a Promise which will be resolved with the last event coming from an Observable.
  The global ES6 promise implementation will be used unless a promise constructor is given.
  Use a shim if you need to support legacy browsers or platforms.
  [caniuse promises](http://caniuse.com/#feat=promises).
  
  See also [firstToPromise](#firsttopromise).
     */
    Observable.prototype.toPromise = function (PromiseCtr) {
        return toPromise(this, PromiseCtr);
    };
    /**
     *Returns a textual description of the Observable. For instance, `Bacon.once(1).map(function() {}).toString()` would return "Bacon.once(1).map(function)".
     **/
    Observable.prototype.toString = function () {
        if (this._name) {
            return this._name;
        }
        else {
            return this.desc.toString();
        }
    };
    Observable.prototype.withDesc = function (desc) {
        if (desc)
            this.desc = desc;
        return this;
    };
    /**
  Sets the structured description of the observable. The [`toString`](#tostring) and `inspect` methods
  use this data recursively to create a string representation for the observable. This method
  is probably useful for Bacon core / library / plugin development only.
  
  For example:
  
      var src = Bacon.once(1)
      var obs = src.map(function(x) { return -x })
      console.log(obs.toString())
      --> Bacon.once(1).map(function)
      obs.withDescription(src, "times", -1)
      console.log(obs.toString())
      --> Bacon.once(1).times(-1)
  
  The method returns the same observable with mutated description.
  
  */
    Observable.prototype.withDescription = function (context, method) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        this.desc = describe.apply(void 0, [context, method].concat(args));
        return this;
    };
    /**
  Returns an EventStream with elements
  pair-wise lined up with events from this and the other EventStream or Property.
  A zipped stream will publish only when it has a value from each
  source and will only produce values up to when any single source ends.
  
  The given function `f` is used to create the result value from value in the two
  sources. If no function is given, the values are zipped into an array.
  
  Be careful not to have too much "drift" between streams. If one stream
  produces many more values than some other excessive buffering will
  occur inside the zipped observable.
  
  Example 1:
  
  ```js
  var x = Bacon.fromArray([1, 2])
  var y = Bacon.fromArray([3, 4])
  x.zip(y, function(x, y) { return x + y })
  
  # produces values 4, 6
  ```
  
  See also [`zipWith`](../globals.html#zipwith) and [`zipAsArray`](../globals.html/zipasarray) for zipping more than 2 sources.
  
     */
    Observable.prototype.zip = function (other, f) {
        return zip(this, other, f);
    };
    return Observable;
}());
/**
 A reactive property. Has the concept of "current value".
 You can create a Property from an EventStream by using either [`toProperty`](eventstream.html#toproperty)
 or [`scan`](eventstream.html#scan) method. Note: depending on how a Property is created, it may or may not
 have an initial value. The current value stays as its last value after the stream has ended.

 Here are the most common ways for creating Properties:

 - Create a constant property with [constant](../globals.html#constant)
 - Create a property based on an EventStream with [toProperty](eventstream.html#toproperty)
 - Scan an EventStream with an accumulator function with [scan](eventstream.html#scan)
 - Create a state property based on multiple sources using [update](../globals.html#update)

 @typeparam V   Type of the elements/values in the stream/property
 */
var Property = /** @class */ (function (_super) {
    __extends(Property, _super);
    function Property(desc, subscribe, handler) {
        var _this = _super.call(this, desc) || this;
        /** @internal */
        _this._isProperty = true;
        assertFunction(subscribe);
        _this.dispatcher = new PropertyDispatcher(_this, subscribe, handler);
        registerObs(_this);
        return _this;
    }
    /**
     Combines properties with the `&&` operator. It produces a new value when either of the Properties change,
     combining the latest values using `&&`.
     */
    Property.prototype.and = function (other) {
        return and(this, other);
    };
    /**
     * creates a stream of changes to the Property. The stream *does not* include
     an event for the current value of the Property at the time this method was called.
     */
    Property.prototype.changes = function () {
        var _this = this;
        return new EventStream(new Desc(this, "changes", []), function (sink) { return _this.dispatcher.subscribe(function (event) {
            if (!event.isInitial) {
                return sink(event);
            }
            return more;
        }); });
    };
    Property.prototype.concat = function (other) {
        return this.transformChanges(describe(this, "concat", other), function (changes) { return changes.concat(other); });
    };
    /** @hidden */
    Property.prototype.transformChanges = function (desc, f) {
        return transformPropertyChanges(this, f, desc);
    };
    /**
     For each element in the source stream, spawn a new
     stream/property using the function `f`. Collect events from each of the spawned
     streams into the result property. Note that instead of a function, you can provide a
     stream/property too. Also, the return value of function `f` can be either an
     `Observable` (stream/property) or a constant value.
  
     `stream.flatMap()` can be used conveniently with [`Bacon.once()`](../globals.html#once) and [`Bacon.never()`](../globals.html#never)
     for converting and filtering at the same time, including only some of the results.
  
     Example - converting strings to integers, skipping empty values:
  
     ```js
     stream.flatMap(function(text) {
      return (text != "") ? parseInt(text) : Bacon.never()
  })
     ```
     */
    Property.prototype.flatMap = function (f) {
        return flatMap$1(this, f);
    };
    /**
     A [`flatMapWithConcurrencyLimit`](#flatmapwithconcurrencylimit) with limit of 1.
     */
    Property.prototype.flatMapConcat = function (f) {
        return flatMapConcat(this, f);
    };
    /**
     Like [`flatMap`](#flatmap), but is applied only on [`Error`](error.html) events. Returned values go into the
     value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just
     passed through, which can be implemented using flatMapError.
     */
    Property.prototype.flatMapError = function (f) {
        return flatMapError(this, f);
    };
    Property.prototype.flatMapEvent = function (f) {
        return flatMapEvent(this, f);
    };
    /**
     Like [`flatMap`](#observable-flatmap), but only spawns a new
     stream if the previously spawned stream has ended.
     */
    Property.prototype.flatMapFirst = function (f) {
        return flatMapFirst(this, f);
    };
    /**
     Like [`flatMap`](#flatmap), but instead of including events from
     all spawned streams, only includes them from the latest spawned stream.
     You can think this as switching from stream to stream.
     Note that instead of a function, you can provide a stream/property too.
     */
    Property.prototype.flatMapLatest = function (f) {
        return flatMapLatest(this, f);
    };
    /**
     A super method of *flatMap* family. It limits the number of open spawned streams and buffers incoming events.
     [`flatMapConcat`](#flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),
     and [`flatMap`](#flatmap) is `flatMapWithConcurrencyLimit ∞` (all inputs are piped to output).
     */
    Property.prototype.flatMapWithConcurrencyLimit = function (limit, f) {
        return flatMapWithConcurrencyLimit(this, limit, f);
    };
    /**
     Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
     stream life. Stream transformed by `limitF` is passed on if provided. `limitF` gets grouped stream
     and the original event causing the stream to start as parameters.
  
     Calculator for grouped consecutive values until group is cancelled:
  
     ```
     var events = [
     {id: 1, type: "add", val: 3 },
     {id: 2, type: "add", val: -1 },
     {id: 1, type: "add", val: 2 },
     {id: 2, type: "cancel"},
     {id: 3, type: "add", val: 2 },
     {id: 3, type: "cancel"},
     {id: 1, type: "add", val: 1 },
     {id: 1, type: "add", val: 2 },
     {id: 1, type: "cancel"}
     ]
  
     function keyF(event) {
    return event.id
  }
  
     function limitF(groupedStream, groupStartingEvent) {
    var cancel = groupedStream.filter(function(x) { return x.type === "cancel"}).take(1)
    var adds = groupedStream.filter(function(x) { return x.type === "add" })
    return adds.takeUntil(cancel).map(".val")
  }
  
     Bacon.sequentially(2, events)
     .groupBy(keyF, limitF)
     .flatMap(function(groupedStream) {
      return groupedStream.fold(0, function(acc, x) { return acc + x })
    })
     .onValue(function(sum) {
      console.log(sum)
      // returns [-1, 2, 8] in an order
    })
     ```
  
     */
    Property.prototype.groupBy = function (keyF, limitF) {
        return groupBy(this, keyF, limitF);
    };
    /**
     Maps values using given function, returning a new
     stream/property. Instead of a function, you can also provide a [Property](property.html),
     in which case each element in the source stream will be mapped to the current value of
     the given property.
     */
    Property.prototype.map = function (f) {
        return map$1(this, f);
    };
    /** Returns a Property that inverts the value of this one (using the `!` operator). **/
    Property.prototype.not = function () {
        return not(this);
    };
    /**
     Combines properties with the `||` operator. It produces a new value when either of the Properties change,
     combining the latest values using `||`.
     */
    Property.prototype.or = function (other) {
        return or(this, other);
    };
    /**
     Creates an EventStream by sampling the
     property value at given interval (in milliseconds)
     */
    Property.prototype.sample = function (interval) {
        return sampleP(this, interval);
    };
    /**
    Adds an initial "default" value for the
    Property. If the Property doesn't have an initial value of it's own, the
    given value will be used as the initial value. If the property has an
    initial value of its own, the given value will be ignored.
     */
    Property.prototype.startWith = function (seed) {
        return startWithP(this, seed);
    };
    /** @hidden */
    Property.prototype.subscribeInternal = function (sink) {
        if (sink === void 0) { sink = nullSink; }
        return this.dispatcher.subscribe(sink);
    };
    /**
     Creates an EventStream based on this Property. The stream contains also an event for the current
     value of this Property at the time this method was called.
     */
    Property.prototype.toEventStream = function (options) {
        var _this = this;
        return new EventStream(new Desc(this, "toEventStream", []), function (sink) { return _this.subscribeInternal(function (event) {
            return sink(event.toNext());
        }); }, undefined, options);
    };
    /**
     Returns the Property itself.
     */
    Property.prototype.toProperty = function () {
        assertNoArguments(arguments);
        return this;
    };
    Property.prototype.transform = function (transformer, desc) {
        return transformP(this, transformer, desc);
    };
    /**
     Creates an EventStream/Property by sampling a given `samplee`
     stream/property value at each event from the this stream/property.
  
     @param {Observable<V2>} samplee
     @param f function to select/calculate the result value based on the value in the source stream and the samplee
  
     @typeparam V2  type of values in the samplee
     @typeparam R   type of values in the result
     */
    Property.prototype.withLatestFrom = function (samplee, f) {
        return withLatestFromP(this, samplee, f);
    };
    /**
     Lets you run a state machine
     on an observable. Give it an initial state object and a state
     transformation function that processes each incoming event and
     returns an array containing the next state and an array of output
     events. Here's an example where we calculate the total sum of all
     numbers in the stream and output the value on stream end:
  
     ```js
     Bacon.fromArray([1,2,3])
     .withStateMachine(0, function(sum, event) {
      if (event.hasValue)
        return [sum + event.value, []]
      else if (event.isEnd)
        return [undefined, [new Bacon.Next(sum), event]]
      else
        return [sum, [event]]
    })
     ```
     @param initState  initial state for the state machine
     @param f          the function that defines the state machine
     @typeparam  State   type of machine state
     @typeparam  Out     type of values to be emitted
     */
    Property.prototype.withStateMachine = function (initState, f) {
        return withStateMachine(initState, f, this);
    };
    return Property;
}(Observable));
/** @hidden */
function isProperty(x) {
    return !!x._isProperty;
}
// allowSync option is used for overriding the "force async" behaviour or EventStreams.
// ideally, this should not exist, but right now the implementation of some operations
// relies on using internal EventStreams that have synchronous behavior. These are not exposed
// to the outside world, though.
/** @hidden */
var allowSync = { forceAsync: false };
/**
 * EventStream represents a stream of events. It is an Observable object, meaning
 that you can listen to events in the stream using, for instance, the [`onValue`](#onvalue) method
 with a callback.

 To create an EventStream, you'll want to use one of the following factory methods:

  - From DOM EventTarget or Node.JS EventEmitter objects using [fromEvent](../globals.html#fromevent)
  - From a Promise using [fromPromise](../globals.html#frompromise)
  - From an unary callback using [fromCallback](../globals.html#fromcallback)
  - From a Node.js style callback using [fromNodeCallback](../globals.html#fromnodecallback)
  - From RxJs or Kefir observables using [fromESObservable](../globals.html#fromesobservable)
  - By polling a synchronous function using [fromPoll](../globals.html#fromPoll)
  - Emit a single event instantly using [once](../globals.html#once)
  - Emit a single event with a delay [later](../globals.html#later)
  - Emit the same event indefinitely using [interval](../globals.html#interval)
  - Emit an array of events instantly [fromArray](../globals.html#fromarray)
  - Emit an array of events with a delay [sequentially](../globals.html#sequentially)
  - Emit an array of events repeatedly with a delay [repeatedly](../globals.html#repeatedly)
  - Use a generator function to be called repeatedly [repeat](../globals.html#repeat)
  - Create a stream that never emits an event, ending immediately [never](../globals.html#never)
  - Create a stream that never emits an event, ending with a delay [silence](../globals.html#silence)
  - Create stream using a custom binder function [fromBinder](../globals.html#frombinder)
  - Wrap jQuery events using [asEventStream](../globals.html#_)


 @typeparam V   Type of the elements/values in the stream/property

 */
var EventStream = /** @class */ (function (_super) {
    __extends(EventStream, _super);
    function EventStream(desc, subscribe, handler, options) {
        var _this = _super.call(this, desc) || this;
        /** @hidden */
        _this._isEventStream = true;
        if (options !== allowSync) {
            subscribe = asyncWrapSubscribe(_this, subscribe);
        }
        _this.dispatcher = new Dispatcher(_this, subscribe, handler);
        registerObs(_this);
        return _this;
    }
    /**
     Buffers stream events with given delay.
     The buffer is flushed at most once in the given interval. So, if your input
     contains [1,2,3,4,5,6,7], then you might get two events containing [1,2,3,4]
     and [5,6,7] respectively, given that the flush occurs between numbers 4 and 5.
  
     Also works with a given "defer-function" instead
     of a delay. Here's a simple example, which is equivalent to
     stream.bufferWithTime(10):
  
     ```js
     stream.bufferWithTime(function(f) { setTimeout(f, 10) })
     ```
  
     * @param delay buffer duration in milliseconds
     */
    EventStream.prototype.bufferWithTime = function (delay) {
        return bufferWithTime(this, delay);
    };
    /**
     Buffers stream events with given count.
     The buffer is flushed when it contains the given number of elements or the source stream ends.
  
     So, if you buffer a stream of `[1, 2, 3, 4, 5]` with count `2`, you'll get output
     events with values `[1, 2]`, `[3, 4]` and `[5]`.
  
     * @param {number} count
     */
    EventStream.prototype.bufferWithCount = function (count) {
        return bufferWithCount(this, count);
    };
    /**
     Buffers stream events and
     flushes when either the buffer contains the given number elements or the
     given amount of milliseconds has passed since last buffered event.
  
     * @param {number | DelayFunction} delay in milliseconds or as a function
     * @param {number} count  maximum buffer size
     */
    EventStream.prototype.bufferWithTimeOrCount = function (delay, count) {
        return bufferWithTimeOrCount(this, delay, count);
    };
    EventStream.prototype.changes = function () {
        return this;
    };
    EventStream.prototype.concat = function (other, options) {
        return concatE(this, other, options);
    };
    /** @hidden */
    EventStream.prototype.transformChanges = function (desc, f) {
        return f(this).withDesc(desc);
    };
    /**
     For each element in the source stream, spawn a new
     stream/property using the function `f`. Collect events from each of the spawned
     streams into the result stream/property. Note that instead of a function, you can provide a
     stream/property too. Also, the return value of function `f` can be either an
     `Observable` (stream/property) or a constant value.
  
     `stream.flatMap()` can be used conveniently with [`Bacon.once()`](../globals.html#once) and [`Bacon.never()`](../globals.html#never)
     for converting and filtering at the same time, including only some of the results.
  
     Example - converting strings to integers, skipping empty values:
  
     ```js
     stream.flatMap(function(text) {
      return (text != "") ? parseInt(text) : Bacon.never()
  })
     ```
     */
    EventStream.prototype.flatMap = function (f) { return flatMap$1(this, f); };
    /**
     A [`flatMapWithConcurrencyLimit`](#flatmapwithconcurrencylimit) with limit of 1.
     */
    EventStream.prototype.flatMapConcat = function (f) { return flatMapConcat(this, f); };
    /**
     Like [`flatMap`](#flatmap), but is applied only on [`Error`](error.html) events. Returned values go into the
     value stream, unless an error event is returned. As an example, one type of error could result in a retry and another just
     passed through, which can be implemented using flatMapError.
     */
    EventStream.prototype.flatMapError = function (f) { return flatMapError(this, f); };
    /**
     Like [`flatMap`](#observable-flatmap), but only spawns a new
     stream if the previously spawned stream has ended.
     */
    EventStream.prototype.flatMapFirst = function (f) { return flatMapFirst(this, f); };
    /**
     Like [`flatMap`](#flatmap), but instead of including events from
     all spawned streams, only includes them from the latest spawned stream.
     You can think this as switching from stream to stream.
     Note that instead of a function, you can provide a stream/property too.
     */
    EventStream.prototype.flatMapLatest = function (f) { return flatMapLatest(this, f); };
    /**
     A super method of *flatMap* family. It limits the number of open spawned streams and buffers incoming events.
     [`flatMapConcat`](#flatmapconcat) is `flatMapWithConcurrencyLimit(1)` (only one input active),
     and [`flatMap`](#flatmap) is `flatMapWithConcurrencyLimit ∞` (all inputs are piped to output).
     */
    EventStream.prototype.flatMapWithConcurrencyLimit = function (limit, f) { return flatMapWithConcurrencyLimit(this, limit, f); };
    EventStream.prototype.flatMapEvent = function (f) { return flatMapEvent(this, f); };
    /**
     Scans stream with given seed value and accumulator function, resulting to a Property.
     Difference to [`scan`](#scan) is that the function `f` can return an [`EventStream`](eventstream.html) or a [`Property`](property.html) instead
     of a pure value, meaning that you can use [`flatScan`](#flatscan) for asynchronous updates of state. It serializes
     updates so that that the next update will be queued until the previous one has completed.
  
     * @param seed initial value to start with
     * @param f transition function from previous state and new value to next state
     * @typeparam V2 state and result type
     */
    EventStream.prototype.flatScan = function (seed, f) {
        return flatScan(this, seed, f);
    };
    /**
     Groups stream events to new streams by `keyF`. Optional `limitF` can be provided to limit grouped
     stream life. Stream transformed by `limitF` is passed on if provided. `limitF` gets grouped stream
     and the original event causing the stream to start as parameters.
  
     Calculator for grouped consecutive values until group is cancelled:
  
     ```
     var events = [
     {id: 1, type: "add", val: 3 },
     {id: 2, type: "add", val: -1 },
     {id: 1, type: "add", val: 2 },
     {id: 2, type: "cancel"},
     {id: 3, type: "add", val: 2 },
     {id: 3, type: "cancel"},
     {id: 1, type: "add", val: 1 },
     {id: 1, type: "add", val: 2 },
     {id: 1, type: "cancel"}
     ]
  
     function keyF(event) {
    return event.id
  }
  
     function limitF(groupedStream, groupStartingEvent) {
    var cancel = groupedStream.filter(function(x) { return x.type === "cancel"}).take(1)
    var adds = groupedStream.filter(function(x) { return x.type === "add" })
    return adds.takeUntil(cancel).map(".val")
  }
  
     Bacon.sequentially(2, events)
     .groupBy(keyF, limitF)
     .flatMap(function(groupedStream) {
      return groupedStream.fold(0, function(acc, x) { return acc + x })
    })
     .onValue(function(sum) {
      console.log(sum)
      // returns [-1, 2, 8] in an order
    })
     ```
  
     */
    EventStream.prototype.groupBy = function (keyF, limitF) {
        return groupBy(this, keyF, limitF);
    };
    /**
   Maps values using given function, returning a new
   stream/property. Instead of a function, you can also provide a [Property](property.html),
   in which case each element in the source stream will be mapped to the current value of
   the given property.
   */
    EventStream.prototype.map = function (f) {
        return map$1(this, f);
    };
    EventStream.prototype.merge = function (other) {
        assertEventStream(other);
        return mergeAll(this, other).withDesc(new Desc(this, "merge", [other]));
    };
    /**
     Returns a stream/property that inverts boolean values (using `!`)
     */
    EventStream.prototype.not = function () { return not(this); };
    /**
     Adds a starting value to the stream/property, i.e. concats a
     single-element stream containing the single seed value  with this stream.
     */
    // TODO: should allow V|V2 signature
    EventStream.prototype.startWith = function (seed) {
        return startWithE(this, seed);
    };
    /** @hidden */
    EventStream.prototype.subscribeInternal = function (sink) {
        if (sink === void 0) { sink = nullSink; }
        return this.dispatcher.subscribe(sink);
    };
    /**
     * Returns this stream.
     */
    EventStream.prototype.toEventStream = function () { return this; };
    /**
     Creates a Property based on the
     EventStream.
  
     Without arguments, you'll get a Property without an initial value.
     The Property will get its first actual value from the stream, and after that it'll
     always have a current value.
  
     You can also give an initial value that will be used as the current value until
     the first value comes from the stream.
     */
    EventStream.prototype.toProperty = function (initValue) {
        var usedInitValue = arguments.length
            ? toOption(initValue)
            : none();
        var disp = this.dispatcher;
        var desc = new Desc(this, "toProperty", Array.prototype.slice.apply(arguments));
        var streamSubscribe = disp.subscribe;
        return new Property(desc, streamSubscribeToPropertySubscribe(usedInitValue, streamSubscribe));
    };
    EventStream.prototype.transform = function (transformer, desc) {
        return transformE(this, transformer, desc);
    };
    /**
     Creates an EventStream/Property by sampling a given `samplee`
     stream/property value at each event from the this stream/property.
  
     @param {Observable<V2>} samplee
     @param f function to select/calculate the result value based on the value in the source stream and the samplee
  
     @typeparam V2  type of values in the samplee
     @typeparam R   type of values in the result
     */
    EventStream.prototype.withLatestFrom = function (samplee, f) {
        return withLatestFromE(this, samplee, f);
    };
    /**
     Lets you run a state machine
     on an observable. Give it an initial state object and a state
     transformation function that processes each incoming event and
     returns an array containing the next state and an array of output
     events. Here's an example where we calculate the total sum of all
     numbers in the stream and output the value on stream end:
  
     ```js
     Bacon.fromArray([1,2,3])
     .withStateMachine(0, function(sum, event) {
      if (event.hasValue)
        return [sum + event.value, []]
      else if (event.isEnd)
        return [undefined, [new Bacon.Next(sum), event]]
      else
        return [sum, [event]]
    })
     ```
     @param initState  initial state for the state machine
     @param f          the function that defines the state machine
     @typeparam  State   type of machine state
     @typeparam  Out     type of values to be emitted
     */
    EventStream.prototype.withStateMachine = function (initState, f) {
        return withStateMachine(initState, f, this);
    };
    return EventStream;
}(Observable));
/** @hidden */
function newEventStream(description, subscribe) {
    return new EventStream(description, subscribe);
}
/** @hidden */
function newEventStreamAllowSync(description, subscribe) {
    return new EventStream(description, subscribe, undefined, allowSync);
}

function symbol(key) {
    if (typeof Symbol !== "undefined" && Symbol[key]) {
        return Symbol[key];
    }
    else if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        return Symbol[key] = Symbol.for(key);
    }
    else {
        return "@@" + key;
    }
}

var ESObservable = /** @class */ (function () {
    function ESObservable(observable) {
        this.observable = observable;
    }
    ESObservable.prototype.subscribe = function (observerOrOnNext, onError, onComplete) {
        var observer = typeof observerOrOnNext === 'function'
            ? { next: observerOrOnNext, error: onError, complete: onComplete }
            : observerOrOnNext;
        var subscription = {
            closed: false,
            unsubscribe: function () {
                subscription.closed = true;
                cancel();
            }
        };
        var cancel = this.observable.subscribe(function (event) {
            if (hasValue(event) && observer.next) {
                observer.next(event.value);
            }
            else if (isError(event)) {
                if (observer.error)
                    observer.error(event.error);
                subscription.unsubscribe();
            }
            else if (event.isEnd) {
                subscription.closed = true;
                if (observer.complete)
                    observer.complete();
            }
        });
        return subscription;
    };
    return ESObservable;
}());
ESObservable.prototype[symbol('observable')] = function () {
    return this;
};
Observable.prototype.toESObservable = function () {
    return new ESObservable(this);
};
Observable.prototype[symbol('observable')] = Observable.prototype.toESObservable;

/**
 Creates a Property from an initial value and updates the value based on multiple inputs.
 The inputs are defined similarly to [`Bacon.when`](#bacon-when), like this:

 ```js
 var result = Bacon.update(
 initial,
 [x,y,z, (previous,x,y,z) => { ... }],
 [x,y,   (previous,x,y) => { ... }])
 ```

 As input, each function above will get the previous value of the `result` Property, along with values from the listed Observables.
 The value returned by the function will be used as the next value of `result`.

 Just like in [`Bacon.when`](#when), only EventStreams will trigger an update, while Properties will be just sampled.
 So, if you list a single EventStream and several Properties, the value will be updated only when an event occurs in the EventStream.

 Here's a simple gaming example:

 ```js
 let scoreMultiplier = Bacon.constant(1)
 let hitUfo = Bacon.interval(1000)
 let hitMotherShip = Bacon.later(10000)
 let score = Bacon.update(
 0,
 [hitUfo, scoreMultiplier, (score, _, multiplier) => score + 100 * multiplier ],
 [hitMotherShip, (score, _) => score + 2000 ]
 )
 ```

 In the example, the `score` property is updated when either `hitUfo` or `hitMotherShip` occur. The `scoreMultiplier` Property is sampled to take multiplier into account when `hitUfo` occurs.

 * @param initial
 * @param {UpdatePattern<Out>} patterns
 * @returns {Property<Out>}
 */
function update(initial) {
    var patterns = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        patterns[_i - 1] = arguments[_i];
    }
    var rawPatterns = extractRawPatterns(patterns);
    for (var i = 0; i < rawPatterns.length; i++) {
        var pattern = rawPatterns[i];
        pattern[1] = lateBindFirst(pattern[1]);
    }
    return when.apply(void 0, rawPatterns).scan(initial, (function (x, f) {
        return f(x);
    })).withDesc(new Desc("Bacon", "update", [initial].concat(patterns)));
}
function lateBindFirst(f) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return function (i) {
            return f.apply(void 0, [i].concat(args));
        };
    };
}

/**
 Creates an EventStream that delivers the given
 series of values (given as array) to the first subscriber. The stream ends after these
 values have been delivered. You can also send [`Bacon.Error`](classes/error.html) events, or
 any combination of pure values and error events like this:
 `Bacon.fromArray([1, new Bacon.Error()])

 @param   values    Array of values or events to repeat
 @typeparam V Type of stream elements
 */
function fromArray(values) {
    assertArray(values);
    if (!values.length) {
        return never().withDesc(new Desc("Bacon", "fromArray", values));
    }
    else {
        var i = 0;
        var stream = new EventStream(new Desc("Bacon", "fromArray", [values]), function (sink) {
            var unsubd = false;
            var reply = more;
            var pushing = false;
            var pushNeeded = false;
            function push() {
                pushNeeded = true;
                if (pushing) {
                    return;
                }
                if (i === values.length) {
                    sink(endEvent());
                    return false;
                }
                pushing = true;
                while (pushNeeded) {
                    pushNeeded = false;
                    if ((reply !== noMore) && !unsubd) {
                        var value = values[i++];
                        reply = sink(toEvent(value));
                        if (reply !== noMore) {
                            if (i === values.length) {
                                sink(endEvent());
                            }
                            else {
                                UpdateBarrier.afterTransaction(stream, push);
                            }
                        }
                    }
                }
                pushing = false;
                return pushing;
            }
            UpdateBarrier.soonButNotYet(stream, push);
            return function () {
                unsubd = true;
                return unsubd;
            };
        });
        return stream;
    }
}

function isEventSourceFn(x) {
    return _.isFunction(x);
}
// Wrap DOM EventTarget, Node EventEmitter, or
// [un]bind: (Any, (Any) -> None) -> None interfaces
// common in MVCs as EventStream
//
// target - EventTarget or EventEmitter, source of events
// eventSource - event name to bind or a function that performs custom binding
// eventTransformer - defaults to returning the first argument to handler
//
// Example 1:
//
//   Bacon.fromEventTarget(document.body, "click")
//   # => EventStream
//
//   Bacon.fromEventTarget(document.body, "scroll", {passive: true})
//   # => EventStream
//
//   Bacon.fromEventTarget (new EventEmitter(), "data")
//   # => EventStream
//
// Returns EventStream
/** @hidden */
var eventMethods = [
    ["addEventListener", "removeEventListener"],
    ["addListener", "removeListener"],
    ["on", "off"],
    ["bind", "unbind"]
];
var findHandlerMethods = function (target) {
    var pair;
    for (var i = 0; i < eventMethods.length; i++) {
        pair = eventMethods[i];
        var methodPair = [target[pair[0]], target[pair[1]]];
        if (methodPair[0] && methodPair[1]) {
            return methodPair;
        }
    }
    for (var j = 0; j < eventMethods.length; j++) {
        pair = eventMethods[j];
        var addListener = target[pair[0]];
        if (addListener) {
            return [addListener, function () { }];
        }
    }
    throw new Error("No suitable event methods in " + target);
};
/**
 creates an EventStream from events
 on a DOM EventTarget or Node.JS EventEmitter object, or an object that supports event listeners using `on`/`off` methods.
 You can also pass an optional function that transforms the emitted
 events' parameters.

 The simple form:

 ```js
 Bacon.fromEvent(document.body, "click").onValue(function() { alert("Bacon!") })
 ```

 Using a binder function:

 ```js
 Bacon.fromEvent(
 window,
 function(binder, listener) {
    binder("scroll", listener, {passive: true})
  }
 ).onValue(function() {
  console.log(window.scrollY)
})
 ```

 @param target
 @param eventSource
 @param eventTransformer
 @typeparam V Type of stream elements

 */
function fromEvent(target, eventSource, eventTransformer) {
    var _a = findHandlerMethods(target), sub = _a[0], unsub = _a[1];
    var desc = new Desc("Bacon", "fromEvent", [target, eventSource]);
    return fromBinder(function (handler) {
        if (isEventSourceFn(eventSource)) {
            eventSource(sub.bind(target), handler);
            return function () {
                return eventSource(unsub.bind(target), handler);
            };
        }
        else {
            sub.call(target, eventSource, handler);
            return function () {
                return unsub.call(target, eventSource, handler);
            };
        }
    }, eventTransformer).withDesc(desc);
}

/**
 A shorthand for combining multiple
 sources (streams, properties, constants) as array and assigning the
 side-effect function f for the values. The following example would log
 the number 3.

 ```js
 function f(a, b) { console.log(a + b) }
 Bacon.onValues(Bacon.constant(1), Bacon.constant(2), f)
 ```
 */
function onValues() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return combineAsArray(args.slice(0, args.length - 1)).onValues(args[arguments.length - 1]);
}

/**
 Calls generator function which is expected to return an observable. The returned EventStream contains
 values and errors from the spawned observable. When the spawned observable ends, the generator is called
 again to spawn a new observable.

 This is repeated until the generator returns a falsy value
 (such as `undefined` or `false`).

 The generator function is called with one argument — iteration number starting from `0`.

 Here's an example:

```js
Bacon.repeat(function(i) {
if (i < 3) {
  return Bacon.once(i);
} else {
  return false;
}
}).log()
```

 The example will produce values 0, 1 and 2.

 @param {(number) => (Observable<V> | null)} generator
 @returns {EventStream<V>}
 @typeparam V Type of stream elements

 */
function repeat(generator) {
    var index = 0;
    return fromBinder(function (sink) {
        var flag = false;
        var reply = more;
        var unsub = function () { };
        function handleEvent(event) {
            if (event.isEnd) {
                if (!flag) {
                    flag = true;
                }
                else {
                    subscribeNext();
                }
                return more;
            }
            else {
                return reply = sink(event);
            }
        }
        function subscribeNext() {
            var next;
            flag = true;
            while (flag && reply !== noMore) {
                next = generator(index++);
                flag = false;
                if (next) {
                    unsub = next.subscribeInternal(handleEvent);
                }
                else {
                    sink(endEvent());
                }
            }
            flag = true;
        }
        subscribeNext();
        return function () { return unsub(); };
    }).withDesc(new Desc("Bacon", "repeat", [generator]));
}

/**
 Repeats given elements indefinitely
 with given interval in milliseconds. For example, `repeatedly(10, [1,2,3])`
 would lead to `1,2,3,1,2,3...` to be repeated indefinitely.

 @param delay between values, in milliseconds
 @param values array of values to repeat
 @typeparam V Type of stream elements

 */
function repeatedly(delay, values) {
    var index = 0;
    return fromPoll(delay, function () {
        return values[index++ % values.length];
    }).withDesc(new Desc("Bacon", "repeatedly", [delay, values]));
}

/**
 Creates a stream that ends after given amount of milliseconds, without emitting any values.

 @param duration duration of silence in milliseconds
 @typeparam V Type of stream elements
 */
function silence(duration) {
    return later(duration, "")
        .filter(false)
        .withDesc(new Desc("Bacon", "silence", [duration]));
}

/**
 Used to retry the call when there is an [`Error`](classes/error.html) event in the stream produced by the `source` function.

 ```js
 var triggeringStream, ajaxCall // <- ajaxCall gives Errors on network or server errors
 ajaxResult = triggeringStream.flatMap(function(url) {
    return Bacon.retry({
        source: function(attemptNumber) { return ajaxCall(url) },
        retries: 5,
        isRetryable: function (error) { return error.httpStatusCode !== 404; },
        delay: function(context) { return 100; } // Just use the same delay always
    })
})
 ```
 * @param options (click for details)
 */
function retry(options) {
    if (!_.isFunction(options.source)) {
        throw new Error("'source' option has to be a function");
    }
    var source = options.source;
    var retries = options.retries || 0;
    var retriesDone = 0;
    var delay = options.delay || function () {
        return 0;
    };
    var isRetryable = options.isRetryable || function () {
        return true;
    };
    var finished = false;
    var errorEvent = null;
    return repeat(function (count) {
        function valueStream() {
            return source(count).endOnError().transform(function (event, sink) {
                if (isError(event)) {
                    errorEvent = event;
                    if (!(isRetryable(errorEvent.error) && (retries === 0 || retriesDone < retries))) {
                        finished = true;
                        return sink(event);
                    }
                    else {
                        return more;
                    }
                }
                else {
                    if (hasValue(event)) {
                        errorEvent = null;
                        finished = true;
                    }
                    return sink(event);
                }
            });
        }
        if (finished) {
            return undefined;
        }
        else if (errorEvent) {
            var context = {
                error: errorEvent.error,
                retriesDone: retriesDone
            };
            var pause = silence(delay(context));
            retriesDone++;
            return pause.concat(once(null).flatMap(valueStream));
        }
        else {
            return valueStream();
        }
    }).withDesc(new Desc("Bacon", "retry", [options]));
}

/**
 Creates a stream containing given
 values (given as array). Delivered with given interval in milliseconds.

 @param delay between elements, in milliseconds
 @param array of values or events
 @typeparam V Type of stream elements

 */
function sequentially(delay, values) {
    var index = 0;
    return fromPoll(delay, function () {
        var value = values[index++];
        if (index < values.length) {
            return value;
        }
        else if (index === values.length) {
            return [toEvent(value), endEvent()];
        }
        else {
            return endEvent();
        }
    }).withDesc(new Desc("Bacon", "sequentially", [delay, values]));
}

function valueAndEnd(value) {
    return [toEvent(value), endEvent()];
}
/**
 * Creates an EventStream from a Promise object such as JQuery Ajax.
 This stream will contain a single value or an error, followed immediately by stream end.
 You can use the optional abort flag (i.e. ´fromPromise(p, true)´ to have the `abort` method of the given promise be called when all subscribers have been removed from the created stream.
 You can also pass an optional function that transforms the promise value into Events. The default is to transform the value into `[new Bacon.Next(value), new Bacon.End()]`.
 Check out this [example](https://github.com/raimohanska/baconjs-examples/blob/master/resources/public/index.html).

 *
 * @param {Promise<V>} source promise object
 * @param abort should we call the `abort` method of the Promise on unsubscribe. This is a nonstandard feature you should probably ignore.
 * @param {EventTransformer<V>} eventTransformer
 * @returns {EventStream<V>}
 */
function fromPromise(promise, abort, eventTransformer) {
    if (eventTransformer === void 0) { eventTransformer = valueAndEnd; }
    return fromBinder(function (handler) {
        var bound = promise.then(handler, function (e) { return handler(new Error$1(e)); });
        if (bound && typeof bound.done === "function") {
            bound.done();
        }
        if (abort) {
            return function () {
                if (typeof promise.abort === "function") {
                    return promise.abort();
                }
            };
        }
        else {
            return function () {
            };
        }
    }, eventTransformer).withDesc(new Desc("Bacon", "fromPromise", [promise]));
}

function withMethodCallSupport(wrapped) {
    return function (f) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (typeof f === "object" && args.length) {
            var context = f;
            var methodName = args[0];
            f = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return context[methodName].apply(context, args);
            };
            args = args.slice(1);
        }
        return wrapped.apply(void 0, [f].concat(args));
    };
}
function partiallyApplied(f, applied) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return f.apply(void 0, (applied.concat(args)));
    };
}
var makeFunction_ = withMethodCallSupport(function (f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (_.isFunction(f)) {
        if (args.length) {
            return partiallyApplied(f, args);
        }
        else {
            return f;
        }
    }
    else {
        return _.always(f);
    }
});
/** @hidden */
function makeFunction(f, args) {
    return makeFunction_.apply(void 0, [f].concat(args));
}

// TODO: types/doc for the object, fnname variant
/**
 Creates an EventStream from a function that
 accepts a callback. The function is supposed to call its callback just
 once. For example:

 ```js
 Bacon.fromCallback(callback => callback("bacon"))
 ```

 This would create a stream that outputs a single value "Bacon!" and ends
 after that. The use of setTimeout causes the value to be delayed by 1
 second.

 You can also give any number of arguments to [`fromCallback`](#bacon-fromcallback), which will be
 passed to the function. These arguments can be simple variables, Bacon
 EventStreams or Properties. For example the following will output "Bacon rules":

 ```js
 bacon = Bacon.constant('bacon')
 Bacon.fromCallback(function(a, b, callback) {
  callback(a + ' ' + b);
}, bacon, 'rules').log();
 ```

 * @param f
 * @param args
 * @returns {EventStream<V>}
 */
function fromCallback(f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return fromBinder(function (handler) {
        makeFunction(f, args)(handler);
        return nop;
    }, function (value) {
        return [value, endEvent()];
    }).withDesc(new Desc("Bacon", "fromCallback", [f].concat(args)));
}
/**
Behaves the same way as `Bacon.fromCallback`,
except that it expects the callback to be called in the Node.js convention:
`callback(error, data)`, where error is null if everything is fine. For example:

```js
var Bacon = require('baconjs').Bacon,
fs = require('fs');
var read = Bacon.fromNodeCallback(fs.readFile, 'input.txt');
read.onError(function(error) { console.log("Reading failed: " + error); });
read.onValue(function(value) { console.log("Read contents: " + value); });
```

 */
function fromNodeCallback(f) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return fromBinder(function (handler) {
        makeFunction(f, args)(handler);
        return nop;
    }, function (error, value) {
        if (error) {
            return [new Error$1(error), endEvent()];
        }
        return [value, endEvent()];
    }).withDesc(new Desc("Bacon", "fromNodeCallback", [f].concat(args)));
}

/**
 * Creates an EventStream from an
 [ES Observable](https://github.com/tc39/proposal-observable). Input can be any
 ES Observable implementation including RxJS and Kefir.
 */
function fromESObservable(_observable) {
    var observable;
    if (_observable[symbol("observable")]) {
        observable = _observable[symbol("observable")]();
    }
    else {
        observable = _observable;
    }
    var desc = new Desc("Bacon", "fromESObservable", [observable]);
    return new EventStream(desc, function (sink) {
        var cancel = observable.subscribe({
            error: function (x) {
                sink(new Error$1(x));
                sink(new End());
            },
            next: function (value) { sink(new Next(value)); },
            complete: function () {
                sink(new End());
            }
        });
        // Support RxJS Observables
        if (cancel.unsubscribe) {
            return function () { cancel.unsubscribe(); };
        }
        else {
            return cancel;
        }
    });
}

/**
 An [`EventStream`](eventstream.html) that allows you to [`push`](#push) values into the stream.

 It also allows plugging other streams into the Bus, as inputs. The Bus practically
 merges all plugged-in streams and the values pushed using the [`push`](#push)
 method.
 */
var Bus = /** @class */ (function (_super) {
    __extends(Bus, _super);
    function Bus() {
        var _this = _super.call(this, new Desc("Bacon", "Bus", []), function (sink) { return _this.subscribeAll(sink); }) || this;
        /** @hidden */
        _this.pushing = false;
        /** @hidden */
        _this.pushQueue = undefined;
        /** @hidden */
        _this.ended = false;
        /** @hidden */
        _this.subscriptions = [];
        _this.unsubAll = _.bind(_this.unsubAll, _this);
        _this.subscriptions = []; // new array for each Bus instance
        _this.ended = false;
        return _this;
    }
    /**
     Plugs the given stream as an input to the Bus. All events from
     the given stream will be delivered to the subscribers of the Bus.
     Returns a function that can be used to unplug the same stream.
  
     The plug method practically allows you to merge in other streams after
     the creation of the Bus.
  
     * @returns a function that can be called to "unplug" the source from Bus.
     */
    Bus.prototype.plug = function (input) {
        var _this = this;
        assertObservable(input);
        if (this.ended) {
            return;
        }
        var sub = { input: input, unsub: undefined };
        this.subscriptions.push(sub);
        if (typeof this.sink !== "undefined") {
            this.subscribeInput(sub);
        }
        return (function () { return _this.unsubscribeInput(input); });
    };
    /**
     Ends the stream. Sends an [End](end.html) event to all subscribers.
     After this call, there'll be no more events to the subscribers.
     Also, the [`push`](#push), [`error`](#error) and [`plug`](#plug) methods have no effect.
     */
    Bus.prototype.end = function () {
        this.ended = true;
        this.unsubAll();
        if (typeof this.sink === "function") {
            return this.sink(endEvent());
        }
    };
    /**
     * Pushes a new value to the stream.
     */
    Bus.prototype.push = function (value) {
        if (!this.ended && typeof this.sink === "function") {
            var rootPush = !this.pushing;
            if (!rootPush) {
                //console.log("recursive push")
                if (!this.pushQueue)
                    this.pushQueue = [];
                this.pushQueue.push(value);
                //console.log('queued', value)
                return;
            }
            this.pushing = true;
            try {
                return this.sink(nextEvent(value));
            }
            finally {
                if (rootPush && this.pushQueue) {
                    //console.log("start processing queue", this.pushQueue.length)
                    var i = 0;
                    while (i < this.pushQueue.length) {
                        //console.log("in loop", i, this.pushQueue[i])
                        var v = this.pushQueue[i];
                        this.sink(nextEvent(v));
                        i++;
                    }
                    this.pushQueue = undefined;
                }
                this.pushing = false;
            }
        }
    };
    /**
     * Pushes an error to this stream.
     */
    Bus.prototype.error = function (error) {
        if (typeof this.sink === "function") {
            return this.sink(new Error$1(error));
        }
    };
    /** @hidden */
    Bus.prototype.unsubAll = function () {
        var iterable = this.subscriptions;
        for (var i = 0, sub; i < iterable.length; i++) {
            sub = iterable[i];
            if (typeof sub.unsub === "function") {
                sub.unsub();
            }
        }
    };
    /** @hidden */
    Bus.prototype.subscribeAll = function (newSink) {
        if (this.ended) {
            newSink(endEvent());
        }
        else {
            this.sink = newSink;
            var iterable = this.subscriptions.slice();
            for (var i = 0, subscription; i < iterable.length; i++) {
                subscription = iterable[i];
                this.subscribeInput(subscription);
            }
        }
        return this.unsubAll;
    };
    /** @hidden */
    Bus.prototype.guardedSink = function (input) {
        var _this = this;
        return function (event) {
            if (event.isEnd) {
                _this.unsubscribeInput(input);
                return noMore;
            }
            else if (_this.sink) {
                return _this.sink(event);
            }
            else {
                return more;
            }
        };
    };
    /** @hidden */
    Bus.prototype.subscribeInput = function (subscription) {
        subscription.unsub = subscription.input.subscribeInternal(this.guardedSink(subscription.input));
        return subscription.unsub;
    };
    /** @hidden */
    Bus.prototype.unsubscribeInput = function (input) {
        var iterable = this.subscriptions;
        for (var i = 0, sub; i < iterable.length; i++) {
            sub = iterable[i];
            if (sub.input === input) {
                if (typeof sub.unsub === "function") {
                    sub.unsub();
                }
                this.subscriptions.splice(i, 1);
                return;
            }
        }
    };
    return Bus;
}(EventStream));

/** @hidden */
function tryF(f) {
    return function (value) {
        try {
            return once(f(value));
        }
        catch (e) {
            return once(new Error$1(e));
        }
    };
}

/**
 * JQuery/Zepto integration support
 */
var $ = {
    /**
     Creates an EventStream from events on a
     jQuery or Zepto.js object. You can pass optional arguments to add a
     jQuery live selector and/or a function that processes the jQuery
     event and its parameters, if given, like this:
  
     ```js
     $("#my-div").asEventStream("click", ".more-specific-selector")
     $("#my-div").asEventStream("click", ".more-specific-selector", function(event, args) { return args[0] })
     $("#my-div").asEventStream("click", function(event, args) { return args[0] })
     ```
  
     Note: you need to install the `asEventStream` method on JQuery by calling
     [init()](#_.aseventstream) as in `Bacon.$.init($)`.
     */
    asEventStream: function (eventName, selector, eventTransformer) {
        var _this = this;
        if (_.isFunction(selector)) {
            eventTransformer = selector;
            selector = undefined;
        }
        return fromBinder(function (handler) {
            _this.on(eventName, selector, handler);
            return (function () { return _this.off(eventName, selector, handler); });
        }, eventTransformer).withDesc(new Desc(this.selector || this, "asEventStream", [eventName]));
    },
    /**
     * Installs the [asEventStream](#_.aseventstream) to the given jQuery/Zepto object (the `$` object).
     */
    init: function (jQuery) {
        jQuery.fn.asEventStream = $.asEventStream;
    }
};

/**
 *  Bacon.js version as string
 */
var version = '3.0.12';

exports.$ = $;
exports.Bus = Bus;
exports.CompositeUnsubscribe = CompositeUnsubscribe;
exports.Desc = Desc;
exports.End = End;
exports.Error = Error$1;
exports.Event = Event;
exports.EventStream = EventStream;
exports.Initial = Initial;
exports.Next = Next;
exports.Observable = Observable;
exports.Property = Property;
exports.Value = Value;
exports._ = _;
exports.combine = combine;
exports.combineAsArray = combineAsArray;
exports.combineTemplate = combineTemplate;
exports.combineWith = combineWith;
exports.concatAll = concatAll;
exports.constant = constant;
exports.fromArray = fromArray;
exports.fromBinder = fromBinder;
exports.fromCallback = fromCallback;
exports.fromESObservable = fromESObservable;
exports.fromEvent = fromEvent;
exports.fromEventTarget = fromEvent;
exports.fromNodeCallback = fromNodeCallback;
exports.fromPoll = fromPoll;
exports.fromPromise = fromPromise;
exports.getScheduler = getScheduler;
exports.groupSimultaneous = groupSimultaneous;
exports.hasValue = hasValue;
exports.interval = interval;
exports.isEnd = isEnd;
exports.isError = isError;
exports.isEvent = isEvent;
exports.isInitial = isInitial;
exports.isNext = isNext;
exports.later = later;
exports.mergeAll = mergeAll;
exports.more = more;
exports.never = never;
exports.noMore = noMore;
exports.nullSink = nullSink;
exports.nullVoidSink = nullVoidSink;
exports.onValues = onValues;
exports.once = once;
exports.repeat = repeat;
exports.repeatedly = repeatedly;
exports.retry = retry;
exports.sequentially = sequentially;
exports.setScheduler = setScheduler;
exports.silence = silence;
exports.spy = spy;
exports.try = tryF;
exports.update = update;
exports.version = version;
exports.when = when;
exports.zipAsArray = zipAsArray;
exports.zipWith = zipWith;

Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),

/***/ "./node_modules/immutable/dist/immutable.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/immutable/dist/immutable.es.js ***!
  \*****************************************************/
/*! exports provided: default, version, Collection, Iterable, Seq, Map, OrderedMap, List, Stack, Set, OrderedSet, Record, Range, Repeat, is, fromJS, hash, isImmutable, isCollection, isKeyed, isIndexed, isAssociative, isOrdered, isValueObject, get, getIn, has, hasIn, merge, mergeDeep, mergeWith, mergeDeepWith, remove, removeIn, set, setIn, update, updateIn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Collection", function() { return Collection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Iterable", function() { return Iterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Seq", function() { return Seq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Map", function() { return Map; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderedMap", function() { return OrderedMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "List", function() { return List; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Stack", function() { return Stack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Set", function() { return Set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrderedSet", function() { return OrderedSet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Record", function() { return Record; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Range", function() { return Range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Repeat", function() { return Repeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "is", function() { return is; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromJS", function() { return fromJS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hash", function() { return hash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImmutable", function() { return isImmutable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCollection", function() { return isCollection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isKeyed", function() { return isKeyed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIndexed", function() { return isIndexed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAssociative", function() { return isAssociative; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOrdered", function() { return isOrdered; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValueObject", function() { return isValueObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIn", function() { return getIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "has", function() { return has; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasIn", function() { return hasIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeDeep", function() { return mergeDeep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeWith", function() { return mergeWith$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeDeepWith", function() { return mergeDeepWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "remove", function() { return remove; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeIn", function() { return removeIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setIn", function() { return setIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "update", function() { return update; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateIn", function() { return updateIn; });
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Used for setting prototype methods that IE8 chokes on.
var DELETE = 'delete';

// Constants describing the size of trie nodes.
var SHIFT = 5; // Resulted in best performance after ______?
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;

// A consistent shared value representing "not set" which equals nothing other
// than itself, and nothing that could be provided externally.
var NOT_SET = {};

// Boolean references, Rough equivalent of `bool &`.
function MakeRef() {
  return { value: false };
}

function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}

// A function which returns a value representing an "owner" for transient writes
// to tries. The return value will only ever equal itself, and will not equal
// the return of any subsequent call of this function.
function OwnerID() {}

function ensureSize(iter) {
  if (iter.size === undefined) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}

function wrapIndex(iter, index) {
  // This implements "is array index" which the ECMAString spec defines as:
  //
  //     A String property name P is an array index if and only if
  //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
  //     to 2^32−1.
  //
  // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
  if (typeof index !== 'number') {
    var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
    if ('' + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}

function returnTrue() {
  return true;
}

function wholeSlice(begin, end, size) {
  return (
    ((begin === 0 && !isNeg(begin)) ||
      (size !== undefined && begin <= -size)) &&
    (end === undefined || (size !== undefined && end >= size))
  );
}

function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}

function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}

function resolveIndex(index, size, defaultIndex) {
  // Sanitize indices using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  return index === undefined
    ? defaultIndex
    : isNeg(index)
      ? size === Infinity
        ? size
        : Math.max(0, size + index) | 0
      : size === undefined || size === index
        ? index
        : Math.min(size, index) | 0;
}

function isNeg(value) {
  // Account for -0 which is negative, but not less than 0.
  return value < 0 || (value === 0 && 1 / value === -Infinity);
}

// Note: value is unchanged to not break immutable-devtools.
var IS_COLLECTION_SYMBOL = '@@__IMMUTABLE_ITERABLE__@@';

function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}

var IS_KEYED_SYMBOL = '@@__IMMUTABLE_KEYED__@@';

function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}

var IS_INDEXED_SYMBOL = '@@__IMMUTABLE_INDEXED__@@';

function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}

function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}

var Collection = function Collection(value) {
  return isCollection(value) ? value : Seq(value);
};

var KeyedCollection = /*@__PURE__*/(function (Collection) {
  function KeyedCollection(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }

  if ( Collection ) KeyedCollection.__proto__ = Collection;
  KeyedCollection.prototype = Object.create( Collection && Collection.prototype );
  KeyedCollection.prototype.constructor = KeyedCollection;

  return KeyedCollection;
}(Collection));

var IndexedCollection = /*@__PURE__*/(function (Collection) {
  function IndexedCollection(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }

  if ( Collection ) IndexedCollection.__proto__ = Collection;
  IndexedCollection.prototype = Object.create( Collection && Collection.prototype );
  IndexedCollection.prototype.constructor = IndexedCollection;

  return IndexedCollection;
}(Collection));

var SetCollection = /*@__PURE__*/(function (Collection) {
  function SetCollection(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }

  if ( Collection ) SetCollection.__proto__ = Collection;
  SetCollection.prototype = Object.create( Collection && Collection.prototype );
  SetCollection.prototype.constructor = SetCollection;

  return SetCollection;
}(Collection));

Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;

var IS_SEQ_SYMBOL = '@@__IMMUTABLE_SEQ__@@';

function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}

var IS_RECORD_SYMBOL = '@@__IMMUTABLE_RECORD__@@';

function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}

function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}

var IS_ORDERED_SYMBOL = '@@__IMMUTABLE_ORDERED__@@';

function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}

var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;

var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;

var Iterator = function Iterator(next) {
  this.next = next;
};

Iterator.prototype.toString = function toString () {
  return '[Iterator]';
};

Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;

Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
  return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};

function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult
    ? (iteratorResult.value = value)
    : (iteratorResult = {
        value: value,
        done: false,
      });
  return iteratorResult;
}

function iteratorDone() {
  return { value: undefined, done: true };
}

function hasIterator(maybeIterable) {
  return !!getIteratorFn(maybeIterable);
}

function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === 'function';
}

function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}

function getIteratorFn(iterable) {
  var iteratorFn =
    iterable &&
    ((REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
      iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === 'string') {
    return true;
  }

  return (
    value &&
    typeof value === 'object' &&
    Number.isInteger(value.length) &&
    value.length >= 0 &&
    (value.length === 0
      ? // Only {length: 0} is considered Array-like.
        Object.keys(value).length === 1
      : // An object is only Array-like if it has a property where the last value
        // in the array-like may be found (which could be undefined).
        value.hasOwnProperty(value.length - 1))
  );
}

var Seq = /*@__PURE__*/(function (Collection$$1) {
  function Seq(value) {
    return value === null || value === undefined
      ? emptySequence()
      : isImmutable(value)
        ? value.toSeq()
        : seqFromValue(value);
  }

  if ( Collection$$1 ) Seq.__proto__ = Collection$$1;
  Seq.prototype = Object.create( Collection$$1 && Collection$$1.prototype );
  Seq.prototype.constructor = Seq;

  Seq.prototype.toSeq = function toSeq () {
    return this;
  };

  Seq.prototype.toString = function toString () {
    return this.__toString('Seq {', '}');
  };

  Seq.prototype.cacheResult = function cacheResult () {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };

  // abstract __iterateUncached(fn, reverse)

  Seq.prototype.__iterate = function __iterate (fn, reverse) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      while (i !== size) {
        var entry = cache[reverse ? size - ++i : i++];
        if (fn(entry[1], entry[0], this) === false) {
          break;
        }
      }
      return i;
    }
    return this.__iterateUncached(fn, reverse);
  };

  // abstract __iteratorUncached(type, reverse)

  Seq.prototype.__iterator = function __iterator (type, reverse) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      return new Iterator(function () {
        if (i === size) {
          return iteratorDone();
        }
        var entry = cache[reverse ? size - ++i : i++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse);
  };

  return Seq;
}(Collection));

var KeyedSeq = /*@__PURE__*/(function (Seq) {
  function KeyedSeq(value) {
    return value === null || value === undefined
      ? emptySequence().toKeyedSeq()
      : isCollection(value)
        ? isKeyed(value)
          ? value.toSeq()
          : value.fromEntrySeq()
        : isRecord(value)
          ? value.toSeq()
          : keyedSeqFromValue(value);
  }

  if ( Seq ) KeyedSeq.__proto__ = Seq;
  KeyedSeq.prototype = Object.create( Seq && Seq.prototype );
  KeyedSeq.prototype.constructor = KeyedSeq;

  KeyedSeq.prototype.toKeyedSeq = function toKeyedSeq () {
    return this;
  };

  return KeyedSeq;
}(Seq));

var IndexedSeq = /*@__PURE__*/(function (Seq) {
  function IndexedSeq(value) {
    return value === null || value === undefined
      ? emptySequence()
      : isCollection(value)
        ? isKeyed(value)
          ? value.entrySeq()
          : value.toIndexedSeq()
        : isRecord(value)
          ? value.toSeq().entrySeq()
          : indexedSeqFromValue(value);
  }

  if ( Seq ) IndexedSeq.__proto__ = Seq;
  IndexedSeq.prototype = Object.create( Seq && Seq.prototype );
  IndexedSeq.prototype.constructor = IndexedSeq;

  IndexedSeq.of = function of (/*...values*/) {
    return IndexedSeq(arguments);
  };

  IndexedSeq.prototype.toIndexedSeq = function toIndexedSeq () {
    return this;
  };

  IndexedSeq.prototype.toString = function toString () {
    return this.__toString('Seq [', ']');
  };

  return IndexedSeq;
}(Seq));

var SetSeq = /*@__PURE__*/(function (Seq) {
  function SetSeq(value) {
    return (isCollection(value) && !isAssociative(value)
      ? value
      : IndexedSeq(value)
    ).toSetSeq();
  }

  if ( Seq ) SetSeq.__proto__ = Seq;
  SetSeq.prototype = Object.create( Seq && Seq.prototype );
  SetSeq.prototype.constructor = SetSeq;

  SetSeq.of = function of (/*...values*/) {
    return SetSeq(arguments);
  };

  SetSeq.prototype.toSetSeq = function toSetSeq () {
    return this;
  };

  return SetSeq;
}(Seq));

Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;

Seq.prototype[IS_SEQ_SYMBOL] = true;

// #pragma Root Sequences

var ArraySeq = /*@__PURE__*/(function (IndexedSeq) {
  function ArraySeq(array) {
    this._array = array;
    this.size = array.length;
  }

  if ( IndexedSeq ) ArraySeq.__proto__ = IndexedSeq;
  ArraySeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  ArraySeq.prototype.constructor = ArraySeq;

  ArraySeq.prototype.get = function get (index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };

  ArraySeq.prototype.__iterate = function __iterate (fn, reverse) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    while (i !== size) {
      var ii = reverse ? size - ++i : i++;
      if (fn(array[ii], ii, this) === false) {
        break;
      }
    }
    return i;
  };

  ArraySeq.prototype.__iterator = function __iterator (type, reverse) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var ii = reverse ? size - ++i : i++;
      return iteratorValue(type, ii, array[ii]);
    });
  };

  return ArraySeq;
}(IndexedSeq));

var ObjectSeq = /*@__PURE__*/(function (KeyedSeq) {
  function ObjectSeq(object) {
    var keys = Object.keys(object);
    this._object = object;
    this._keys = keys;
    this.size = keys.length;
  }

  if ( KeyedSeq ) ObjectSeq.__proto__ = KeyedSeq;
  ObjectSeq.prototype = Object.create( KeyedSeq && KeyedSeq.prototype );
  ObjectSeq.prototype.constructor = ObjectSeq;

  ObjectSeq.prototype.get = function get (key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  };

  ObjectSeq.prototype.has = function has (key) {
    return hasOwnProperty.call(this._object, key);
  };

  ObjectSeq.prototype.__iterate = function __iterate (fn, reverse) {
    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;
    while (i !== size) {
      var key = keys[reverse ? size - ++i : i++];
      if (fn(object[key], key, this) === false) {
        break;
      }
    }
    return i;
  };

  ObjectSeq.prototype.__iterator = function __iterator (type, reverse) {
    var object = this._object;
    var keys = this._keys;
    var size = keys.length;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var key = keys[reverse ? size - ++i : i++];
      return iteratorValue(type, key, object[key]);
    });
  };

  return ObjectSeq;
}(KeyedSeq));
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;

var CollectionSeq = /*@__PURE__*/(function (IndexedSeq) {
  function CollectionSeq(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }

  if ( IndexedSeq ) CollectionSeq.__proto__ = IndexedSeq;
  CollectionSeq.prototype = Object.create( IndexedSeq && IndexedSeq.prototype );
  CollectionSeq.prototype.constructor = CollectionSeq;

  CollectionSeq.prototype.__iterateUncached = function __iterateUncached (fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  };

  CollectionSeq.prototype.__iteratorUncached = function __iteratorUncached (type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function () {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };

  return CollectionSeq;
}(IndexedSeq));

// # pragma Helper functions

var EMPTY_SEQ;

function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}

function keyedSeqFromValue(value) {
  var seq = Array.isArray(value)
    ? new ArraySeq(value)
    : hasIterator(value)
      ? new CollectionSeq(value)
      : undefined;
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    'Expected Array or collection object of [k, v] entries, or keyed object: ' +
      value
  );
}

function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    'Expected Array or collection object of values: ' + value
  );
}

function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  if (typeof value === 'object') {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    'Expected Array or collection object of values, or keyed object: ' + value
  );
}

function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value)
    ? new ArraySeq(value)
    : hasIterator(value)
      ? new CollectionSeq(value)
      : undefined;
}

var IS_MAP_SYMBOL = '@@__IMMUTABLE_MAP__@@';

function isMap(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}

function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}

function isValueObject(maybeValue) {
  return Boolean(
    maybeValue &&
      typeof maybeValue.equals === 'function' &&
      typeof maybeValue.hashCode === 'function'
  );
}

/**
 * An extension of the "same-value" algorithm as [described for use by ES6 Map
 * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
 *
 * NaN is considered the same as NaN, however -0 and 0 are considered the same
 * value, which is different from the algorithm described by
 * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
 *
 * This is extended further to allow Objects to describe the values they
 * represent, by way of `valueOf` or `equals` (and `hashCode`).
 *
 * Note: because of this extension, the key equality of Immutable.Map and the
 * value equality of Immutable.Set will differ from ES6 Map and Set.
 *
 * ### Defining custom values
 *
 * The easiest way to describe the value an object represents is by implementing
 * `valueOf`. For example, `Date` represents a value by returning a unix
 * timestamp for `valueOf`:
 *
 *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
 *     var date2 = new Date(1234567890000);
 *     date1.valueOf(); // 1234567890000
 *     assert( date1 !== date2 );
 *     assert( Immutable.is( date1, date2 ) );
 *
 * Note: overriding `valueOf` may have other implications if you use this object
 * where JavaScript expects a primitive, such as implicit string coercion.
 *
 * For more complex types, especially collections, implementing `valueOf` may
 * not be performant. An alternative is to implement `equals` and `hashCode`.
 *
 * `equals` takes another object, presumably of similar type, and returns true
 * if it is equal. Equality is symmetrical, so the same result should be
 * returned if this and the argument are flipped.
 *
 *     assert( a.equals(b) === b.equals(a) );
 *
 * `hashCode` returns a 32bit integer number representing the object which will
 * be used to determine how to store the value object in a Map or Set. You must
 * provide both or neither methods, one must not exist without the other.
 *
 * Also, an important relationship between these methods must be upheld: if two
 * values are equal, they *must* return the same hashCode. If the values are not
 * equal, they might have the same hashCode; this is called a hash collision,
 * and while undesirable for performance reasons, it is acceptable.
 *
 *     if (a.equals(b)) {
 *       assert( a.hashCode() === b.hashCode() );
 *     }
 *
 * All Immutable collections are Value Objects: they implement `equals()`
 * and `hashCode()`.
 */
function is(valueA, valueB) {
  if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (
    typeof valueA.valueOf === 'function' &&
    typeof valueB.valueOf === 'function'
  ) {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(
    isValueObject(valueA) &&
    isValueObject(valueB) &&
    valueA.equals(valueB)
  );
}

var imul =
  typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2
    ? Math.imul
    : function imul(a, b) {
        a |= 0; // int
        b |= 0; // int
        var c = a & 0xffff;
        var d = b & 0xffff;
        // Shift by 0 fixes the sign on the high part.
        return (c * d + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0)) | 0; // int
      };

// v8 has an optimization for storing 31-bit signed numbers.
// Values which have either 00 or 11 as the high order bits qualify.
// This function drops the highest order bit in a signed number, maintaining
// the sign bit.
function smi(i32) {
  return ((i32 >>> 1) & 0x40000000) | (i32 & 0xbfffffff);
}

var defaultValueOf = Object.prototype.valueOf;

function hash(o) {
  switch (typeof o) {
    case 'boolean':
      // The hash values for built-in constants are a 1 value for each 5-byte
      // shift region expect for the first, which encodes the value. This
      // reduces the odds of a hash collision for these common values.
      return o ? 0x42108421 : 0x42108420;
    case 'number':
      return hashNumber(o);
    case 'string':
      return o.length > STRING_HASH_CACHE_MIN_STRLEN
        ? cachedHashString(o)
        : hashString(o);
    case 'object':
    case 'function':
      if (o === null) {
        return 0x42108422;
      }
      if (typeof o.hashCode === 'function') {
        // Drop any high bits from accidentally long hash codes.
        return smi(o.hashCode(o));
      }
      if (o.valueOf !== defaultValueOf && typeof o.valueOf === 'function') {
        o = o.valueOf(o);
      }
      return hashJSObj(o);
    case 'undefined':
      return 0x42108423;
    default:
      if (typeof o.toString === 'function') {
        return hashString(o.toString());
      }
      throw new Error('Value type ' + typeof o + ' cannot be hashed.');
  }
}

// Compress arbitrarily large numbers into smi hashes.
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  var hash = n | 0;
  if (hash !== n) {
    hash ^= n * 0xffffffff;
  }
  while (n > 0xffffffff) {
    n /= 0xffffffff;
    hash ^= n;
  }
  return smi(hash);
}

function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === undefined) {
    hashed = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}

// http://jsperf.com/hashing-strings
function hashString(string) {
  // This is the hash from JVM
  // The hash code for a string is computed as
  // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
  // where s[i] is the ith character of the string and n is the length of
  // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
  // (exclusive) by dropping high bits.
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = (31 * hashed + string.charCodeAt(ii)) | 0;
  }
  return smi(hashed);
}

function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== undefined) {
      return hashed;
    }
  }

  hashed = obj[UID_HASH_KEY];
  if (hashed !== undefined) {
    return hashed;
  }

  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== undefined) {
      return hashed;
    }

    hashed = getIENodeHash(obj);
    if (hashed !== undefined) {
      return hashed;
    }
  }

  hashed = ++objHashUID;
  if (objHashUID & 0x40000000) {
    objHashUID = 0;
  }

  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== undefined && isExtensible(obj) === false) {
    throw new Error('Non-extensible objects are not allowed as keys.');
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed,
    });
  } else if (
    obj.propertyIsEnumerable !== undefined &&
    obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable
  ) {
    // Since we can't define a non-enumerable property on the object
    // we'll hijack one of the less-used non-enumerable properties to
    // save our hash on it. Since this is a function it will not show up in
    // `JSON.stringify` which is what we want.
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== undefined) {
    // At this point we couldn't get the IE `uniqueID` to use as a hash
    // and we couldn't use a non-enumerable property to exploit the
    // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
    // itself.
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error('Unable to set a non-enumerable property on object.');
  }

  return hashed;
}

// Get references to ES5 object methods.
var isExtensible = Object.isExtensible;

// True if Object.defineProperty works as expected. IE8 fails this test.
var canDefineProperty = (function() {
  try {
    Object.defineProperty({}, '@', {});
    return true;
  } catch (e) {
    return false;
  }
})();

// IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
// and avoid memory leaks from the IE cloneNode bug.
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1: // Element
        return node.uniqueID;
      case 9: // Document
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}

// If possible, use a WeakMap.
var usingWeakMap = typeof WeakMap === 'function';
var weakMap;
if (usingWeakMap) {
  weakMap = new WeakMap();
}

var objHashUID = 0;

var UID_HASH_KEY = '__immutablehash__';
if (typeof Symbol === 'function') {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}

var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};

var ToKeyedSequence = /*@__PURE__*/(function (KeyedSeq$$1) {
  function ToKeyedSequence(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }

  if ( KeyedSeq$$1 ) ToKeyedSequence.__proto__ = KeyedSeq$$1;
  ToKeyedSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
  ToKeyedSequence.prototype.constructor = ToKeyedSequence;

  ToKeyedSequence.prototype.get = function get (key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };

  ToKeyedSequence.prototype.has = function has (key) {
    return this._iter.has(key);
  };

  ToKeyedSequence.prototype.valueSeq = function valueSeq () {
    return this._iter.valueSeq();
  };

  ToKeyedSequence.prototype.reverse = function reverse () {
    var this$1 = this;

    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function () { return this$1._iter.toSeq().reverse(); };
    }
    return reversedSequence;
  };

  ToKeyedSequence.prototype.map = function map (mapper, context) {
    var this$1 = this;

    var mappedSequence = mapFactory(this, mapper, context);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function () { return this$1._iter.toSeq().map(mapper, context); };
    }
    return mappedSequence;
  };

  ToKeyedSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (v, k) { return fn(v, k, this$1); }, reverse);
  };

  ToKeyedSequence.prototype.__iterator = function __iterator (type, reverse) {
    return this._iter.__iterator(type, reverse);
  };

  return ToKeyedSequence;
}(KeyedSeq));
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;

var ToIndexedSequence = /*@__PURE__*/(function (IndexedSeq$$1) {
  function ToIndexedSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if ( IndexedSeq$$1 ) ToIndexedSequence.__proto__ = IndexedSeq$$1;
  ToIndexedSequence.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  ToIndexedSequence.prototype.constructor = ToIndexedSequence;

  ToIndexedSequence.prototype.includes = function includes (value) {
    return this._iter.includes(value);
  };

  ToIndexedSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var i = 0;
    reverse && ensureSize(this);
    return this._iter.__iterate(
      function (v) { return fn(v, reverse ? this$1.size - ++i : i++, this$1); },
      reverse
    );
  };

  ToIndexedSequence.prototype.__iterator = function __iterator (type, reverse) {
    var this$1 = this;

    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    var i = 0;
    reverse && ensureSize(this);
    return new Iterator(function () {
      var step = iterator.next();
      return step.done
        ? step
        : iteratorValue(
            type,
            reverse ? this$1.size - ++i : i++,
            step.value,
            step
          );
    });
  };

  return ToIndexedSequence;
}(IndexedSeq));

var ToSetSequence = /*@__PURE__*/(function (SetSeq$$1) {
  function ToSetSequence(iter) {
    this._iter = iter;
    this.size = iter.size;
  }

  if ( SetSeq$$1 ) ToSetSequence.__proto__ = SetSeq$$1;
  ToSetSequence.prototype = Object.create( SetSeq$$1 && SetSeq$$1.prototype );
  ToSetSequence.prototype.constructor = ToSetSequence;

  ToSetSequence.prototype.has = function has (key) {
    return this._iter.includes(key);
  };

  ToSetSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (v) { return fn(v, v, this$1); }, reverse);
  };

  ToSetSequence.prototype.__iterator = function __iterator (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    return new Iterator(function () {
      var step = iterator.next();
      return step.done
        ? step
        : iteratorValue(type, step.value, step.value, step);
    });
  };

  return ToSetSequence;
}(SetSeq));

var FromEntriesSequence = /*@__PURE__*/(function (KeyedSeq$$1) {
  function FromEntriesSequence(entries) {
    this._iter = entries;
    this.size = entries.size;
  }

  if ( KeyedSeq$$1 ) FromEntriesSequence.__proto__ = KeyedSeq$$1;
  FromEntriesSequence.prototype = Object.create( KeyedSeq$$1 && KeyedSeq$$1.prototype );
  FromEntriesSequence.prototype.constructor = FromEntriesSequence;

  FromEntriesSequence.prototype.entrySeq = function entrySeq () {
    return this._iter.toSeq();
  };

  FromEntriesSequence.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._iter.__iterate(function (entry) {
      // Check if entry exists first so array access doesn't throw for holes
      // in the parent iteration.
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn(
          indexedCollection ? entry.get(1) : entry[1],
          indexedCollection ? entry.get(0) : entry[0],
          this$1
        );
      }
    }, reverse);
  };

  FromEntriesSequence.prototype.__iterator = function __iterator (type, reverse) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
    return new Iterator(function () {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        // Check if entry exists first so array access doesn't throw for holes
        // in the parent iteration.
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  };

  return FromEntriesSequence;
}(KeyedSeq));

ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;

function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function () { return collection; };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this); // super.reverse()
    reversedSequence.flip = function () { return collection.reverse(); };
    return reversedSequence;
  };
  flipSequence.has = function (key) { return collection.includes(key); };
  flipSequence.includes = function (key) { return collection.has(key); };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    return collection.__iterate(function (v, k) { return fn(k, v, this$1) !== false; }, reverse);
  };
  flipSequence.__iteratorUncached = function(type, reverse) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse);
      return new Iterator(function () {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse
    );
  };
  return flipSequence;
}

function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function (key) { return collection.has(key); };
  mappedSequence.get = function (key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET
      ? notSetValue
      : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    return collection.__iterate(
      function (v, k, c) { return fn(mapper.call(context, v, k, c), k, this$1) !== false; },
      reverse
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    return new Iterator(function () {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}

function reverseFactory(collection, useKeys) {
  var this$1 = this;

  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function () { return collection; };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function () { return collection.flip(); };
      return flipSequence;
    };
  }
  reversedSequence.get = function (key, notSetValue) { return collection.get(useKeys ? key : -1 - key, notSetValue); };
  reversedSequence.has = function (key) { return collection.has(useKeys ? key : -1 - key); };
  reversedSequence.includes = function (value) { return collection.includes(value); };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse) {
    var this$1 = this;

    var i = 0;
    reverse && ensureSize(collection);
    return collection.__iterate(
      function (v, k) { return fn(v, useKeys ? k : reverse ? this$1.size - ++i : i++, this$1); },
      !reverse
    );
  };
  reversedSequence.__iterator = function (type, reverse) {
    var i = 0;
    reverse && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse);
    return new Iterator(function () {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse ? this$1.size - ++i : i++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}

function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function (key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function (key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection)
        ? v
        : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    collection.__iterate(function (v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1);
      }
    }, reverse);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var iterations = 0;
    return new Iterator(function () {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}

function countByFactory(collection, grouper, context) {
  var groups = Map().asMutable();
  collection.__iterate(function (v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function (a) { return a + 1; });
  });
  return groups.asImmutable();
}

function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map()).asMutable();
  collection.__iterate(function (v, k) {
    groups.update(
      grouper.call(context, v, k, collection),
      function (a) { return ((a = a || []), a.push(isKeyedIter ? [k, v] : v), a); }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function (arr) { return reify(collection, coerce(arr)); }).asImmutable();
}

function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;

  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }

  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);

  // begin or end will be NaN if they were provided as negative numbers and
  // this collection's size is unknown. In that case, cache first so there is
  // a known size and these do not resolve to NaN.
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }

  // Note: resolvedEnd is undefined when the original sequence's length is
  // unknown and this slice did not supply an end and should contain all
  // elements after resolvedBegin.
  // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }

  var sliceSeq = makeSequence(collection);

  // If collection.size is undefined, the size of the realized sliceSeq is
  // unknown at this point unless the number of items to slice is 0
  sliceSeq.size =
    sliceSize === 0 ? sliceSize : (collection.size && sliceSize) || undefined;

  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize
        ? collection.get(index + resolvedBegin, notSetValue)
        : notSetValue;
    };
  }

  sliceSeq.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (sliceSize === 0) {
      return 0;
    }
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function (v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return (
          fn(v, useKeys ? k : iterations - 1, this$1) !== false &&
          iterations !== sliceSize
        );
      }
    });
    return iterations;
  };

  sliceSeq.__iteratorUncached = function(type, reverse) {
    if (sliceSize !== 0 && reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    // Don't bother instantiating parent iterator if taking 0.
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function () {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, undefined, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };

  return sliceSeq;
}

function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    collection.__iterate(
      function (v, k, c) { return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1); }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var iterating = true;
    return new Iterator(function () {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}

function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function (v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse) {
    var this$1 = this;

    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function () {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, undefined, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}

function concatFactory(collection, values) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection]
    .concat(values)
    .map(function (v) {
      if (!isCollection(v)) {
        v = isKeyedCollection
          ? keyedSeqFromValue(v)
          : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
      } else if (isKeyedCollection) {
        v = KeyedCollection(v);
      }
      return v;
    })
    .filter(function (v) { return v.size !== 0; });

  if (iters.length === 0) {
    return collection;
  }

  if (iters.length === 1) {
    var singleton = iters[0];
    if (
      singleton === collection ||
      (isKeyedCollection && isKeyed(singleton)) ||
      (isIndexed(collection) && isIndexed(singleton))
    ) {
      return singleton;
    }
  }

  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function (sum, seq) {
    if (sum !== undefined) {
      var size = seq.size;
      if (size !== undefined) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}

function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse) {
    if (reverse) {
      return this.cacheResult().__iterate(fn, reverse);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function (v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse) {
    if (reverse) {
      return this.cacheResult().__iterator(type, reverse);
    }
    var iterator = collection.__iterator(type, reverse);
    var stack = [];
    var iterations = 0;
    return new Iterator(function () {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}

function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection
    .toSeq()
    .map(function (v, k) { return coerce(mapper.call(context, v, k, collection)); })
    .flatten(true);
}

function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    collection.__iterate(
      function (v) { return (!iterations || fn(separator, iterations++, this$1) !== false) &&
        fn(v, iterations++, this$1) !== false; },
      reverse
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse);
    var iterations = 0;
    var step;
    return new Iterator(function () {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2
        ? iteratorValue(type, iterations++, separator)
        : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}

function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries = collection
    .toSeq()
    .map(function (v, k) { return [k, v, index++, mapper ? mapper(v, k, collection) : v]; })
    .valueSeq()
    .toArray();
  entries.sort(function (a, b) { return comparator(a[3], b[3]) || a[2] - b[2]; }).forEach(
    isKeyedCollection
      ? function (v, i) {
          entries[i].length = 2;
        }
      : function (v, i) {
          entries[i] = v[1];
        }
  );
  return isKeyedCollection
    ? KeyedSeq(entries)
    : isIndexed(collection)
      ? IndexedSeq(entries)
      : SetSeq(entries);
}

function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection
      .toSeq()
      .map(function (v, k) { return [v, mapper(v, k, collection)]; })
      .reduce(function (a, b) { return (maxCompare(comparator, a[1], b[1]) ? b : a); });
    return entry && entry[0];
  }
  return collection.reduce(function (a, b) { return (maxCompare(comparator, a, b) ? b : a); });
}

function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  // b is considered the new max if the comparator declares them equal, but
  // they are not equal and b is in fact a nullish value.
  return (
    (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) ||
    comp > 0
  );
}

function zipWithFactory(keyIter, zipper, iters, zipAll) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function (i) { return i.size; });
  zipSequence.size = zipAll ? sizes.max() : sizes.min();
  // Note: this a generic base implementation of __iterate in terms of
  // __iterator which may be more generically useful in the future.
  zipSequence.__iterate = function(fn, reverse) {
    /* generic:
    var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      iterations++;
      if (fn(step.value[1], step.value[0], this) === false) {
        break;
      }
    }
    return iterations;
    */
    // indexed:
    var iterator = this.__iterator(ITERATE_VALUES, reverse);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse) {
    var iterators = iters.map(
      function (i) { return ((i = Collection(i)), getIterator(reverse ? i.reverse() : i)); }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function () {
      var steps;
      if (!isDone) {
        steps = iterators.map(function (i) { return i.next(); });
        isDone = zipAll ? steps.every(function (s) { return s.done; }) : steps.some(function (s) { return s.done; });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(null, steps.map(function (s) { return s.value; }))
      );
    });
  };
  return zipSequence;
}

// #pragma Helper Functions

function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}

function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError('Expected [K, V] tuple: ' + entry);
  }
}

function collectionClass(collection) {
  return isKeyed(collection)
    ? KeyedCollection
    : isIndexed(collection)
      ? IndexedCollection
      : SetCollection;
}

function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection)
      ? KeyedSeq
      : isIndexed(collection)
        ? IndexedSeq
        : SetSeq
    ).prototype
  );
}

function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}

function defaultComparator(a, b) {
  if (a === undefined && b === undefined) {
    return 0;
  }

  if (a === undefined) {
    return 1;
  }

  if (b === undefined) {
    return -1;
  }

  return a > b ? 1 : a < b ? -1 : 0;
}

// http://jsperf.com/copy-array-inline
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}

function invariant(condition, error) {
  if (!condition) { throw new Error(error); }
}

function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    'Cannot perform this action with an infinite size.'
  );
}

function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== 'string') {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    'Invalid keyPath: expected Ordered Collection or Array: ' + keyPath
  );
}

function isPlainObj(value) {
  return (
    value &&
    (typeof value.constructor !== 'function' ||
      value.constructor.name === 'Object')
  );
}

/**
 * Returns true if the value is a potentially-persistent data structure, either
 * provided by Immutable.js or a plain Array or Object.
 */
function isDataStructure(value) {
  return (
    typeof value === 'object' &&
    (isImmutable(value) || Array.isArray(value) || isPlainObj(value))
  );
}

/**
 * Converts a value to a string, adding quotes if a string was provided.
 */
function quoteString(value) {
  try {
    return typeof value === 'string' ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}

function has(collection, key) {
  return isImmutable(collection)
    ? collection.has(key)
    : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}

function get(collection, key, notSetValue) {
  return isImmutable(collection)
    ? collection.get(key, notSetValue)
    : !has(collection, key)
      ? notSetValue
      : typeof collection.get === 'function'
        ? collection.get(key)
        : collection[key];
}

function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to = {};
  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}

function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      'Cannot update non-data-structure value: ' + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        'Cannot update immutable value without .remove() method: ' + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}

function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      'Cannot update non-data-structure value: ' + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        'Cannot update immutable value without .set() method: ' + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}

function updateIn(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = undefined;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}

function updateInDeeply(
  inImmutable,
  existing,
  keyPath,
  i,
  notSetValue,
  updater
) {
  var wasNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      'Cannot update within non-data-structure value in path [' +
        keyPath.slice(0, i).map(quoteString) +
        ']: ' +
        existing
    );
  }
  var key = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting
    ? existing
    : nextUpdated === NOT_SET
      ? remove(existing, key)
      : set(
          wasNotSet ? (inImmutable ? emptyMap() : {}) : existing,
          key,
          nextUpdated
        );
}

function setIn(collection, keyPath, value) {
  return updateIn(collection, keyPath, NOT_SET, function () { return value; });
}

function setIn$1(keyPath, v) {
  return setIn(this, keyPath, v);
}

function removeIn(collection, keyPath) {
  return updateIn(collection, keyPath, function () { return NOT_SET; });
}

function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}

function update(collection, key, notSetValue, updater) {
  return updateIn(collection, [key], notSetValue, updater);
}

function update$1(key, notSetValue, updater) {
  return arguments.length === 1
    ? key(this)
    : update(this, key, notSetValue, updater);
}

function updateIn$1(keyPath, notSetValue, updater) {
  return updateIn(this, keyPath, notSetValue, updater);
}

function merge() {
  var iters = [], len = arguments.length;
  while ( len-- ) iters[ len ] = arguments[ len ];

  return mergeIntoKeyedWith(this, iters);
}

function mergeWith(merger) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  if (typeof merger !== 'function') {
    throw new TypeError('Invalid merger function: ' + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}

function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (
    collection.toSeq().size === 0 &&
    !collection.__ownerID &&
    iters.length === 1
  ) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function (collection) {
    var mergeIntoCollection = merger
      ? function (value, key) {
          update(
            collection,
            key,
            NOT_SET,
            function (oldVal) { return (oldVal === NOT_SET ? value : merger(oldVal, value, key)); }
          );
        }
      : function (value, key) {
          collection.set(key, value);
        };
    for (var ii = 0; ii < iters.length; ii++) {
      iters[ii].forEach(mergeIntoCollection);
    }
  });
}

function merge$1(collection) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  return mergeWithSources(collection, sources);
}

function mergeWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

  return mergeWithSources(collection, sources, merger);
}

function mergeDeep(collection) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  return mergeDeepWithSources(collection, sources);
}

function mergeDeepWith(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 2 ];

  return mergeDeepWithSources(collection, sources, merger);
}

function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}

function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      'Cannot merge into non-data-structure value: ' + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === 'function' && collection.mergeWith
      ? collection.mergeWith.apply(collection, [ merger ].concat( sources ))
      : collection.merge
        ? collection.merge.apply(collection, sources)
        : collection.concat.apply(collection, sources);
  }
  var isArray = Array.isArray(collection);
  var merged = collection;
  var Collection$$1 = isArray ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray
    ? function (value) {
        // Copy on write
        if (merged === collection) {
          merged = shallowCopy(merged);
        }
        merged.push(value);
      }
    : function (value, key) {
        var hasVal = hasOwnProperty.call(merged, key);
        var nextVal =
          hasVal && merger ? merger(merged[key], value, key) : value;
        if (!hasVal || nextVal !== merged[key]) {
          // Copy on write
          if (merged === collection) {
            merged = shallowCopy(merged);
          }
          merged[key] = nextVal;
        }
      };
  for (var i = 0; i < sources.length; i++) {
    Collection$$1(sources[i]).forEach(mergeItem);
  }
  return merged;
}

function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue)
      ? mergeWithSources(oldValue, [newValue], deepMerger)
      : merger
        ? merger(oldValue, newValue, key)
        : newValue;
  }
  return deepMerger;
}

function mergeDeep$1() {
  var iters = [], len = arguments.length;
  while ( len-- ) iters[ len ] = arguments[ len ];

  return mergeDeepWithSources(this, iters);
}

function mergeDeepWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  return mergeDeepWithSources(this, iters, merger);
}

function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  return updateIn(this, keyPath, emptyMap(), function (m) { return mergeWithSources(m, iters); });
}

function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while ( len-- > 0 ) iters[ len ] = arguments[ len + 1 ];

  return updateIn(this, keyPath, emptyMap(), function (m) { return mergeDeepWithSources(m, iters); }
  );
}

function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}

function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}

function asImmutable() {
  return this.__ensureOwner();
}

function wasAltered() {
  return this.__altered;
}

var Map = /*@__PURE__*/(function (KeyedCollection$$1) {
  function Map(value) {
    return value === null || value === undefined
      ? emptyMap()
      : isMap(value) && !isOrdered(value)
        ? value
        : emptyMap().withMutations(function (map) {
            var iter = KeyedCollection$$1(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v, k) { return map.set(k, v); });
          });
  }

  if ( KeyedCollection$$1 ) Map.__proto__ = KeyedCollection$$1;
  Map.prototype = Object.create( KeyedCollection$$1 && KeyedCollection$$1.prototype );
  Map.prototype.constructor = Map;

  Map.of = function of () {
    var keyValues = [], len = arguments.length;
    while ( len-- ) keyValues[ len ] = arguments[ len ];

    return emptyMap().withMutations(function (map) {
      for (var i = 0; i < keyValues.length; i += 2) {
        if (i + 1 >= keyValues.length) {
          throw new Error('Missing value for key: ' + keyValues[i]);
        }
        map.set(keyValues[i], keyValues[i + 1]);
      }
    });
  };

  Map.prototype.toString = function toString () {
    return this.__toString('Map {', '}');
  };

  // @pragma Access

  Map.prototype.get = function get (k, notSetValue) {
    return this._root
      ? this._root.get(0, undefined, k, notSetValue)
      : notSetValue;
  };

  // @pragma Modification

  Map.prototype.set = function set (k, v) {
    return updateMap(this, k, v);
  };

  Map.prototype.remove = function remove (k) {
    return updateMap(this, k, NOT_SET);
  };

  Map.prototype.deleteAll = function deleteAll (keys) {
    var collection = Collection(keys);

    if (collection.size === 0) {
      return this;
    }

    return this.withMutations(function (map) {
      collection.forEach(function (key) { return map.remove(key); });
    });
  };

  Map.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };

  // @pragma Composition

  Map.prototype.sort = function sort (comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator));
  };

  Map.prototype.sortBy = function sortBy (mapper, comparator) {
    // Late binding
    return OrderedMap(sortFactory(this, comparator, mapper));
  };

  Map.prototype.map = function map (mapper, context) {
    return this.withMutations(function (map) {
      map.forEach(function (value, key) {
        map.set(key, mapper.call(context, value, key, map));
      });
    });
  };

  // @pragma Mutability

  Map.prototype.__iterator = function __iterator (type, reverse) {
    return new MapIterator(this, type, reverse);
  };

  Map.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    var iterations = 0;
    this._root &&
      this._root.iterate(function (entry) {
        iterations++;
        return fn(entry[1], entry[0], this$1);
      }, reverse);
    return iterations;
  };

  Map.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };

  return Map;
}(KeyedCollection));

Map.isMap = isMap;

var MapPrototype = Map.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn$1;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update$1;
MapPrototype.updateIn = updateIn$1;
MapPrototype.merge = MapPrototype.concat = merge;
MapPrototype.mergeWith = mergeWith;
MapPrototype.mergeDeep = mergeDeep$1;
MapPrototype.mergeDeepWith = mergeDeepWith$1;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype['@@transducer/init'] = MapPrototype.asMutable = asMutable;
MapPrototype['@@transducer/step'] = function(result, arr) {
  return result.set(arr[0], arr[1]);
};
MapPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

// #pragma Trie Nodes

var ArrayMapNode = function ArrayMapNode(ownerID, entries) {
  this.ownerID = ownerID;
  this.entries = entries;
};

ArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  var entries = this.entries;
  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }
  return notSetValue;
};

ArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;

  var entries = this.entries;
  var idx = 0;
  var len = entries.length;
  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }
  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && entries.length === 1) {
    return; // undefined
  }

  if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries, key, value);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1
        ? newEntries.pop()
        : (newEntries[idx] = newEntries.pop());
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new ArrayMapNode(ownerID, newEntries);
};

var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};

BitmapIndexedNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0
    ? notSetValue
    : this.nodes[popCount(bitmap & (bit - 1))].get(
        shift + SHIFT,
        keyHash,
        key,
        notSetValue
      );
};

BitmapIndexedNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;

  if (!exists && value === NOT_SET) {
    return this;
  }

  var idx = popCount(bitmap & (bit - 1));
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : undefined;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );

  if (newNode === node) {
    return this;
  }

  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }

  if (
    exists &&
    !newNode &&
    nodes.length === 2 &&
    isLeafNode(nodes[idx ^ 1])
  ) {
    return nodes[idx ^ 1];
  }

  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? (newNode ? bitmap : bitmap ^ bit) : bitmap | bit;
  var newNodes = exists
    ? newNode
      ? setAt(nodes, idx, newNode, isEditable)
      : spliceOut(nodes, idx, isEditable)
    : spliceIn(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }

  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};

var HashArrayMapNode = function HashArrayMapNode(ownerID, count, nodes) {
  this.ownerID = ownerID;
  this.count = count;
  this.nodes = nodes;
};

HashArrayMapNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node
    ? node.get(shift + SHIFT, keyHash, key, notSetValue)
    : notSetValue;
};

HashArrayMapNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];

  if (removed && !node) {
    return this;
  }

  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }

  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);

  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }

  return new HashArrayMapNode(ownerID, newCount, newNodes);
};

var HashCollisionNode = function HashCollisionNode(ownerID, keyHash, entries) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries;
};

HashCollisionNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  var entries = this.entries;
  for (var ii = 0, len = entries.length; ii < len; ii++) {
    if (is(key, entries[ii][0])) {
      return entries[ii][1];
    }
  }
  return notSetValue;
};

HashCollisionNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === undefined) {
    keyHash = hash(key);
  }

  var removed = value === NOT_SET;

  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }

  var entries = this.entries;
  var idx = 0;
  var len = entries.length;
  for (; idx < len; idx++) {
    if (is(key, entries[idx][0])) {
      break;
    }
  }
  var exists = idx < len;

  if (exists ? entries[idx][1] === value : removed) {
    return this;
  }

  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);

  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
  }

  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries : arrCopy(entries);

  if (exists) {
    if (removed) {
      idx === len - 1
        ? newEntries.pop()
        : (newEntries[idx] = newEntries.pop());
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }

  if (isEditable) {
    this.entries = newEntries;
    return this;
  }

  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};

var ValueNode = function ValueNode(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};

ValueNode.prototype.get = function get (shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};

ValueNode.prototype.update = function update (ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }

  SetRef(didAlter);

  if (removed) {
    SetRef(didChangeSize);
    return; // undefined
  }

  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }

  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};

// #pragma Iterators

ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(
  fn,
  reverse
) {
  var entries = this.entries;
  for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};

BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(
  fn,
  reverse
) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse ? maxIndex - ii : ii];
    if (node && node.iterate(fn, reverse) === false) {
      return false;
    }
  }
};

// eslint-disable-next-line no-unused-vars
ValueNode.prototype.iterate = function(fn, reverse) {
  return fn(this.entry);
};

var MapIterator = /*@__PURE__*/(function (Iterator$$1) {
  function MapIterator(map, type, reverse) {
    this._type = type;
    this._reverse = reverse;
    this._stack = map._root && mapIteratorFrame(map._root);
  }

  if ( Iterator$$1 ) MapIterator.__proto__ = Iterator$$1;
  MapIterator.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );
  MapIterator.prototype.constructor = MapIterator;

  MapIterator.prototype.next = function next () {
    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = (void 0);
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(
            type,
            node.entries[this._reverse ? maxIndex - index : index]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  };

  return MapIterator;
}(Iterator));

function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}

function mapIteratorFrame(node, prev) {
  return {
    node: node,
    index: 0,
    __prev: prev,
  };
}

function makeMap(size, root, ownerID, hash$$1) {
  var map = Object.create(MapPrototype);
  map.size = size;
  map._root = root;
  map.__ownerID = ownerID;
  map.__hash = hash$$1;
  map.__altered = false;
  return map;
}

var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}

function updateMap(map, k, v) {
  var newRoot;
  var newSize;
  if (!map._root) {
    if (v === NOT_SET) {
      return map;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map._root,
      map.__ownerID,
      0,
      undefined,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map;
    }
    newSize = map.size + (didChangeSize.value ? (v === NOT_SET ? -1 : 1) : 0);
  }
  if (map.__ownerID) {
    map.size = newSize;
    map._root = newRoot;
    map.__hash = undefined;
    map.__altered = true;
    return map;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}

function updateNode(
  node,
  ownerID,
  shift,
  keyHash,
  key,
  value,
  didChangeSize,
  didAlter
) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}

function isLeafNode(node) {
  return (
    node.constructor === ValueNode || node.constructor === HashCollisionNode
  );
}

function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }

  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

  var newNode;
  var nodes =
    idx1 === idx2
      ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)]
      : ((newNode = new ValueNode(ownerID, keyHash, entry)),
        idx1 < idx2 ? [node, newNode] : [newNode, node]);

  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
}

function createNodes(ownerID, entries, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries.length; ii++) {
    var entry = entries[ii];
    node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
  }
  return node;
}

function packNodes(ownerID, nodes, count, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== undefined && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}

function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
}

function popCount(x) {
  x -= (x >> 1) & 0x55555555;
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x += x >> 8;
  x += x >> 16;
  return x & 0x7f;
}

function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}

function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}

function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}

var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

var IS_LIST_SYMBOL = '@@__IMMUTABLE_LIST__@@';

function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}

var List = /*@__PURE__*/(function (IndexedCollection$$1) {
  function List(value) {
    var empty = emptyList();
    if (value === null || value === undefined) {
      return empty;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection$$1(value);
    var size = iter.size;
    if (size === 0) {
      return empty;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty.withMutations(function (list) {
      list.setSize(size);
      iter.forEach(function (v, i) { return list.set(i, v); });
    });
  }

  if ( IndexedCollection$$1 ) List.__proto__ = IndexedCollection$$1;
  List.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
  List.prototype.constructor = List;

  List.of = function of (/*...values*/) {
    return this(arguments);
  };

  List.prototype.toString = function toString () {
    return this.__toString('List [', ']');
  };

  // @pragma Access

  List.prototype.get = function get (index, notSetValue) {
    index = wrapIndex(this, index);
    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }
    return notSetValue;
  };

  // @pragma Modification

  List.prototype.set = function set (index, value) {
    return updateList(this, index, value);
  };

  List.prototype.remove = function remove (index) {
    return !this.has(index)
      ? this
      : index === 0
        ? this.shift()
        : index === this.size - 1
          ? this.pop()
          : this.splice(index, 1);
  };

  List.prototype.insert = function insert (index, value) {
    return this.splice(index, 0, value);
  };

  List.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };

  List.prototype.push = function push (/*...values*/) {
    var values = arguments;
    var oldSize = this.size;
    return this.withMutations(function (list) {
      setListBounds(list, 0, oldSize + values.length);
      for (var ii = 0; ii < values.length; ii++) {
        list.set(oldSize + ii, values[ii]);
      }
    });
  };

  List.prototype.pop = function pop () {
    return setListBounds(this, 0, -1);
  };

  List.prototype.unshift = function unshift (/*...values*/) {
    var values = arguments;
    return this.withMutations(function (list) {
      setListBounds(list, -values.length);
      for (var ii = 0; ii < values.length; ii++) {
        list.set(ii, values[ii]);
      }
    });
  };

  List.prototype.shift = function shift () {
    return setListBounds(this, 1);
  };

  // @pragma Composition

  List.prototype.concat = function concat (/*...collections*/) {
    var arguments$1 = arguments;

    var seqs = [];
    for (var i = 0; i < arguments.length; i++) {
      var argument = arguments$1[i];
      var seq = IndexedCollection$$1(
        typeof argument !== 'string' && hasIterator(argument)
          ? argument
          : [argument]
      );
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function (list) {
      seqs.forEach(function (seq) { return seq.forEach(function (value) { return list.push(value); }); });
    });
  };

  List.prototype.setSize = function setSize (size) {
    return setListBounds(this, 0, size);
  };

  List.prototype.map = function map (mapper, context) {
    var this$1 = this;

    return this.withMutations(function (list) {
      for (var i = 0; i < this$1.size; i++) {
        list.set(i, mapper.call(context, list.get(i), i, list));
      }
    });
  };

  // @pragma Iteration

  List.prototype.slice = function slice (begin, end) {
    var size = this.size;
    if (wholeSlice(begin, end, size)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size),
      resolveEnd(end, size)
    );
  };

  List.prototype.__iterator = function __iterator (type, reverse) {
    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    return new Iterator(function () {
      var value = values();
      return value === DONE
        ? iteratorDone()
        : iteratorValue(type, reverse ? --index : index++, value);
    });
  };

  List.prototype.__iterate = function __iterate (fn, reverse) {
    var index = reverse ? this.size : 0;
    var values = iterateList(this, reverse);
    var value;
    while ((value = values()) !== DONE) {
      if (fn(value, reverse ? --index : index++, this) === false) {
        break;
      }
    }
    return index;
  };

  List.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  };

  return List;
}(IndexedCollection));

List.isList = isList;

var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn$1;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update$1;
ListPrototype.updateIn = updateIn$1;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype['@@transducer/init'] = ListPrototype.asMutable = asMutable;
ListPrototype['@@transducer/step'] = function(result, arr) {
  return result.push(arr);
};
ListPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

var VNode = function VNode(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};

// TODO: seems like these methods are very similar

VNode.prototype.removeBefore = function removeBefore (ownerID, level, index) {
  if (index === level ? 1 << level : this.array.length === 0) {
    return this;
  }
  var originIndex = (index >>> level) & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild =
      oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = undefined;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};

VNode.prototype.removeAfter = function removeAfter (ownerID, level, index) {
  if (index === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = ((index - 1) >>> level) & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }

  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild =
      oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }

  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};

var DONE = {};

function iterateList(list, reverse) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;

  return iterateNodeOrLeaf(list._root, list._level, 0);

  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0
      ? iterateLeaf(node, offset)
      : iterateNode(node, level, offset);
  }

  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function () {
      if (from === to) {
        return DONE;
      }
      var idx = reverse ? --to : from++;
      return array && array[idx];
    };
  }

  function iterateNode(node, level, offset) {
    var values;
    var array = node && node.array;
    var from = offset > left ? 0 : (left - offset) >> level;
    var to = ((right - offset) >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function () {
      while (true) {
        if (values) {
          var value = values();
          if (value !== DONE) {
            return value;
          }
          values = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse ? --to : from++;
        values = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}

function makeList(origin, capacity, level, root, tail, ownerID, hash) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash;
  list.__altered = false;
  return list;
}

var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}

function updateList(list, index, value) {
  index = wrapIndex(list, index);

  if (index !== index) {
    return list;
  }

  if (index >= list.size || index < 0) {
    return list.withMutations(function (list) {
      index < 0
        ? setListBounds(list, index).set(0, value)
        : setListBounds(list, 0, index + 1).set(index, value);
    });
  }

  index += list._origin;

  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value,
      didAlter
    );
  }

  if (!didAlter.value) {
    return list;
  }

  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}

function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = (index >>> level) & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === undefined) {
    return node;
  }

  var newNode;

  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }

  if (nodeHas && node.array[idx] === value) {
    return node;
  }

  if (didAlter) {
    SetRef(didAlter);
  }

  newNode = editableVNode(node, ownerID);
  if (value === undefined && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}

function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}

function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << (list._level + SHIFT)) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[(rawIndex >>> level) & MASK];
      level -= SHIFT;
    }
    return node;
  }
}

function setListBounds(list, begin, end) {
  // Sanitize begin & end using this shorthand for ToInt32(argument)
  // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
  if (begin !== undefined) {
    begin |= 0;
  }
  if (end !== undefined) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity =
    end === undefined
      ? oldCapacity
      : end < 0
        ? oldCapacity + end
        : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }

  // If it's going to end after it starts, it's empty.
  if (newOrigin >= newCapacity) {
    return list.clear();
  }

  var newLevel = list._level;
  var newRoot = list._root;

  // New origin might need creating a higher root.
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [undefined, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }

  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);

  // New size might need creating a higher root.
  while (newTailOffset >= 1 << (newLevel + SHIFT)) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }

  // Locate or create the new tail.
  var oldTail = list._tail;
  var newTail =
    newTailOffset < oldTailOffset
      ? listNodeFor(list, newCapacity - 1)
      : newTailOffset > oldTailOffset
        ? new VNode([], owner)
        : oldTail;

  // Merge Tail into tree.
  if (
    oldTail &&
    newTailOffset > oldTailOffset &&
    newOrigin < oldCapacity &&
    oldTail.array.length
  ) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = (oldTailOffset >>> level) & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
  }

  // If the size has been reduced, there's a chance the tail needs to be trimmed.
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }

  // If the new origin is within the tail, then we do not need a root.
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

    // Otherwise, if the root has been trimmed, garbage collect.
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;

    // Identify the new top root node of the subtree of the old root.
    while (newRoot) {
      var beginIndex = (newOrigin >>> newLevel) & MASK;
      if ((beginIndex !== newTailOffset >>> newLevel) & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }

    // Trim the new sides of the new root.
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }

  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = undefined;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}

function getTailOffset(size) {
  return size < SIZE ? 0 : ((size - 1) >>> SHIFT) << SHIFT;
}

var OrderedMap = /*@__PURE__*/(function (Map$$1) {
  function OrderedMap(value) {
    return value === null || value === undefined
      ? emptyOrderedMap()
      : isOrderedMap(value)
        ? value
        : emptyOrderedMap().withMutations(function (map) {
            var iter = KeyedCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v, k) { return map.set(k, v); });
          });
  }

  if ( Map$$1 ) OrderedMap.__proto__ = Map$$1;
  OrderedMap.prototype = Object.create( Map$$1 && Map$$1.prototype );
  OrderedMap.prototype.constructor = OrderedMap;

  OrderedMap.of = function of (/*...values*/) {
    return this(arguments);
  };

  OrderedMap.prototype.toString = function toString () {
    return this.__toString('OrderedMap {', '}');
  };

  // @pragma Access

  OrderedMap.prototype.get = function get (k, notSetValue) {
    var index = this._map.get(k);
    return index !== undefined ? this._list.get(index)[1] : notSetValue;
  };

  // @pragma Modification

  OrderedMap.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      return this;
    }
    return emptyOrderedMap();
  };

  OrderedMap.prototype.set = function set (k, v) {
    return updateOrderedMap(this, k, v);
  };

  OrderedMap.prototype.remove = function remove (k) {
    return updateOrderedMap(this, k, NOT_SET);
  };

  OrderedMap.prototype.wasAltered = function wasAltered () {
    return this._map.wasAltered() || this._list.wasAltered();
  };

  OrderedMap.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._list.__iterate(
      function (entry) { return entry && fn(entry[1], entry[0], this$1); },
      reverse
    );
  };

  OrderedMap.prototype.__iterator = function __iterator (type, reverse) {
    return this._list.fromEntrySeq().__iterator(type, reverse);
  };

  OrderedMap.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };

  return OrderedMap;
}(Map));

OrderedMap.isOrderedMap = isOrderedMap;

OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;

function makeOrderedMap(map, list, ownerID, hash) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map ? map.size : 0;
  omap._map = map;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash;
  return omap;
}

var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return (
    EMPTY_ORDERED_MAP ||
    (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()))
  );
}

function updateOrderedMap(omap, k, v) {
  var map = omap._map;
  var list = omap._list;
  var i = map.get(k);
  var has = i !== undefined;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    // removed
    if (!has) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map.size * 2) {
      newList = list.filter(function (entry, idx) { return entry !== undefined && i !== idx; });
      newMap = newList
        .toKeyedSeq()
        .map(function (entry) { return entry[0]; })
        .flip()
        .toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
    }
  } else if (has) {
    if (v === list.get(i)[1]) {
      return omap;
    }
    newMap = map;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = undefined;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}

var IS_STACK_SYMBOL = '@@__IMMUTABLE_STACK__@@';

function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}

var Stack = /*@__PURE__*/(function (IndexedCollection$$1) {
  function Stack(value) {
    return value === null || value === undefined
      ? emptyStack()
      : isStack(value)
        ? value
        : emptyStack().pushAll(value);
  }

  if ( IndexedCollection$$1 ) Stack.__proto__ = IndexedCollection$$1;
  Stack.prototype = Object.create( IndexedCollection$$1 && IndexedCollection$$1.prototype );
  Stack.prototype.constructor = Stack;

  Stack.of = function of (/*...values*/) {
    return this(arguments);
  };

  Stack.prototype.toString = function toString () {
    return this.__toString('Stack [', ']');
  };

  // @pragma Access

  Stack.prototype.get = function get (index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };

  Stack.prototype.peek = function peek () {
    return this._head && this._head.value;
  };

  // @pragma Modification

  Stack.prototype.push = function push (/*...values*/) {
    var arguments$1 = arguments;

    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head,
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  Stack.prototype.pushAll = function pushAll (iter) {
    iter = IndexedCollection$$1(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(function (value) {
      newSize++;
      head = {
        value: value,
        next: head,
      };
    }, /* reverse */ true);
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  Stack.prototype.pop = function pop () {
    return this.slice(1);
  };

  Stack.prototype.clear = function clear () {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = undefined;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };

  Stack.prototype.slice = function slice (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      // super.slice(begin, end);
      return IndexedCollection$$1.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };

  // @pragma Mutability

  Stack.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };

  // @pragma Iteration

  Stack.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    if (reverse) {
      return new ArraySeq(this.toArray()).__iterate(
        function (v, k) { return fn(v, k, this$1); },
        reverse
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };

  Stack.prototype.__iterator = function __iterator (type, reverse) {
    if (reverse) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function () {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  };

  return Stack;
}(IndexedCollection));

Stack.isStack = isStack;

var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype['@@transducer/init'] = StackPrototype.asMutable = asMutable;
StackPrototype['@@transducer/step'] = function(result, arr) {
  return result.unshift(arr);
};
StackPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

function makeStack(size, head, ownerID, hash) {
  var map = Object.create(StackPrototype);
  map.size = size;
  map._head = head;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = false;
  return map;
}

var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}

var IS_SET_SYMBOL = '@@__IMMUTABLE_SET__@@';

function isSet(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}

function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}

function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (
    !isCollection(b) ||
    (a.size !== undefined && b.size !== undefined && a.size !== b.size) ||
    (a.__hash !== undefined &&
      b.__hash !== undefined &&
      a.__hash !== b.__hash) ||
    isKeyed(a) !== isKeyed(b) ||
    isIndexed(a) !== isIndexed(b) ||
    isOrdered(a) !== isOrdered(b)
  ) {
    return false;
  }

  if (a.size === 0 && b.size === 0) {
    return true;
  }

  var notAssociative = !isAssociative(a);

  if (isOrdered(a)) {
    var entries = a.entries();
    return (
      b.every(function (v, k) {
        var entry = entries.next().value;
        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
      }) && entries.next().done
    );
  }

  var flipped = false;

  if (a.size === undefined) {
    if (b.size === undefined) {
      if (typeof a.cacheResult === 'function') {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }

  var allEqual = true;
  var bSize = b.__iterate(function (v, k) {
    if (
      notAssociative
        ? !a.has(v)
        : flipped
          ? !is(v, a.get(k, NOT_SET))
          : !is(a.get(k, NOT_SET), v)
    ) {
      allEqual = false;
      return false;
    }
  });

  return allEqual && a.size === bSize;
}

/**
 * Contributes additional methods to a constructor
 */
function mixin(ctor, methods) {
  var keyCopier = function (key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols &&
    Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}

function toJS(value) {
  if (!value || typeof value !== 'object') {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function (v, k) {
      result$1[k] = toJS(v);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function (v) {
    result.push(toJS(v));
  });
  return result;
}

var Set = /*@__PURE__*/(function (SetCollection$$1) {
  function Set(value) {
    return value === null || value === undefined
      ? emptySet()
      : isSet(value) && !isOrdered(value)
        ? value
        : emptySet().withMutations(function (set) {
            var iter = SetCollection$$1(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v) { return set.add(v); });
          });
  }

  if ( SetCollection$$1 ) Set.__proto__ = SetCollection$$1;
  Set.prototype = Object.create( SetCollection$$1 && SetCollection$$1.prototype );
  Set.prototype.constructor = Set;

  Set.of = function of (/*...values*/) {
    return this(arguments);
  };

  Set.fromKeys = function fromKeys (value) {
    return this(KeyedCollection(value).keySeq());
  };

  Set.intersect = function intersect (sets) {
    sets = Collection(sets).toArray();
    return sets.length
      ? SetPrototype.intersect.apply(Set(sets.pop()), sets)
      : emptySet();
  };

  Set.union = function union (sets) {
    sets = Collection(sets).toArray();
    return sets.length
      ? SetPrototype.union.apply(Set(sets.pop()), sets)
      : emptySet();
  };

  Set.prototype.toString = function toString () {
    return this.__toString('Set {', '}');
  };

  // @pragma Access

  Set.prototype.has = function has (value) {
    return this._map.has(value);
  };

  // @pragma Modification

  Set.prototype.add = function add (value) {
    return updateSet(this, this._map.set(value, value));
  };

  Set.prototype.remove = function remove (value) {
    return updateSet(this, this._map.remove(value));
  };

  Set.prototype.clear = function clear () {
    return updateSet(this, this._map.clear());
  };

  // @pragma Composition

  Set.prototype.map = function map (mapper, context) {
    var this$1 = this;

    var removes = [];
    var adds = [];
    this.forEach(function (value) {
      var mapped = mapper.call(context, value, value, this$1);
      if (mapped !== value) {
        removes.push(value);
        adds.push(mapped);
      }
    });
    return this.withMutations(function (set) {
      removes.forEach(function (value) { return set.remove(value); });
      adds.forEach(function (value) { return set.add(value); });
    });
  };

  Set.prototype.union = function union () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    iters = iters.filter(function (x) { return x.size !== 0; });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function (set) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetCollection$$1(iters[ii]).forEach(function (value) { return set.add(value); });
      }
    });
  };

  Set.prototype.intersect = function intersect () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function (iter) { return SetCollection$$1(iter); });
    var toRemove = [];
    this.forEach(function (value) {
      if (!iters.every(function (iter) { return iter.includes(value); })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.subtract = function subtract () {
    var iters = [], len = arguments.length;
    while ( len-- ) iters[ len ] = arguments[ len ];

    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function (iter) { return SetCollection$$1(iter); });
    var toRemove = [];
    this.forEach(function (value) {
      if (iters.some(function (iter) { return iter.includes(value); })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function (set) {
      toRemove.forEach(function (value) {
        set.remove(value);
      });
    });
  };

  Set.prototype.sort = function sort (comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator));
  };

  Set.prototype.sortBy = function sortBy (mapper, comparator) {
    // Late binding
    return OrderedSet(sortFactory(this, comparator, mapper));
  };

  Set.prototype.wasAltered = function wasAltered () {
    return this._map.wasAltered();
  };

  Set.prototype.__iterate = function __iterate (fn, reverse) {
    var this$1 = this;

    return this._map.__iterate(function (k) { return fn(k, k, this$1); }, reverse);
  };

  Set.prototype.__iterator = function __iterator (type, reverse) {
    return this._map.__iterator(type, reverse);
  };

  Set.prototype.__ensureOwner = function __ensureOwner (ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };

  return Set;
}(SetCollection));

Set.isSet = isSet;

var SetPrototype = Set.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype['@@transducer/init'] = SetPrototype.asMutable = asMutable;
SetPrototype['@@transducer/step'] = function(result, arr) {
  return result.add(arr);
};
SetPrototype['@@transducer/result'] = function(obj) {
  return obj.asImmutable();
};

SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;

function updateSet(set, newMap) {
  if (set.__ownerID) {
    set.size = newMap.size;
    set._map = newMap;
    return set;
  }
  return newMap === set._map
    ? set
    : newMap.size === 0
      ? set.__empty()
      : set.__make(newMap);
}

function makeSet(map, ownerID) {
  var set = Object.create(SetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}

/**
 * Returns a lazy seq of nums from start (inclusive) to end
 * (exclusive), by step, where start defaults to 0, step to 1, and end to
 * infinity. When start is equal to end, returns empty list.
 */
var Range = /*@__PURE__*/(function (IndexedSeq$$1) {
  function Range(start, end, step) {
    if (!(this instanceof Range)) {
      return new Range(start, end, step);
    }
    invariant(step !== 0, 'Cannot step a Range by 0');
    start = start || 0;
    if (end === undefined) {
      end = Infinity;
    }
    step = step === undefined ? 1 : Math.abs(step);
    if (end < start) {
      step = -step;
    }
    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }

  if ( IndexedSeq$$1 ) Range.__proto__ = IndexedSeq$$1;
  Range.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  Range.prototype.constructor = Range;

  Range.prototype.toString = function toString () {
    if (this.size === 0) {
      return 'Range []';
    }
    return (
      'Range [ ' +
      this._start +
      '...' +
      this._end +
      (this._step !== 1 ? ' by ' + this._step : '') +
      ' ]'
    );
  };

  Range.prototype.get = function get (index, notSetValue) {
    return this.has(index)
      ? this._start + wrapIndex(this, index) * this._step
      : notSetValue;
  };

  Range.prototype.includes = function includes (searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return (
      possibleIndex >= 0 &&
      possibleIndex < this.size &&
      possibleIndex === Math.floor(possibleIndex)
    );
  };

  Range.prototype.slice = function slice (begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range(0, 0);
    }
    return new Range(
      this.get(begin, this._end),
      this.get(end, this._end),
      this._step
    );
  };

  Range.prototype.indexOf = function indexOf (searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.size) {
        return index;
      }
    }
    return -1;
  };

  Range.prototype.lastIndexOf = function lastIndexOf (searchValue) {
    return this.indexOf(searchValue);
  };

  Range.prototype.__iterate = function __iterate (fn, reverse) {
    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;
    while (i !== size) {
      if (fn(value, reverse ? size - ++i : i++, this) === false) {
        break;
      }
      value += reverse ? -step : step;
    }
    return i;
  };

  Range.prototype.__iterator = function __iterator (type, reverse) {
    var size = this.size;
    var step = this._step;
    var value = reverse ? this._start + (size - 1) * step : this._start;
    var i = 0;
    return new Iterator(function () {
      if (i === size) {
        return iteratorDone();
      }
      var v = value;
      value += reverse ? -step : step;
      return iteratorValue(type, reverse ? size - ++i : i++, v);
    });
  };

  Range.prototype.equals = function equals (other) {
    return other instanceof Range
      ? this._start === other._start &&
          this._end === other._end &&
          this._step === other._step
      : deepEqual(this, other);
  };

  return Range;
}(IndexedSeq));

var EMPTY_RANGE;

function getIn(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;
  while (i !== keyPath.length) {
    collection = get(collection, keyPath[i++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}

function getIn$1(searchKeyPath, notSetValue) {
  return getIn(this, searchKeyPath, notSetValue);
}

function hasIn(collection, keyPath) {
  return getIn(collection, keyPath, NOT_SET) !== NOT_SET;
}

function hasIn$1(searchKeyPath) {
  return hasIn(this, searchKeyPath);
}

function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function (v, k) {
    object[k] = v;
  });
  return object;
}

// Note: all of these methods are deprecated.
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;

Collection.Iterator = Iterator;

mixin(Collection, {
  // ### Conversion to other types

  toArray: function toArray() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i = 0;
    this.__iterate(function (v, k) {
      // Keyed collections produce an array of tuples.
      array[i++] = useTuples ? [k, v] : v;
    });
    return array;
  },

  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },

  toJS: function toJS$1() {
    return toJS(this);
  },

  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },

  toMap: function toMap() {
    // Use Late Binding here to solve the circular dependency.
    return Map(this.toKeyedSeq());
  },

  toObject: toObject,

  toOrderedMap: function toOrderedMap() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedMap(this.toKeyedSeq());
  },

  toOrderedSet: function toOrderedSet() {
    // Use Late Binding here to solve the circular dependency.
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },

  toSet: function toSet() {
    // Use Late Binding here to solve the circular dependency.
    return Set(isKeyed(this) ? this.valueSeq() : this);
  },

  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },

  toSeq: function toSeq() {
    return isIndexed(this)
      ? this.toIndexedSeq()
      : isKeyed(this)
        ? this.toKeyedSeq()
        : this.toSetSeq();
  },

  toStack: function toStack() {
    // Use Late Binding here to solve the circular dependency.
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },

  toList: function toList() {
    // Use Late Binding here to solve the circular dependency.
    return List(isKeyed(this) ? this.valueSeq() : this);
  },

  // ### Common JavaScript methods and properties

  toString: function toString() {
    return '[Collection]';
  },

  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return (
      head +
      ' ' +
      this.toSeq()
        .map(this.__toStringMapper)
        .join(', ') +
      ' ' +
      tail
    );
  },

  // ### ES6 Collection methods (ES6 Array and Map)

  concat: function concat() {
    var values = [], len = arguments.length;
    while ( len-- ) values[ len ] = arguments[ len ];

    return reify(this, concatFactory(this, values));
  },

  includes: function includes(searchValue) {
    return this.some(function (value) { return is(value, searchValue); });
  },

  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },

  every: function every(predicate, context) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function (v, k, c) {
      if (!predicate.call(context, v, k, c)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },

  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, true));
  },

  find: function find(predicate, context, notSetValue) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[1] : notSetValue;
  },

  forEach: function forEach(sideEffect, context) {
    assertNotInfinite(this.size);
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  },

  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== undefined ? '' + separator : ',';
    var joined = '';
    var isFirst = true;
    this.__iterate(function (v) {
      isFirst ? (isFirst = false) : (joined += separator);
      joined += v !== null && v !== undefined ? v.toString() : '';
    });
    return joined;
  },

  keys: function keys() {
    return this.__iterator(ITERATE_KEYS);
  },

  map: function map(mapper, context) {
    return reify(this, mapFactory(this, mapper, context));
  },

  reduce: function reduce$1(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      false
    );
  },

  reduceRight: function reduceRight(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      true
    );
  },

  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },

  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },

  some: function some(predicate, context) {
    return !this.every(not(predicate), context);
  },

  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },

  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },

  // ### More sequential methods

  butLast: function butLast() {
    return this.slice(0, -1);
  },

  isEmpty: function isEmpty() {
    return this.size !== undefined ? this.size === 0 : !this.some(function () { return true; });
  },

  count: function count(predicate, context) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context) : this
    );
  },

  countBy: function countBy(grouper, context) {
    return countByFactory(this, grouper, context);
  },

  equals: function equals(other) {
    return deepEqual(this, other);
  },

  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      // We cache as an entries array, so we can just return the cache!
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection
      .toSeq()
      .map(entryMapper)
      .toIndexedSeq();
    entriesSequence.fromEntrySeq = function () { return collection.toSeq(); };
    return entriesSequence;
  },

  filterNot: function filterNot(predicate, context) {
    return this.filter(not(predicate), context);
  },

  findEntry: function findEntry(predicate, context, notSetValue) {
    var found = notSetValue;
    this.__iterate(function (v, k, c) {
      if (predicate.call(context, v, k, c)) {
        found = [k, v];
        return false;
      }
    });
    return found;
  },

  findKey: function findKey(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry && entry[0];
  },

  findLast: function findLast(predicate, context, notSetValue) {
    return this.toKeyedSeq()
      .reverse()
      .find(predicate, context, notSetValue);
  },

  findLastEntry: function findLastEntry(predicate, context, notSetValue) {
    return this.toKeyedSeq()
      .reverse()
      .findEntry(predicate, context, notSetValue);
  },

  findLastKey: function findLastKey(predicate, context) {
    return this.toKeyedSeq()
      .reverse()
      .findKey(predicate, context);
  },

  first: function first(notSetValue) {
    return this.find(returnTrue, null, notSetValue);
  },

  flatMap: function flatMap(mapper, context) {
    return reify(this, flatMapFactory(this, mapper, context));
  },

  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },

  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },

  get: function get(searchKey, notSetValue) {
    return this.find(function (_, key) { return is(key, searchKey); }, undefined, notSetValue);
  },

  getIn: getIn$1,

  groupBy: function groupBy(grouper, context) {
    return groupByFactory(this, grouper, context);
  },

  has: function has(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },

  hasIn: hasIn$1,

  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === 'function' ? iter : Collection(iter);
    return this.every(function (value) { return iter.includes(value); });
  },

  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === 'function' ? iter : Collection(iter);
    return iter.isSubset(this);
  },

  keyOf: function keyOf(searchValue) {
    return this.findKey(function (value) { return is(value, searchValue); });
  },

  keySeq: function keySeq() {
    return this.toSeq()
      .map(keyMapper)
      .toIndexedSeq();
  },

  last: function last(notSetValue) {
    return this.toSeq()
      .reverse()
      .first(notSetValue);
  },

  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq()
      .reverse()
      .keyOf(searchValue);
  },

  max: function max(comparator) {
    return maxFactory(this, comparator);
  },

  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },

  min: function min(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  },

  minBy: function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  },

  rest: function rest() {
    return this.slice(1);
  },

  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },

  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },

  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, true));
  },

  skipUntil: function skipUntil(predicate, context) {
    return this.skipWhile(not(predicate), context);
  },

  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },

  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },

  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },

  takeWhile: function takeWhile(predicate, context) {
    return reify(this, takeWhileFactory(this, predicate, context));
  },

  takeUntil: function takeUntil(predicate, context) {
    return this.takeWhile(not(predicate), context);
  },

  update: function update(fn) {
    return fn(this);
  },

  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },

  // ### Hashable Object

  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  },

  // ### Internal

  // abstract __iterate(fn, reverse)

  // abstract __iterator(type, reverse)
});

var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;

mixin(KeyedCollection, {
  // ### More sequential methods

  flip: function flip() {
    return reify(this, flipFactory(this));
  },

  mapEntries: function mapEntries(mapper, context) {
    var this$1 = this;

    var iterations = 0;
    return reify(
      this,
      this.toSeq()
        .map(function (v, k) { return mapper.call(context, [k, v], iterations++, this$1); })
        .fromEntrySeq()
    );
  },

  mapKeys: function mapKeys(mapper, context) {
    var this$1 = this;

    return reify(
      this,
      this.toSeq()
        .flip()
        .map(function (k, v) { return mapper.call(context, k, v, this$1); })
        .flip()
    );
  },
});

var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function (v, k) { return quoteString(k) + ': ' + quoteString(v); };

mixin(IndexedCollection, {
  // ### Conversion to other types

  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, false);
  },

  // ### ES6 Collection methods (ES6 Array and Map)

  filter: function filter(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, false));
  },

  findIndex: function findIndex(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[0] : -1;
  },

  indexOf: function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === undefined ? -1 : key;
  },

  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === undefined ? -1 : key;
  },

  reverse: function reverse() {
    return reify(this, reverseFactory(this, false));
  },

  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },

  splice: function splice(index, removeNum /*, ...values*/) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
      return this;
    }
    // If index is negative, it should resolve relative to the size of the
    // collection. However size may be expensive to compute if not cached, so
    // only call count() if the number is in fact negative.
    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(
      this,
      numArgs === 1
        ? spliced
        : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
    );
  },

  // ### More collection methods

  findLastIndex: function findLastIndex(predicate, context) {
    var entry = this.findLastEntry(predicate, context);
    return entry ? entry[0] : -1;
  },

  first: function first(notSetValue) {
    return this.get(0, notSetValue);
  },

  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },

  get: function get(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 ||
      (this.size === Infinity || (this.size !== undefined && index > this.size))
      ? notSetValue
      : this.find(function (_, key) { return key === index; }, undefined, notSetValue);
  },

  has: function has(index) {
    index = wrapIndex(this, index);
    return (
      index >= 0 &&
      (this.size !== undefined
        ? this.size === Infinity || index < this.size
        : this.indexOf(index) !== -1)
    );
  },

  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },

  interleave: function interleave(/*...collections*/) {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },

  keySeq: function keySeq() {
    return Range(0, this.size);
  },

  last: function last(notSetValue) {
    return this.get(-1, notSetValue);
  },

  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, false));
  },

  zip: function zip(/*, ...collections */) {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },

  zipAll: function zipAll(/*, ...collections */) {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },

  zipWith: function zipWith(zipper /*, ...collections */) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  },
});

var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;

mixin(SetCollection, {
  // ### ES6 Collection methods (ES6 Array and Map)

  get: function get(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },

  includes: function includes(value) {
    return this.has(value);
  },

  // ### More sequential methods

  keySeq: function keySeq() {
    return this.valueSeq();
  },
});

SetCollection.prototype.has = CollectionPrototype.includes;
SetCollection.prototype.contains = SetCollection.prototype.includes;

// Mixin subclasses

mixin(KeyedSeq, KeyedCollection.prototype);
mixin(IndexedSeq, IndexedCollection.prototype);
mixin(SetSeq, SetCollection.prototype);

// #pragma Helper functions

function reduce(collection, reducer, reduction, context, useFirst, reverse) {
  assertNotInfinite(collection.size);
  collection.__iterate(function (v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  }, reverse);
  return reduction;
}

function keyMapper(v, k) {
  return k;
}

function entryMapper(v, k) {
  return [k, v];
}

function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}

function defaultZipper() {
  return arrCopy(arguments);
}

function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed
      ? ordered
        ? function (v, k) {
            h = (31 * h + hashMerge(hash(v), hash(k))) | 0;
          }
        : function (v, k) {
            h = (h + hashMerge(hash(v), hash(k))) | 0;
          }
      : ordered
        ? function (v) {
            h = (31 * h + hash(v)) | 0;
          }
        : function (v) {
            h = (h + hash(v)) | 0;
          }
  );
  return murmurHashOfSize(size, h);
}

function murmurHashOfSize(size, h) {
  h = imul(h, 0xcc9e2d51);
  h = imul((h << 15) | (h >>> -15), 0x1b873593);
  h = imul((h << 13) | (h >>> -13), 5);
  h = ((h + 0xe6546b64) | 0) ^ size;
  h = imul(h ^ (h >>> 16), 0x85ebca6b);
  h = imul(h ^ (h >>> 13), 0xc2b2ae35);
  h = smi(h ^ (h >>> 16));
  return h;
}

function hashMerge(a, b) {
  return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0; // int
}

var OrderedSet = /*@__PURE__*/(function (Set$$1) {
  function OrderedSet(value) {
    return value === null || value === undefined
      ? emptyOrderedSet()
      : isOrderedSet(value)
        ? value
        : emptyOrderedSet().withMutations(function (set) {
            var iter = SetCollection(value);
            assertNotInfinite(iter.size);
            iter.forEach(function (v) { return set.add(v); });
          });
  }

  if ( Set$$1 ) OrderedSet.__proto__ = Set$$1;
  OrderedSet.prototype = Object.create( Set$$1 && Set$$1.prototype );
  OrderedSet.prototype.constructor = OrderedSet;

  OrderedSet.of = function of (/*...values*/) {
    return this(arguments);
  };

  OrderedSet.fromKeys = function fromKeys (value) {
    return this(KeyedCollection(value).keySeq());
  };

  OrderedSet.prototype.toString = function toString () {
    return this.__toString('OrderedSet {', '}');
  };

  return OrderedSet;
}(Set));

OrderedSet.isOrderedSet = isOrderedSet;

var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;

OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;

function makeOrderedSet(map, ownerID) {
  var set = Object.create(OrderedSetPrototype);
  set.size = map ? map.size : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}

var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return (
    EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()))
  );
}

var Record = function Record(defaultValues, name) {
  var hasInitialized;

  var RecordType = function Record(values) {
    var this$1 = this;

    if (values instanceof RecordType) {
      return values;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys = Object.keys(defaultValues);
      var indices = (RecordTypePrototype._indices = {});
      // Deprecated: left to attempt not to break any external code which
      // relies on a ._name property existing on record instances.
      // Use Record.getDescriptiveName() instead
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i = 0; i < keys.length; i++) {
        var propName = keys[i];
        indices[propName] = i;
        if (RecordTypePrototype[propName]) {
          /* eslint-disable no-console */
          typeof console === 'object' &&
            console.warn &&
            console.warn(
              'Cannot define ' +
                recordName(this) +
                ' with property "' +
                propName +
                '" since that property name is part of the Record API.'
            );
          /* eslint-enable no-console */
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = undefined;
    this._values = List().withMutations(function (l) {
      l.setSize(this$1._keys.length);
      KeyedCollection(values).forEach(function (v, k) {
        l.set(this$1._indices[k], v === this$1._defaultValues[k] ? undefined : v);
      });
    });
  };

  var RecordTypePrototype = (RecordType.prototype = Object.create(
    RecordPrototype
  ));
  RecordTypePrototype.constructor = RecordType;

  if (name) {
    RecordType.displayName = name;
  }

  return RecordType;
};

Record.prototype.toString = function toString () {
  var str = recordName(this) + ' { ';
  var keys = this._keys;
  var k;
  for (var i = 0, l = keys.length; i !== l; i++) {
    k = keys[i];
    str += (i ? ', ' : '') + k + ': ' + quoteString(this.get(k));
  }
  return str + ' }';
};

Record.prototype.equals = function equals (other) {
  return (
    this === other ||
    (other &&
      this._keys === other._keys &&
      recordSeq(this).equals(recordSeq(other)))
  );
};

Record.prototype.hashCode = function hashCode () {
  return recordSeq(this).hashCode();
};

// @pragma Access

Record.prototype.has = function has (k) {
  return this._indices.hasOwnProperty(k);
};

Record.prototype.get = function get (k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }
  var index = this._indices[k];
  var value = this._values.get(index);
  return value === undefined ? this._defaultValues[k] : value;
};

// @pragma Modification

Record.prototype.set = function set (k, v) {
  if (this.has(k)) {
    var newValues = this._values.set(
      this._indices[k],
      v === this._defaultValues[k] ? undefined : v
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
};

Record.prototype.remove = function remove (k) {
  return this.set(k);
};

Record.prototype.clear = function clear () {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
};

Record.prototype.wasAltered = function wasAltered () {
  return this._values.wasAltered();
};

Record.prototype.toSeq = function toSeq () {
  return recordSeq(this);
};

Record.prototype.toJS = function toJS$1 () {
  return toJS(this);
};

Record.prototype.entries = function entries () {
  return this.__iterator(ITERATE_ENTRIES);
};

Record.prototype.__iterator = function __iterator (type, reverse) {
  return recordSeq(this).__iterator(type, reverse);
};

Record.prototype.__iterate = function __iterate (fn, reverse) {
  return recordSeq(this).__iterate(fn, reverse);
};

Record.prototype.__ensureOwner = function __ensureOwner (ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
};

Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn$1;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge;
RecordPrototype.mergeWith = mergeWith;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep$1;
RecordPrototype.mergeDeepWith = mergeDeepWith$1;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn$1;
RecordPrototype.update = update$1;
RecordPrototype.updateIn = updateIn$1;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject =
  CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function() {
  return this.toString();
};

function makeRecord(likeRecord, values, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values;
  record.__ownerID = ownerID;
  return record;
}

function recordName(record) {
  return record.constructor.displayName || record.constructor.name || 'Record';
}

function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function (k) { return [k, record.get(k)]; }));
}

function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, 'Cannot set on an immutable record.');
        this.set(name, value);
      },
    });
  } catch (error) {
    // Object.defineProperty failed. Probably IE8.
  }
}

/**
 * Returns a lazy Seq of `value` repeated `times` times. When `times` is
 * undefined, returns an infinite sequence of `value`.
 */
var Repeat = /*@__PURE__*/(function (IndexedSeq$$1) {
  function Repeat(value, times) {
    if (!(this instanceof Repeat)) {
      return new Repeat(value, times);
    }
    this._value = value;
    this.size = times === undefined ? Infinity : Math.max(0, times);
    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }
      EMPTY_REPEAT = this;
    }
  }

  if ( IndexedSeq$$1 ) Repeat.__proto__ = IndexedSeq$$1;
  Repeat.prototype = Object.create( IndexedSeq$$1 && IndexedSeq$$1.prototype );
  Repeat.prototype.constructor = Repeat;

  Repeat.prototype.toString = function toString () {
    if (this.size === 0) {
      return 'Repeat []';
    }
    return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
  };

  Repeat.prototype.get = function get (index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };

  Repeat.prototype.includes = function includes (searchValue) {
    return is(this._value, searchValue);
  };

  Repeat.prototype.slice = function slice (begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size)
      ? this
      : new Repeat(
          this._value,
          resolveEnd(end, size) - resolveBegin(begin, size)
        );
  };

  Repeat.prototype.reverse = function reverse () {
    return this;
  };

  Repeat.prototype.indexOf = function indexOf (searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  };

  Repeat.prototype.lastIndexOf = function lastIndexOf (searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }
    return -1;
  };

  Repeat.prototype.__iterate = function __iterate (fn, reverse) {
    var size = this.size;
    var i = 0;
    while (i !== size) {
      if (fn(this._value, reverse ? size - ++i : i++, this) === false) {
        break;
      }
    }
    return i;
  };

  Repeat.prototype.__iterator = function __iterator (type, reverse) {
    var this$1 = this;

    var size = this.size;
    var i = 0;
    return new Iterator(
      function () { return i === size
          ? iteratorDone()
          : iteratorValue(type, reverse ? size - ++i : i++, this$1._value); }
    );
  };

  Repeat.prototype.equals = function equals (other) {
    return other instanceof Repeat
      ? is(this._value, other._value)
      : deepEqual(other);
  };

  return Repeat;
}(IndexedSeq));

var EMPTY_REPEAT;

function fromJS(value, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value,
    '',
    converter && converter.length > 2 ? [] : undefined,
    { '': value }
  );
}

function fromJSWith(stack, converter, value, key, keyPath, parentValue) {
  var toSeq = Array.isArray(value)
    ? IndexedSeq
    : isPlainObj(value)
      ? KeyedSeq
      : null;
  if (toSeq) {
    if (~stack.indexOf(value)) {
      throw new TypeError('Cannot convert circular structure to Immutable');
    }
    stack.push(value);
    keyPath && key !== '' && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      toSeq(value).map(function (v, k) { return fromJSWith(stack, converter, v, k, keyPath, value); }
      ),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value;
}

function defaultConverter(k, v) {
  return isKeyed(v) ? v.toMap() : v.toList();
}

var version = "4.0.0-rc.11";

var Immutable = {
  version: version,

  Collection: Collection,
  // Note: Iterable is deprecated
  Iterable: Collection,

  Seq: Seq,
  Map: Map,
  OrderedMap: OrderedMap,
  List: List,
  Stack: Stack,
  Set: Set,
  OrderedSet: OrderedSet,

  Record: Record,
  Range: Range,
  Repeat: Repeat,

  is: is,
  fromJS: fromJS,
  hash: hash,

  isImmutable: isImmutable,
  isCollection: isCollection,
  isKeyed: isKeyed,
  isIndexed: isIndexed,
  isAssociative: isAssociative,
  isOrdered: isOrdered,
  isValueObject: isValueObject,
  isSeq: isSeq,
  isList: isList,
  isMap: isMap,
  isOrderedMap: isOrderedMap,
  isStack: isStack,
  isSet: isSet,
  isOrderedSet: isOrderedSet,
  isRecord: isRecord,

  get: get,
  getIn: getIn,
  has: has,
  hasIn: hasIn,
  merge: merge$1,
  mergeDeep: mergeDeep,
  mergeWith: mergeWith$1,
  mergeDeepWith: mergeDeepWith,
  remove: remove,
  removeIn: removeIn,
  set: set,
  setIn: setIn,
  update: update,
  updateIn: updateIn,
};

// Note: Iterable is deprecated
var Iterable = Collection;

/* harmony default export */ __webpack_exports__["default"] = (Immutable);



/***/ })

/******/ });
})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9kaXN0L2xpYi9hdXRvY29tcGxldGVXaWRnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9saWIvZmFjZXQuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9saWIvZmV0Y2hDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9saWIvcGFnZS5qcyIsIndlYnBhY2s6Ly8vLi9kaXN0L2xpYi9wYWdlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9saWIvc2VhcmNoUmVzdWx0LmpzIiwid2VicGFjazovLy8uL2Rpc3QvbGliL3NtYXJ0U2VhcmNoLmpzIiwid2VicGFjazovLy8uL2Rpc3QvbGliL3RlbXBsYXRlcy9kaWRZb3VNZWFuVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9saWIvdGVtcGxhdGVzL3BhZ2luYXRpb25UZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9kaXN0L2xpYi90ZW1wbGF0ZXMvc2VhcmNoUmVzdWx0VGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9saWIvdXJsUGFyYW1MaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYWNvbmpzL2Rpc3QvQmFjb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ltbXV0YWJsZS9kaXN0L2ltbXV0YWJsZS5lcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw0QkFBNEIsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx1REFBdUQsNkNBQTZDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEJBQThCLFVBQVUsRUFBRTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsMkJBQTJCLGFBQWEsR0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQixxQkFBcUIsRUFBRTtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsa0JBQWtCLEVBQUUsK0NBQStDLGNBQWMsRUFBRTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQ0FBZ0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdDQUFnQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsVUFBVSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9DQUFvQyxFQUFFO0FBQ2pGLDJDQUEyQyw2REFBNkQ7QUFDeEc7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQkFBK0IsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLHlCQUF5QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxvQkFBb0IsVUFBVSxFQUFFO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGVBQWUsRUFBRTtBQUN4RSx3RUFBd0UsaUJBQWlCLEVBQUUsMkJBQTJCLGlCQUFpQixFQUFFO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQSw0REFBNEQsbUJBQW1CLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWUsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLG9CQUFvQixFQUFFO0FBQ3BHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLEVBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYSxFQUFFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsc0NBQXNDO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbURBQW1ELEVBQUU7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUMsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usa0NBQWtDLEVBQUU7QUFDeEcsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBLEtBQUssRUFBRSxFQUFFO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0Esd0RBQXdELDBCQUEwQixFQUFFO0FBQ3BGO0FBQ0EsK0RBQStELHdCQUF3QixFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysc0NBQXNDLEVBQUUsdUNBQXVDLGdDQUFnQyxFQUFFLDBCQUEwQixpQkFBaUIsRUFBRTtBQUNoUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSwwQkFBMEIsRUFBRTtBQUN6RyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQixFQUFFO0FBQ25FO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxzQ0FBc0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQkFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVFQUF1RSxvQkFBb0IsRUFBRTtBQUM3RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsS0FBSyxlQUFlLE9BQU8sZ0NBQWdDO0FBQzlFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJCQUEyQixhQUFhLEdBQUc7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYyxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DLHFFQUFxRSxzQ0FBc0MsRUFBRTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7O0FBRTFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUUsRUFBRTtBQUNiO0FBQ0E7QUFDQSwwRkFBMEYsOEJBQThCLEVBQUU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLDZCQUE2QjtBQUNuQyxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLHNCQUFzQjtBQUM1QixNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLHNCQUFzQjtBQUM1QixNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELDRCQUE0QjtBQUMvRSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLFNBQVMsRUFBRSxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGVBQWU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0Msb0JBQW9CO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0RBQWtELDJCQUEyQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsK0JBQStCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOEJBQThCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDhCQUE4QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsK0JBQStCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsb0RBQW9EO0FBQ2pJLHVEQUF1RCw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLDZCQUE2QjtBQUNuQyxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLHNCQUFzQjtBQUM1QixNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLHNCQUFzQjtBQUM1QixNQUFNLDRCQUE0QjtBQUNsQyxNQUFNLDRCQUE0QjtBQUNsQyxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELDRCQUE0QjtBQUMvRSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlCQUFpQjtBQUN0RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU07QUFDcEMsNEJBQTRCLE1BQU07QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2REFBNkQsa0JBQWtCO0FBQy9FOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUEsU0FBUyxtQ0FBbUM7QUFDNUMsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQSx1Q0FBdUMscUNBQXFDLEVBQUU7QUFDOUUsa0NBQWtDLFlBQVksRUFBRTtBQUNoRCxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBLHdEQUF3RCxnQ0FBZ0MsRUFBRTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUMsRUFBRTtBQUN6RSw4QkFBOEIsd0NBQXdDLEVBQUU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9DQUFvQyx1QkFBdUIsRUFBRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixpQ0FBaUMsRUFBRTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRkFBMkYsaUJBQWlCO0FBQzVHLGdFQUFnRSxpQkFBaUI7QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnREFBZ0QsRUFBRTtBQUNuRixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7QUFFNUQsQ0FBQzs7Ozs7Ozs7Ozs7OztBQzV1S0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsS0FBSztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZFQUE2RTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEJBQTBCLHFCQUFxQixFQUFFOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsY0FBYyxFQUFFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxnQkFBZ0IsRUFBRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEUsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsS0FBSztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnREFBZ0QsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlDQUF5QyxFQUFFO0FBQzlGO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QixFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHVDQUF1QywrQkFBK0IsRUFBRTtBQUN4RSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwrRUFBK0UsYUFBYSxFQUFFO0FBQzlGLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJCQUEyQjtBQUMzRTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx3Q0FBd0MsMkJBQTJCLEVBQUU7QUFDckUsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLDZCQUE2QixFQUFFO0FBQ3ZFLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBDQUEwQywrQkFBK0IsRUFBRTtBQUMzRSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBMkQsRUFBRTtBQUMzRjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUEyQyxFQUFFO0FBQzNFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwrQ0FBK0M7O0FBRTVHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQixFQUFFO0FBQzdELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUIsRUFBRTtBQUM1RCxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsS0FBSztBQUM3Qzs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCwyQkFBMkIsRUFBRTtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUEyRDtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVlLHdFQUFTLEVBQUM7QUFDbVYiLCJmaWxlIjoic21hcnRzZWFyY2guYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9kaXN0L2xpYi9pbmRleC5qc1wiKTtcbiIsInZhciBfVkVSU0lPTiA9IFZFUlNJT047XG5leHBvcnQgeyBfVkVSU0lPTiBhcyBWRVJTSU9OIH07XG4vKipcbiAqIFRoZSBkZWZhdWx0IEFQSSBlbmRwb2ludCB0byB3aGljaCBhdXRvLWNvbXBsZXRlIGFuZCBzZWFyY2ggcXVlcmllcyBhcmUgc2VudC5cbiAqL1xuZXhwb3J0IHZhciBBUElfRU5EUE9JTlQgPSBcIi92MS9wcmVwYXJlZF9zZWFyY2hcIjtcbi8qKlxuICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gcmVuZGVyIGEgc2luZ2xlIHBhZ2luYXRpb24gZWxlbWVudC4gKlRoZSBkZWZhdWx0IGFsZ29yaXRobSBpczoqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAodmFsdWU6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gKiAgICAgcmV0dXJuIHZhbHVlXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHBhZ2UgdmFsdWUuIFRoZSBmaXJzdCBwYWdlIGNvcnJlc3BvbmRzIHRvIHRoZSB2YWx1ZSAwLlxuICogQHJldHVybnMgVGhlIGdpdmVuIHZhbHVlIHdpdGhvdXQgbW9kaWZpY2F0aW9uLlxuICovXG5leHBvcnQgdmFyIFBBR0lOQVRJT05fRlVOQ1RJT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byByZW5kZXIgYSBzaW5nbGUgc2VhcmNoIHJlc3VsdC4gKlRoZSBkZWZhdWx0IGFsZ29yaXRobSBpczoqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAoZGF0YTogUmVzdWx0LCBoaWdobGlnaHRzOiBIaWdobGlnaHRpbmcpOiBzdHJpbmcgPT4ge1xuICogICAgIHJldHVybiBgPGEgaHJlZj1cIiR7ZGF0YS5saW5rfVwiPlxuICogICAgICAgICAgICAgICA8aDE+JHtkYXRhLnRpdGxlfTwvaDE+XG4gKiAgICAgICAgICAgICAgIDxwPiR7aGlnaGxpZ2h0cy5jb250ZW50fTwvcD5cbiAqICAgICAgICAgICAgIDwvYT5gXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgc2VhcmNoIHJlc3VsdCBpbmZvcm1hdGlvbiBsaWtlIGxpbmsgb3IgdGl0bGUuXG4gKiBAcGFyYW0gaGlnaGxpZ2h0cyBUaGUgY29udGVudCB0byBiZSBkaXNwbGF5ZWQgb24gdGhlIHNlYXJjaCByZXN1bHQgcGFnZS5cbiAqL1xuZXhwb3J0IHZhciBTRUFSQ0hfUkVTVUxUX0ZVTkNUSU9OID0gZnVuY3Rpb24gKGRhdGEsIGhpZ2hsaWdodHMpIHtcbiAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJcIiArIGRhdGEubGluayArIFwiXFxcIj48aDE+XCIgKyBkYXRhLnRpdGxlICsgXCI8L2gxPjxwPlwiICsgaGlnaGxpZ2h0cy5jb250ZW50ICsgXCI8L3A+PC9hPlwiO1xufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gcmVuZGVyIGEgc2luZ2xlICdEaWQgeW91IG1lYW4nIHN1Z2dlc3Rpb24uICpUaGUgZGVmYXVsdCBhbGdvcml0aG0gaXM6KlxuICogYGBgdHlwZXNjcmlwdFxuICogKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICogICAgIHJldHVybiB2YWx1ZVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSBzdWdnZXN0aW9uLlxuICovXG5leHBvcnQgdmFyIERJRF9ZT1VfTUVBTl9GVU5DVElPTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBcIjxzcGFuPlwiICsgdmFsdWUgKyBcIjwvc3Bhbj5cIjtcbn07XG4vKipcbiAqIERlZmF1bHQgdGhyZXNob2xkIG9mIGNoYXJhY3RlcnMgdG8gdHlwZSBiZWZvcmUgdGhlIGZpcnN0IGF1dG9jb21wbGV0ZSByZXF1ZXN0IGlzIHNlbnRcbiAqL1xuZXhwb3J0IHZhciBBVVRPQ09NUExFVEVfREVGQVVMVF9USFJFU0hPTEQgPSAwO1xuLyoqXG4gKiBEZWZhdWx0IENTUyBjbGFzcyBmb3IgdGhlIGF1dG9jb21wbGV0ZSBib3hcbiAqL1xuZXhwb3J0IHZhciBDU1NfQVVUT0NPTVBMRVRFX1dJREdFVCA9IFwic21hcnQtc2VhcmNoLWF1dG9jb21wbGV0ZS13aWRnZXRcIjtcbi8qKlxuICogRGVmYXVsdCBDU1MgY2xhc3MgZm9yIHRoZSBhY3RpdmUgYXV0b2NvbXBsZXRlIGl0ZW1cbiAqL1xuZXhwb3J0IHZhciBDU1NfQVVUT0NPTVBMRVRFX0FDVElWRSA9IFwic21hcnQtc2VhcmNoLWF1dG9jb21wbGV0ZS1hY3RpdmVcIjtcbi8qKlxuICogRGVmYXVsdCBDU1MgY2xhc3MgZm9yIGFuIGF1dG9jb21wbGV0ZSBpdGVtXG4gKi9cbmV4cG9ydCB2YXIgQ1NTX0FVVE9DT01QTEVURV9JVEVNID0gXCJzbWFydC1zZWFyY2gtYXV0b2NvbXBsZXRlLWl0ZW1cIjtcbi8qKlxuICogRGVmYXVsdCBDU1MgY2xhc3MgZm9yIHRoZSBwYWdpbmF0aW9uIHdyYXBwZXIgSFRNTCBlbGVtZW50LlxuICovXG5leHBvcnQgdmFyIENTU19QQUdJTkFUSU9OID0gXCJzbWFydC1zZWFyY2gtcGFnaW5hdGlvblwiO1xuLyoqXG4gKiBEZWZhdWx0IENTUyBjbGFzcyBmb3IgdGhlIHBhZ2luYXRpb24gbmV4dCBidXR0b24uXG4gKi9cbmV4cG9ydCB2YXIgQ1NTX05FWFRfQlVUVE9OID0gXCJzbWFydC1zZWFyY2gtcGFnaW5hdGlvbi1uZXh0XCI7XG4vKipcbiAqIERlZmF1bHQgQ1NTIGNsYXNzIGZvciB0aGUgcGFnaW5hdGlvbiBwcmV2IGJ1dHRvbi5cbiAqL1xuZXhwb3J0IHZhciBDU1NfUFJFVl9CVVRUT04gPSBcInNtYXJ0LXNlYXJjaC1wYWdpbmF0aW9uLXByZXZcIjtcbi8qKlxuICogRGVmYXVsdCBDU1MgY2xhc3MgZm9yIHRoZSBwYWdpbmF0aW9uIHBhZ2UgYnV0dG9ucy5cbiAqL1xuZXhwb3J0IHZhciBDU1NfUEFHRV9CVVRUT04gPSBcInNtYXJ0LXNlYXJjaC1wYWdpbmF0aW9uLXBhZ2VcIjtcbi8qKlxuICogRGVmYXVsdCBDU1MgY2xhc3MgZm9yIHRoZSBwYWdpbmF0aW9uIGN1cnJlbnQgcGFnZSBidXR0b24uXG4gKi9cbmV4cG9ydCB2YXIgQ1NTX0NVUlJFTlRfUEFHRSA9IFwic21hcnQtc2VhcmNoLXBhZ2luYXRpb24tY3VycmVudFwiO1xuLyoqXG4gKiBEZWZhdWx0IENTUyBjbGFzcyBmb3IgdGhlIHNlYXJjaCByZXN1bHQgd3JhcHBlciBIVE1MIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCB2YXIgQ1NTX1NFQVJDSF9SRVNVTFRfV1JBUFBFUiA9IFwic21hcnQtc2VhcmNoLXNlYXJjaC1yZXN1bHRzXCI7XG4vKipcbiAqIERlZmF1bHQgQ1NTIGNsYXNzIGZvciBhIHNpbmdsZSBzZWFyY2ggcmVzdWx0IGluc2lkZSB0aGUgd3JhcHBlci5cbiAqL1xuZXhwb3J0IHZhciBDU1NfU0VBUkNIX1JFU1VMVF9FTEVNRU5UID0gXCJzbWFydC1zZWFyY2gtc2VhcmNoLXJlc3VsdFwiO1xuLyoqXG4gKiBEZWZhdWx0IENTUyBjbGFzcyBmb3IgdGhlIHNpbmdsZSAnRGlkIHlvdSBtZWFuJyB3cmFwcGVyLlxuICovXG5leHBvcnQgdmFyIENTU19ESURfWU9VX01FQU5fV1JBUFBFUiA9IFwic21hcnQtc2VhcmNoLWRpZC15b3UtbWVhbi13cmFwcGVyXCI7XG4vKipcbiAqIERlZmF1bHQgQ1NTIGNsYXNzIGZvciBhIHNpbmdsZSAnRGlkIHlvdSBtZWFuJyBzdWdnZXN0aW9uLlxuICovXG5leHBvcnQgdmFyIENTU19ESURfWU9VX01FQU5fRUxFTUVOVCA9IFwic21hcnQtc2VhcmNoLWRpZC15b3UtbWVhbi1lbGVtZW50XCI7XG4iLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuaW1wb3J0ICogYXMgQmFjb24gZnJvbSBcImJhY29uanNcIjtcbmltcG9ydCB7IENTU19BVVRPQ09NUExFVEVfV0lER0VULCBDU1NfQVVUT0NPTVBMRVRFX0FDVElWRSwgQ1NTX0FVVE9DT01QTEVURV9JVEVNLCBBVVRPQ09NUExFVEVfREVGQVVMVF9USFJFU0hPTEQgfSBmcm9tIFwiLi4vZGVmYXVsdHNcIjtcbi8qKiBAaGlkZGVuICovXG52YXIgU1BFQ0lBTF9LRVlTID0gW1wiRW50ZXJcIiwgXCJBcnJvd1VwXCIsIFwiQXJyb3dEb3duXCJdO1xuLyoqXG4gKiAgVGhpcyBldmVudCBpcyB0cmlnZ2VyZWQgdGhlIG1vbWVudCB0aGUgYm94IGlzIGRpc3BsYXllZC5cbiAqL1xudmFyIGFwcGVhcmVkRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJzbWFydC1zZWFyY2gtd2lkZ2V0LWFwcGVhcmVkXCIsIHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG59KTtcbi8qKlxuICogIFRoaXMgZXZlbnQgaXMgdHJpZ2dlcmVkIHRoZSBtb21lbnQgdGhlIGJveCBpcyBoaWRkZW4uXG4gKi9cbnZhciBoaWRkZW5FdmVudCA9IG5ldyBDdXN0b21FdmVudChcInNtYXJ0LXNlYXJjaC13aWRnZXQtaGlkZGVuXCIsIHtcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG59KTtcbi8qKlxuICogVGhlIGhhbmRsZXIgbGlzdGVuaW5nIHRvIHRoaXMgZXZlbnQgd2lsbCBjbGVhciBhbmQgaGlkZSB0aGUgYXV0b2NvbXBsZXRlIHdpZGdldC5cbiAqL1xudmFyIGlucHV0RW1wdHkgPSBuZXcgQ3VzdG9tRXZlbnQoXCJzbWFydC1zZWFyY2gtaW5wdXQtZW1wdHlcIiwge1xuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbn0pO1xuLyoqXG4gKiBVSS1XaWRnZXQgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYW4gaW5wdXQgZWxlbWVudC4gRmV0Y2hlcyBhbmQgZGlzcGxheXMgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHJlbmRlciB5b3VyIG93biBIVE1MIGFuZCBqdXN0IGZldGNoIHRoZSBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbnMsIHVzZSBbW1NtYXJ0U2VhcmNoLmZldGNoQXV0b2NvbXBsZXRlTGlzdF1dXG4gKiBpbnN0ZWFkLlxuICovXG52YXIgQXV0b2NvbXBsZXRlV2lkZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhdXRvY29tcGxldGVDbGllbnQgVGhlIFtbRmV0Y2hDbGllbnRdXSB1c2VkIHRvIHNlbmQgQVBJIGNhbGxzIGFnYWluc3QgdGhlIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgdXNlZCB0byBtb2RpZnkgdGhlIGF1dG9jb21wbGV0ZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1dG9jb21wbGV0ZVdpZGdldChhdXRvY29tcGxldGVDbGllbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVDbGllbnQgPSBhdXRvY29tcGxldGVDbGllbnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gbWVhbnQgdG8gYmUgY2FsbGVkIGF0IGV2ZXJ5IGtleXN0cm9rZSB0aGF0IHJldHVybnMgYSBsaXN0IG9mIHN1Z2dlc3Rpb25zIGZvciBhdXRvY29tcGxldGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcmVmaXggQWxsIGNoYXJhY3RlcnMgdHlwZWQgc28gZmFyLCBhbGwgc3RyaW5ncyByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0aGlzIHByZWZpeC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaGlnaGxpZ2h0ZWQgb3IgZGVmYXVsdCBhdXRvY29tcGxldGUgbGlzdCBmb3IgdGhlIGdpdmVuIHByZWZpeCwgY29udGFpbnMgYXQgbW9zdCA1IGVsZW1lbnRzLlxuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZVdpZGdldC5wcm90b3R5cGUuZ2V0QXV0b2NvbXBsZXRlTGlzdCA9IGZ1bmN0aW9uIChwcmVmaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywgYXV0b2NvbXBsZXRlTGlzdCwgZXJyb3JfMTtcbiAgICAgICAgICAgIHZhciBfYztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2phbmt5IGhhY2sgdG8gd29yayBhcm91bmQgYSB0eXBlZG9jIHByb2JsZW0gd2l0aCBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHsgbGFuZ3VhZ2U6IG9wdGlvbnMubGFuZ3VhZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZUNsaWVudC5wYXJhbWV0ZXJMaXN0ID0gKF9jID0gdGhpcy5hdXRvY29tcGxldGVDbGllbnQucGFyYW1ldGVyTGlzdCkuYWRkT3JVcGRhdGUuYXBwbHkoX2MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmF1dG9jb21wbGV0ZUNsaWVudC5mZXRjaCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlTGlzdCA9IChfZC5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfYiA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYXV0b2NvbXBsZXRlTGlzdC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIF90aGlzLmhpZ2hsaWdodFByZWZpeChpdGVtLCBwcmVmaXgpOyB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYXV0b2NvbXBsZXRlTGlzdF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXCIsIGVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFtcIlwiXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgcHJlZml4ICh0eXBlZCBieSB0aGUgdXNlciBpbiB0aGUgaW5wdXQgZmllbGQpIHVzaW5nIHRoZSBodG1sIHN0cm9uZyB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbSBBbiBpdGVtIGZyb20gdGhlIGxpc3Qgb2YgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zLlxuICAgICAqIEBwYXJhbSBwcmVmaXggVGhlIHByZWZpeCB0byBoaWdobGlnaHQuXG4gICAgICovXG4gICAgQXV0b2NvbXBsZXRlV2lkZ2V0LnByb3RvdHlwZS5oaWdobGlnaHRQcmVmaXggPSBmdW5jdGlvbiAoaXRlbSwgcHJlZml4KSB7XG4gICAgICAgIHZhciBzdWZmaXggPSBpdGVtLnN1YnN0cihpdGVtLmluZGV4T2YocHJlZml4KSArIHByZWZpeC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gXCI8c3Ryb25nPlwiICsgcHJlZml4ICsgXCI8L3N0cm9uZz5cIiArIHN1ZmZpeDtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVdpZGdldC5wcm90b3R5cGUuc2hvd0JveCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICAgICAgaWYgKGJveC5zdHlsZS52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICBib3guc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgICAgICAgYm94LmRpc3BhdGNoRXZlbnQoYXBwZWFyZWRFdmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVdpZGdldC5wcm90b3R5cGUuaGlkZUJveCA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICAgICAgYm94LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICBib3guZGlzcGF0Y2hFdmVudChoaWRkZW5FdmVudCk7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVXaWRnZXQucHJvdG90eXBlLmNsZWFyQXV0b2NvbXBsZXRlQm94ID0gZnVuY3Rpb24gKGJveCkge1xuICAgICAgICB0aGlzLmhpZGVCb3goYm94KTtcbiAgICAgICAgYm94LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIgKyBDU1NfQVVUT0NPTVBMRVRFX0lURU0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ucmVtb3ZlKCk7IH0pO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlV2lkZ2V0LnByb3RvdHlwZS5jcmVhdGVBdXRvY29tcGxldGVCb3ggPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgYm94LnNldEF0dHJpYnV0ZShcImlkXCIsIGlucHV0SWQgKyBcIiBhdXRvY29tcGxldGUtd2lkZ2V0XCIpO1xuICAgICAgICBib3guc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgQ1NTX0FVVE9DT01QTEVURV9XSURHRVQpO1xuICAgICAgICByZXR1cm4gYm94O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBoaWdobGlnaHRzIGZyb20gYSBoaWdobGlnaHRlZCBpdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW0gQSBzdHJpbmcgY29udGFpbmluZyBhICZsdDtzdHJvbmcmZ3Q7LXRhZy5cbiAgICAgKi9cbiAgICBBdXRvY29tcGxldGVXaWRnZXQucHJvdG90eXBlLnJlbW92ZUhpZ2hsaWdodHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgdGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRlbXAuaW5uZXJIVE1MID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIHRlbXAudGV4dENvbnRlbnQgfHwgXCJcIjtcbiAgICB9O1xuICAgIC8vIFRPRE86IFRoZSBDU1MtY2xhc3NlcyBzaG91bGQgYmUgY29uZmlndXJhYmxlLlxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBhY3RpdmUgaXRlbSB3aXRoIHRoZSAnc21hcnQtc2VhcmNoLWF1dG9jb21wbGV0ZS1hY3RpdmUnIGNzcyBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdXRvY29tcGxldGVMaXN0IFRoZSBodG1sIGVsZW1lbnQgY29udGFpbmluZyBhbGwgdGhlIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uc1xuICAgICAqIEBwYXJhbSBjdXJzb3JJbmRleFxuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZVdpZGdldC5wcm90b3R5cGUubWFya0FjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoYXV0b2NvbXBsZXRlTGlzdCwgY3Vyc29ySW5kZXgpIHtcbiAgICAgICAgdmFyIGFjSXRlbXMgPSBBcnJheS5mcm9tKGF1dG9jb21wbGV0ZUxpc3QucXVlcnlTZWxlY3RvckFsbChcIi5cIiArIENTU19BVVRPQ09NUExFVEVfSVRFTSkpO1xuICAgICAgICB2YXIgbWFya2VkSXRlbSA9IGFjSXRlbXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7IHJldHVybiBpbmRleCA9PT0gY3Vyc29ySW5kZXg7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoQ1NTX0FVVE9DT01QTEVURV9BQ1RJVkUpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucG9wKCk7XG4gICAgICAgIGFjSXRlbXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7IHJldHVybiBpbmRleCAhPT0gY3Vyc29ySW5kZXg7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5jbGFzc0xpc3QucmVtb3ZlKENTU19BVVRPQ09NUExFVEVfQUNUSVZFKTsgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZWRJdGVtO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlV2lkZ2V0LnByb3RvdHlwZS5yZW5kZXJJdGVtID0gZnVuY3Rpb24gKGFjSXRlbSkge1xuICAgICAgICB2YXIgcmVuZGVyZWRJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgcmVuZGVyZWRJdGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIENTU19BVVRPQ09NUExFVEVfSVRFTSk7XG4gICAgICAgIHJlbmRlcmVkSXRlbS5pbm5lckhUTUwgPSBhY0l0ZW07XG4gICAgICAgIHJldHVybiByZW5kZXJlZEl0ZW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB3aWRnZXQgYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBnaXZlbiBIVE1MSW5wdXRFbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0RWxlbWVudCBUaGUgSFRNTCBpbnB1dCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgd2lkZ2V0IHRvLlxuICAgICAqIEBwYXJhbSByZW5kZXJUYXJnZXQgVGhlIEhUTUwgZGl2IGVsZW1lbnQgdG8gcmVuZGVyIHRoZSB3aWRnZXQgaW50b1xuICAgICAqL1xuICAgIEF1dG9jb21wbGV0ZVdpZGdldC5wcm90b3R5cGUuaW5pdGlhbGl6ZUFuZEF0dGFjaCA9IGZ1bmN0aW9uIChpbnB1dEVsZW1lbnQsIHJlbmRlclRhcmdldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYm94ID0gdGhpcy5jcmVhdGVBdXRvY29tcGxldGVCb3goaW5wdXRFbGVtZW50LmlkKTtcbiAgICAgICAgaWYgKHJlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LmFwcGVuZENoaWxkKGJveCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXRFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGJveCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBpbnB1dCBlbGVtZW50IGhhcyBubyBwYXJlbnQuIFBsZWFzZSBhdHRhY2ggaXQgdG8gYW4gZWxlbWVudCBpbiB0aGUgRE9NIHRyZWUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZUJveChib3gpO1xuICAgICAgICAvL2hhbmRsZXMgdGhlIHR5cGluZ1xuICAgICAgICBCYWNvbi5mcm9tRXZlbnQoaW5wdXRFbGVtZW50LCBcImtleWRvd25cIilcbiAgICAgICAgICAgIC5kZWJvdW5jZSgzMDApXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gIVNQRUNJQUxfS0VZUy5pbmNsdWRlcyhldmVudC5rZXkpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNraXBEdXBsaWNhdGVzKClcbiAgICAgICAgICAgIC5mbGF0TWFwTGF0ZXN0KGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic21hcnQtc2VhcmNoLWlucHV0LWVtcHR5XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsZWFyQXV0b2NvbXBsZXRlQm94KGJveCk7IH0sIHtcbiAgICAgICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdGhyZXNob2xkID0gKChfYSA9IF90aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmVmaXhUaHJlc2hvbGQpIHx8IEFVVE9DT01QTEVURV9ERUZBVUxUX1RIUkVTSE9MRDtcbiAgICAgICAgICAgIGlmIChwcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudChpbnB1dEVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeC5sZW5ndGggPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmFjb24uZnJvbVByb21pc2UoX3RoaXMuZ2V0QXV0b2NvbXBsZXRlTGlzdChwcmVmaXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vblZhbHVlKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckF1dG9jb21wbGV0ZUJveChib3gpO1xuICAgICAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvd0JveChib3gpO1xuICAgICAgICAgICAgICAgIHZhciByZW5kZXJlZEl0ZW0gPSBfdGhpcy5yZW5kZXJJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkSXRlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQudmFsdWUgPSBfdGhpcy5yZW1vdmVIaWdobGlnaHRzKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJBdXRvY29tcGxldGVCb3goYm94KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBib3guYXBwZW5kQ2hpbGQocmVuZGVyZWRJdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy9oYW5kbGVzIHRoZSBjdXJzb3IgbW92ZWQgYnkgdGhlIGFycm93IGtleXNcbiAgICAgICAgdmFyIHVwID0gQmFjb24uZnJvbUV2ZW50KGlucHV0RWxlbWVudCwgXCJrZXlkb3duXCIpLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGV2ZW50LmtleSA9PT0gXCJBcnJvd1VwXCI7IH0pO1xuICAgICAgICB2YXIgZG93biA9IEJhY29uLmZyb21FdmVudChpbnB1dEVsZW1lbnQsIFwia2V5ZG93blwiKS5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5rZXkgPT09IFwiQXJyb3dEb3duXCI7IH0pO1xuICAgICAgICB2YXIgZW50ZXIgPSBCYWNvbi5mcm9tRXZlbnQoaW5wdXRFbGVtZW50LCBcImtleWRvd25cIikuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQua2V5ID09PSBcIkVudGVyXCI7IH0pO1xuICAgICAgICB2YXIgcmVzZXQgPSBCYWNvbi5mcm9tRXZlbnQoYm94LCBcInNtYXJ0LXNlYXJjaC13aWRnZXQtYXBwZWFyZWRcIik7XG4gICAgICAgIEJhY29uLnVwZGF0ZSgtMSwgW2Rvd24sIGZ1bmN0aW9uIChwcmV2KSB7IHJldHVybiBNYXRoLm1pbihwcmV2ICsgMSwgNCk7IH1dLCAvL3RoZSBtYXhpbXVtIGFtb3VudCBvZiBpdGVtcyBpbiB0aGUgbGlzdCB3ZSBnZXQgZnJvbSBoYXVwaWEgaXMgNVxuICAgICAgICBbdXAsIGZ1bmN0aW9uIChwcmV2KSB7IHJldHVybiBNYXRoLm1heChwcmV2IC0gMSwgLTEpOyB9XSwgLy8tMSBiZWNhdXNlIHByZXNzaW5nIGRvd24gZm9yIHRoZSBmaXJzdCB0aW1lIHdpbGwgbW92ZSB0aGUgY3Vyc29yIGZyb20gdGhlIGlucHV0IGZpZWxkIHRvIHRoZSBmaXJzdCBpdGVtXG4gICAgICAgIFtyZXNldCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gLTE7IH1dLCBbZW50ZXIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xOyB9XSkub25WYWx1ZShmdW5jdGlvbiAoaGlnaGxpZ2h0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBoaWdobGlnaHRlZEl0ZW0gPSBfdGhpcy5tYXJrQWN0aXZlSXRlbShib3gsIGhpZ2hsaWdodEluZGV4KTtcbiAgICAgICAgICAgIGlucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGhpZ2hsaWdodGVkSXRlbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dG9jb21wbGV0ZVdpZGdldDtcbn0oKSk7XG5leHBvcnQgeyBBdXRvY29tcGxldGVXaWRnZXQgfTtcbiIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSBcIi4vcGFnZVwiO1xudmFyIEZhY2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzZWFyY2hDbGllbnQgVGhlIGZldGNoIGNsaWVudCB0byBzZW5kIHRoZSBIVFRQIHJlcXVlc3RzLlxuICAgICAqIEBwYXJhbSBkYXRhIFRoZSBwb3NzaWJsZSB2YWx1ZXMgdG8gZmlsdGVyIHRoaXMgc2VhcmNoVGVybSBieS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBmYWNldHMgY29uZmlndXJlZCBpbiB0aGUgcHJlcGFyZWQgc2VhcmNoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZhY2V0KHNlYXJjaENsaWVudCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLl9maWx0ZXJDbGllbnQgPSBzZWFyY2hDbGllbnQ7XG4gICAgICAgIHRoaXMuX25hbWUgPSBjb25maWcuYmFzZU5hbWU7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBkYXRhLm5hbWUuc3BsaXQoXCJfXCIpLnBvcCgpO1xuICAgICAgICB0aGlzLl9jb3VudHMgPSB0aGlzLmRhdGEuY291bnRzLm1hcChmdW5jdGlvbiAoY291bnRzKSB7XG4gICAgICAgICAgICBjb3VudHMuZmlsdGVyUXVlcnkgPSBfdGhpcy5nZXRGaWx0ZXJQYXJhbU5hbWUoKTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudHM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZXQucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZXQucHJvdG90eXBlLCBcImNvdW50c1wiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwb3NzaWJsZSB2YWx1ZXMgZm9yIHRoaXMgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgZmlsdGVyIGZ1bmN0aW9uIGFzIHdlbGwgYXMgdGhlIG51bWJlciBvZlxuICAgICAgICAgKiBzZWFyY2ggcmVzdWx0cyB0aGF0IHdvdWxkIGJlIHJldHVybmVkIGlmIHlvdSBmaWx0ZXJlZCBieSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2V0LnByb3RvdHlwZSwgXCJmaWx0ZXJDbGllbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJDbGllbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWNldC5wcm90b3R5cGUsIFwiZGlzcGxheU5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZhY2V0LnByb3RvdHlwZSwgXCJzZWxlY3RlZFZhbHVlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkVmFsdWVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFjZXQucHJvdG90eXBlLCBcInR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBGYWNldC5wcm90b3R5cGUuZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFyYW0gPSB7fTtcbiAgICAgICAgcGFyYW1bdGhpcy5nZXRGaWx0ZXJQYXJhbU5hbWUoKV0gPSBcIlxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCI7XG4gICAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuICAgIEZhY2V0LnByb3RvdHlwZS5nZXRGaWx0ZXJQYXJhbU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcImZhY2V0LmZpbHRlci5cIiArIHRoaXMuY29uZmlnLmJhc2VOYW1lO1xuICAgIH07XG4gICAgRmFjZXQucHJvdG90eXBlLmdldFNlbGVjdGVkUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuc2VsZWN0ZWRWYWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5nZXRRdWVyeVBhcmFtKHZhbHVlKTsgfSkpIHx8IFtdO1xuICAgIH07XG4gICAgRmFjZXQucHJvdG90eXBlLmlzVmFsdWVBbGxvd2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBhbGxvd2VkVmFsdWVzID0gdGhpcy5jb3VudHMubWFwKGZ1bmN0aW9uIChjb3VudHMpIHsgcmV0dXJuIGNvdW50cy52YWx1ZTsgfSk7XG4gICAgICAgIHJldHVybiBhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKTtcbiAgICB9O1xuICAgIEZhY2V0LnByb3RvdHlwZS5zZXRTZWxlY3RlZFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFsdWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRmFjZXQucHJvdG90eXBlLnNldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheU5hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgc2VsZWN0ZWQgdmFsdWVzIGluIHRoaXMgZmFjZXQuXG4gICAgICogRm9yIHJlc2V0dGluZyBhIHNpbmdsZSBmYWNldCB3ZSByZWNvbW1lbmQgY2FsbGluZyBmaWx0ZXIgd2l0aCBubyBwYXJhbWV0ZXJzIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzZXR0ZWQgZmFjZXQuXG4gICAgICovXG4gICAgRmFjZXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFyYW1ldGVyTGlzdCA9IHRoaXMuZmlsdGVyQ2xpZW50LnBhcmFtZXRlckxpc3QuZGVsZXRlQWxsKHRoaXMuZ2V0RmlsdGVyUGFyYW1OYW1lKCkpO1xuICAgICAgICB0aGlzLmZpbHRlckNsaWVudC5wYXJhbWV0ZXJMaXN0ID0gcGFyYW1ldGVyTGlzdDtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZFZhbHVlcy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlsdGVycyB0aGUgc2VhcmNoIHJlc3VsdHMgZm9yIHRoaXMgc2VhcmNoIHRlcm0gdXNpbmcgdGhlIGZhY2V0IHZhbHVlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbi5cbiAgICAgKiBBbGxvd3MgZm9yIHRoZSBhZGRpdGlvbmFsIHVzYWdlIG9mIGN1c3RvbSBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIGZpbHRlclZhbHVlcyBUaGUgZmFjZXQgdmFsdWVzIHRvIGJlIGZpbHRlcmVkLiBNdXN0IGJlIGFuIGFycmF5LlxuICAgICAqIEBwYXJhbSBjdXN0b21QYXJhbXMgQWRkaXRpb25hbCBwYXJhbWV0ZXIgb2JqZWN0cy4gVGhlIGtleSB3aWxsIGJlIHRoZSBwYXJhbWV0ZXIgbmFtZSwgdGhlIHZhbHVlIGl0cyB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgcGFyYW1ldGVycyBhbHJlYWR5IGV4aXN0IChiZWNhdXNlIHlvdSBhZGRlZCB0aGVtIGFzIGNvbmZpZ3VyYXRpb24gb3B0aW9ucykgdGhleSB3aWxsIGJlIG92ZXJ3cml0dGVuIGFuZCB0aGVuIGRlbGV0ZWQuXG4gICAgICovXG4gICAgRmFjZXQucHJvdG90eXBlLmN1c3RvbUZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXJWYWx1ZXMpIHtcbiAgICAgICAgdmFyIGN1c3RvbVBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY3VzdG9tUGFyYW1zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDbGllbnQucGFyYW1ldGVyTGlzdCA9IChfYSA9IHRoaXMuZmlsdGVyQ2xpZW50LnBhcmFtZXRlckxpc3QpLmFkZE9yVXBkYXRlLmFwcGx5KF9hLCBjdXN0b21QYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5maWx0ZXIuYXBwbHkodGhpcywgZmlsdGVyVmFsdWVzKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQ2xpZW50LnBhcmFtZXRlckxpc3QgPSAoX2IgPSB0aGlzLmZpbHRlckNsaWVudC5wYXJhbWV0ZXJMaXN0KS5kZWxldGUuYXBwbHkoX2IsIGN1c3RvbVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIHRoZSBzZWFyY2ggcmVzdWx0cyBmb3IgdGhpcyBzZWFyY2ggdGVybSB1c2luZyB0aGUgZmFjZXR0ZSB2YWx1ZXMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGZpbHRlclZhbHVlcyBUaGUgZmFjZXQgdmFsdWVzIHRvIGJlIGZpbHRlcmVkLlxuICAgICAqIEB0aHJvd3MgV2hlbiBzZWxlY3RlZCB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkIG9yIG11bHRpcGxlIHNlbGVjdGlvbnMgYXJlIG5vdCBhbGxvd2VkLlxuICAgICAqL1xuICAgIEZhY2V0LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGZpbHRlclZhbHVlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJQYXJhbXMsIGNsaWVudFBhcmFtcztcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5tdWx0aVNlbGVjdCAmJiBmaWx0ZXJWYWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGlzIG5vdCBhIG11bHRpIHZhbHVlIGZhY2V0LiBZb3UgY2FuIG9ubHkgcGFzcyBvbmUgdmFsdWUgdG8gZmlsdGVyKCkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWx0ZXJWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnR5cGUgIT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZhY2V0IFwiICsgX3RoaXMuY29uZmlnLmJhc2VOYW1lICsgXCIgaXMgb2YgdHlwZSBcIiArIF90aGlzLnR5cGUgKyBcIiwgYnV0IHRoZSB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgKFwiICsgdmFsdWUgKyBcIikgaXMgb2YgdHlwZSBcIiArIHR5cGVvZiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5pc1ZhbHVlQWxsb3dlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwYXNzZWQgdmFsdWUgXCIgKyB2YWx1ZSArIFwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgZmFjZXR0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZpbHRlclBhcmFtcyA9IGZpbHRlclZhbHVlcy5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBfdGhpcy5nZXRRdWVyeVBhcmFtKHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgY2xpZW50UGFyYW1zID0gKF9hID0gdGhpcy5maWx0ZXJDbGllbnQucGFyYW1ldGVyTGlzdC5kZWxldGVBbGwodGhpcy5nZXRGaWx0ZXJQYXJhbU5hbWUoKSkpLmFkZC5hcHBseShfYSwgZmlsdGVyUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNsaWVudC5wYXJhbWV0ZXJMaXN0ID0gY2xpZW50UGFyYW1zLnVwZGF0ZUZpcnN0KHsgaGF1cGlhX3N0YXJ0OiBcIjBcIiB9KS51cGRhdGVGaXJzdCh7IGhhdXBpYV9wYWdlTnVtYmVyOiBcIjBcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5zZWFyY2goKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBGYWNldC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIganNvbiwgZXJyb3JfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmZpbHRlckNsaWVudC5mZXRjaCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAganNvbiA9IChfYS5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQYWdlKHRoaXMuZmlsdGVyQ2xpZW50LCBqc29uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBGYWNldDtcbn0oKSk7XG5leHBvcnQgeyBGYWNldCB9O1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IFVSTFBhcmFtTGlzdCB9IGZyb20gXCIuL3VybFBhcmFtTGlzdFwiO1xuLyoqIEBoaWRkZW4gKi9cbnZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICBjYWNoZTogXCJuby1jYWNoZVwiLFxuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICB9LFxuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICByZWZlcnJlclBvbGljeTogXCJuby1yZWZlcnJlclwiLFxufTtcbnZhciBGZXRjaENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGZXRjaENsaWVudCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJMaXN0ID0gbmV3IFVSTFBhcmFtTGlzdCgpO1xuICAgICAgICB0aGlzLl9hdXRvY29tcGxldGUgPSAoKF9iID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmF1dG9jb21wbGV0ZSkgfHwgZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmFtZXRlckxpc3QgPSAoX2EgPSB0aGlzLnBhcmFtZXRlckxpc3QuYWRkT3JVcGRhdGVTZWFyY2hUZXJtKG9wdGlvbnMuc2VhcmNoVGVybSB8fCBcIlwiKSkuYWRkLmFwcGx5KF9hLCBvcHRpb25zLmN1c3RvbVBhcmFtcyB8fCBbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZldGNoQ2xpZW50LnByb3RvdHlwZSwgXCJhdXRvY29tcGxldGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvY29tcGxldGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGZXRjaENsaWVudC5wcm90b3R5cGUsIFwicGFyYW1ldGVyTGlzdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlckxpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlckxpc3QgPSBsaXN0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGV4ZWN1dGUgb3IgYXV0b2NvbXBsZXRlIFVSTC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxcbiAgICAgKi9cbiAgICBGZXRjaENsaWVudC5wcm90b3R5cGUuZ2V0VXJsV2l0aFBhdGggPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciByZXR1cm5VcmwgPSB1cmw7XG4gICAgICAgIGlmICghcmV0dXJuVXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuVXJsICs9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHVyblVybCArIFwiYXV0b2NvbXBsZXRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVXJsICsgXCJleGVjdXRlXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgZmV0Y2ggcmVzb3VyY2UgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHJlc3NvdXJjZS5cbiAgICAgKi9cbiAgICBGZXRjaENsaWVudC5wcm90b3R5cGUuYnVpbGRSZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICBpZiAodXJsICE9PSB0aGlzLnVybCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmxXaXRob3V0UGFyYW1zID0gdGhpcy5nZXRVcmxXaXRoUGF0aCh1cmwpO1xuICAgICAgICB2YXIgdXJsUGFyYW1zID0gdGhpcy5wYXJhbWV0ZXJMaXN0LnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciByZXF1ZXN0VXJsID0gbmV3IFVSTCh1cmxXaXRob3V0UGFyYW1zICsgXCIvP1wiICsgdXJsUGFyYW1zKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QocmVxdWVzdFVybCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgIH07XG4gICAgRmV0Y2hDbGllbnQucHJvdG90eXBlLmhhbmRsZVN0YXR1cyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBHRVQgcmVxdWVzdCB0byB0aGUgU21hcnRTZWFyY2ggQVBJIGF0IHRoZSBnaXZlbiBvciBzdG9yZWQgdXJsXG4gICAgICogQHBhcmFtIHVybCBPdmVycmlkZXMgdGhlIHVybCBjbGFzcyBmaWVsZFxuICAgICAqL1xuICAgIEZldGNoQ2xpZW50LnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgaWYgKHVybCA9PT0gdm9pZCAwKSB7IHVybCA9IHRoaXMudXJsOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0LCByZXNwb25zZSwgaGFuZGxlZFJlc3BvbnNlLCBlcnJvcl8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZmV0Y2gocmVxdWVzdCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZWRSZXNwb25zZSA9IHRoaXMuaGFuZGxlU3RhdHVzKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGhhbmRsZWRSZXNwb25zZS5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yXzEpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmV0Y2hDbGllbnQ7XG59KCkpO1xuZXhwb3J0IHsgRmV0Y2hDbGllbnQgfTtcbiIsImV4cG9ydCB7IFNtYXJ0U2VhcmNoIH0gZnJvbSBcIi4vc21hcnRTZWFyY2hcIjtcbmV4cG9ydCB7IFBhZ2UgfSBmcm9tIFwiLi9wYWdlXCI7XG5leHBvcnQgeyBGYWNldCB9IGZyb20gXCIuL2ZhY2V0XCI7XG5leHBvcnQgeyBTZWFyY2hSZXN1bHQgfSBmcm9tIFwiLi9zZWFyY2hSZXN1bHRcIjtcbmV4cG9ydCB7IFBhZ2VSZW5kZXJlciB9IGZyb20gXCIuL3BhZ2VSZW5kZXJlclwiO1xuIiwidmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5pbXBvcnQgeyBTZWFyY2hSZXN1bHQgfSBmcm9tIFwiLi9zZWFyY2hSZXN1bHRcIjtcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSBcIi4vZmFjZXRcIjtcbmltcG9ydCB7IFVSTFBhcmFtTGlzdCB9IGZyb20gXCIuL3VybFBhcmFtTGlzdFwiO1xudmFyIFBBR0lOQVRJT05fRVJST1JfTUVTU0FHRSA9IFwiSW52YWxpZCBwYWdpbmF0aW9uIHBhcmFtZXRlcnMgZGVmaW5lZC4gU3RhdGljIHBhZ2luYXRpb24gcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuXCI7XG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIHNlYXJjaCBlbmdpbmUgcmVzdWx0cyBwYWdlIChTRVJQKS5cbiAqL1xudmFyIFBhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIGdldHMgY2FsbGVkIGFmdGVyIFtbU21hcnRTZWFyY2hdXSByZWNlaXZlcyBzZWFyY2ggcmVzdWx0cyBmcm9tIHRoZSBiYWNrZW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZldGNoQ2xpZW50IFRoZSBbW0ZldGNoQ2xpZW50XV0gdXNlZCB0byBzZW5kIEFQSSBjYWxscyBhZ2FpbnN0IHRoZSBwcmVwYXJlZCBzZWFyY2guXG4gICAgICogQHBhcmFtIHJlc3BvbnNlRGF0YSBUaGUgcmVzcG9uc2UgSlNPTiB0aGF0IG1heSBvciBtYXkgbm90IGhhdmUgYmVlbiBmaWx0ZXJlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDdXJyZW50bHkgb25seSB1c2VkIHRvIGdldCB0aGUgdGVtcGxhdGUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYWdlKGZldGNoQ2xpZW50LCByZXNwb25zZURhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNwb25zZURhdGEgPSByZXNwb25zZURhdGE7XG4gICAgICAgIHRoaXMuX2ZldGNoQ2xpZW50ID0gZmV0Y2hDbGllbnQ7XG4gICAgICAgIHRoaXMucmVzcG9uc2VEYXRhID0gcmVzcG9uc2VEYXRhO1xuICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdHMgPSByZXNwb25zZURhdGEucmVzdWx0cy5tYXAoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGhpZ2hsaWdodGluZyA9IF90aGlzLnJlc3BvbnNlRGF0YS5oaWdobGlnaHRpbmc7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlYXJjaFJlc3VsdChyZXN1bHQsIGhpZ2hsaWdodGluZyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBhZ2luYXRpb25QYXJhbXMgPSB0aGlzLmV4dHJhY3RQYWdpbmF0aW9uUGFyYW1zKHRoaXMucmVzcG9uc2VEYXRhKTtcbiAgICAgICAgdGhpcy5mYWNldHMgPSB0aGlzLmhhc0ZhY2V0cyhyZXNwb25zZURhdGEpID8gdGhpcy5leHRyYWN0RmFjZXRzKHJlc3BvbnNlRGF0YSwgZmV0Y2hDbGllbnQpIDogW107XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlLnByb3RvdHlwZSwgXCJudW1iZXJPZlJlc3VsdHNcIiwge1xuICAgICAgICAvKiogVGhlIHRvdGFsIG51bWJlciBvZiBzZWFyY2ggcmVzdWx0cyBtYXRjaGluZyB0aGUgc2VhcmNoIHRlcm0uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VEYXRhLm51bVJvd3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlLnByb3RvdHlwZSwgXCJkaWRZb3VNZWFuXCIsIHtcbiAgICAgICAgLyoqIFJldHVybnMgYWx0ZXJuYXRpdmUgc2VhcmNoIHF1ZXJpZXMgaWYgdGhlIFtbbnVtYmVyT2ZSZXN1bHRzXV0gdmFsdWUgaXMgYmVuZWF0aCB0aGUgdGhyZXNob2xkIGNvbmZpZ3VyZWQgYXQgdGhlXG4gICAgICAgICAqICBwcmVwYXJlZCBzZWFyY2ggaW4gdGhlIGNvY2twaXQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VEYXRhLmRpZFlvdU1lYW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlLnByb3RvdHlwZSwgXCJmZXRjaENsaWVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoQ2xpZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQYWdlLnByb3RvdHlwZS5oYXNGYWNldHMgPSBmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZURhdGEuZmFjZXRzLmxlbmd0aCA+IDAgJiYgcmVzcG9uc2VEYXRhLmZhY2V0Q29uZmlncy5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUuZXh0cmFjdEZhY2V0cyA9IGZ1bmN0aW9uIChyZXNwb25zZURhdGEsIHNlYXJjaENsaWVudCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VEYXRhLmZhY2V0cy5tYXAoZnVuY3Rpb24gKHJlc3BvbnNlRmFjZXQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZmFjZXRCYXNlTmFtZSA9IHJlc3BvbnNlRGF0YS5mYWNldENvbmZpZ3NbaW5kZXhdLmJhc2VOYW1lO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzbHlGaWx0ZXJlZEZhY2V0S2V5ID0gT2JqZWN0LmtleXMocmVzcG9uc2VEYXRhLnJlcXVlc3RQYXJhbWV0ZXJzKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LmluY2x1ZGVzKGZhY2V0QmFzZU5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZmFjZXQgPSBuZXcgRmFjZXQoc2VhcmNoQ2xpZW50LCByZXNwb25zZUZhY2V0LCByZXNwb25zZURhdGEuZmFjZXRDb25maWdzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNseUZpbHRlcmVkRmFjZXRLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSByZXNwb25zZURhdGEucmVxdWVzdFBhcmFtZXRlcnNbcHJldmlvdXNseUZpbHRlcmVkRmFjZXRLZXldLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1wiL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWNldC5zZXRTZWxlY3RlZFZhbHVlcy5hcHBseShmYWNldCwgc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhY2V0O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2UucHJvdG90eXBlLmV4dHJhY3RQYWdpbmF0aW9uUGFyYW1zID0gZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICAgICAgICB2YXIgcmVxdWVzdFBhcmFtZXRlcnMgPSByZXNwb25zZURhdGEucmVxdWVzdFBhcmFtZXRlcnM7XG4gICAgICAgIHZhciBwYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICBpZiAodGhpcy5oYXNEeW5hbWljUGFnaW5hdGlvblBhcmFtcyhyZXF1ZXN0UGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHBhZ2luYXRpb25QYXJhbXMgPSB0aGlzLmV4dHJhY3REeW5hbWljUGFnaW5hdGlvblBhcmFtcyhyZXF1ZXN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNTdGF0aWNQYWdpbmF0aW9uUGFyYW1zKHJlcXVlc3RQYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcGFnaW5hdGlvblBhcmFtcyA9IHRoaXMuZXh0cmFjdFN0YXRpY1BhZ2luYXRpb25QYXJhbXMocmVxdWVzdFBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnaW5hdGlvblBhcmFtcyA9IHRoaXMuc2V0RGVmYXVsdFN0YXRpY1BhZ2luYXRpb25QYXJhbXMocmVzcG9uc2VEYXRhLnJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWdpbmF0aW9uUGFyYW1zO1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUuaGFzRHluYW1pY1BhZ2luYXRpb25QYXJhbXMgPSBmdW5jdGlvbiAocmVxdWVzdFBhcmFtZXRlcnMpIHtcbiAgICAgICAgdmFyIGhhc1Jvd3MgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxdWVzdFBhcmFtZXRlcnMsIFwiaGF1cGlhX3Jvd3NcIik7XG4gICAgICAgIHZhciBoYXNTdGFydCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXF1ZXN0UGFyYW1ldGVycywgXCJoYXVwaWFfc3RhcnRcIik7XG4gICAgICAgIHJldHVybiBoYXNSb3dzICYmIGhhc1N0YXJ0O1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUuZXh0cmFjdER5bmFtaWNQYWdpbmF0aW9uUGFyYW1zID0gZnVuY3Rpb24gKHJlcXVlc3RQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHZhciByb3dzID0gTnVtYmVyKHJlcXVlc3RQYXJhbWV0ZXJzLmhhdXBpYV9yb3dzKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTnVtYmVyKHJlcXVlc3RQYXJhbWV0ZXJzLmhhdXBpYV9zdGFydCk7XG4gICAgICAgIGlmIChpc05hTihyb3dzKSB8fCBpc05hTihzdGFydCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBwYWdpbmF0aW9uIHBhcmFtZXRlcnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzOiByb3dzLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUuaGFzU3RhdGljUGFnaW5hdGlvblBhcmFtcyA9IGZ1bmN0aW9uIChyZXF1ZXN0UGFyYW1ldGVycykge1xuICAgICAgICB2YXIgaGFzUGFnZU51bWJlciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXF1ZXN0UGFyYW1ldGVycywgXCJoYXVwaWFfcGFnZU51bWJlclwiKTtcbiAgICAgICAgdmFyIGhhc1BhZ2VTaXplID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcXVlc3RQYXJhbWV0ZXJzLCBcImhhdXBpYV9wYWdlU2l6ZVwiKTtcbiAgICAgICAgcmV0dXJuIGhhc1BhZ2VOdW1iZXIgJiYgaGFzUGFnZVNpemU7XG4gICAgfTtcbiAgICBQYWdlLnByb3RvdHlwZS5leHRyYWN0U3RhdGljUGFnaW5hdGlvblBhcmFtcyA9IGZ1bmN0aW9uIChyZXF1ZXN0UGFyYW1ldGVycykge1xuICAgICAgICB2YXIgcGFnZU51bWJlciA9IE51bWJlcihyZXF1ZXN0UGFyYW1ldGVycy5oYXVwaWFfcGFnZU51bWJlcik7XG4gICAgICAgIHZhciBwYWdlU2l6ZSA9IE51bWJlcihyZXF1ZXN0UGFyYW1ldGVycy5oYXVwaWFfcGFnZVNpemUpO1xuICAgICAgICBpZiAoaXNOYU4ocGFnZU51bWJlcikgfHwgaXNOYU4ocGFnZVNpemUpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgcGFnaW5hdGlvbiBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlcixcbiAgICAgICAgICAgIHBhZ2VTaXplOiBwYWdlU2l6ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBhZ2UucHJvdG90eXBlLnNldERlZmF1bHRTdGF0aWNQYWdpbmF0aW9uUGFyYW1zID0gZnVuY3Rpb24gKHJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IDAsXG4gICAgICAgICAgICBwYWdlU2l6ZTogcm93cyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2YgcGFnZXMuXG4gICAgICovXG4gICAgUGFnZS5wcm90b3R5cGUuZ2V0TnVtYmVyT2ZQYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RhdGljUGFnaW5hdGlvbih0aGlzLnBhZ2luYXRpb25QYXJhbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihQQUdJTkFUSU9OX0VSUk9SX01FU1NBR0UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5yZXNwb25zZURhdGEubnVtUm93cyAvIHRoaXMucGFnaW5hdGlvblBhcmFtcy5wYWdlU2l6ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0aGUgZmFjZXQgbWF0Y2hpbmcgdGhlIGdpdmVuIG5hbWUgaWYgaXQgZXhpc3RzIG9uIHRoaXMgcHJlcGFyZWQgc2VhcmNoLlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmYWNldCBhcyBpdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFNtYXJ0U2VhcmNoIGNvY2twaXQgdW5kZXIgUHJlcGFyZWQgU2VhcmNoID4gRmFjZXRcbiAgICAgKi9cbiAgICBQYWdlLnByb3RvdHlwZS5nZXRGYWNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0cy5maW5kKGZ1bmN0aW9uIChmYWNldCkgeyByZXR1cm4gZmFjZXQubmFtZSA9PT0gbmFtZTsgfSkgfHwgbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgZmFjZXRzIG9uIHRoaXMgcGFnZVxuICAgICAqIEBwYXJhbSBpbmNsdWRlIEFuIG9wdGlvbmFsIGxpc3Qgb2YgZmFjZXQgbmFtZXMgdG8gcmVzZXQuIElmIHlvdSBwYXNzIHRoaXMgcGFyYW1ldGVyIG9ubHkgdGhlIGZhY2V0cyB0aGF0IG1hdGNoIHRoZSBuYW1lcyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSByZXNldHRlZC5cbiAgICAgKiBJZiB5b3UgcGFzcyBubyBwYXJhbWV0ZXIsIGFsbCBmYWNldHMgd2lsbCBiZSByZXNldHRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgcGFnZSBvZiB0aGUgbmV3IGFuZCB1bmZpbHRlcmVkIHJlc3VsdHNldC5cbiAgICAgKi9cbiAgICBQYWdlLnByb3RvdHlwZS5yZXNldEZhY2V0cyA9IGZ1bmN0aW9uIChpbmNsdWRlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2V0cyA9IHRoaXMuZmFjZXRzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGZhY2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBpbmNsdWRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoZmFjZXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFjZXQucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWNldC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEeW5hbWljUGFnaW5hdGlvbih0aGlzLnBhZ2luYXRpb25QYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnNlYXJjaCh7IHN0YXJ0OiAwLCByb3dzOiB0aGlzLnBhZ2luYXRpb25QYXJhbXMucm93cyB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5nZXRGaXJzdFBhZ2UoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZG9lc24ndCB3b3JrIHdpdGggW1tEeW5hbWljUGFnaW5hdGlvblBhcmFtc11dLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IHBhZ2Ugd2l0aCB0aGUgZGVmaW5lZCBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgUGFnZS5wcm90b3R5cGUuZ2V0Rmlyc3RQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdGF0aWNQYWdpbmF0aW9uKHRoaXMucGFnaW5hdGlvblBhcmFtcykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFBBR0lOQVRJT05fRVJST1JfTUVTU0FHRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZSgwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZG9lc24ndCB3b3JrIHdpdGggW1tEeW5hbWljUGFnaW5hdGlvblBhcmFtc11dLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxhc3QgcGFnZSB3aXRoIHRoZSBkZWZpbmVkIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKi9cbiAgICBQYWdlLnByb3RvdHlwZS5nZXRMYXN0UGFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhc3RQYWdlID0gdGhpcy5nZXROdW1iZXJPZlBhZ2VzKCkgLSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlKGxhc3RQYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZG9lc24ndCB3b3JrIHdpdGggW1tEeW5hbWljUGFnaW5hdGlvblBhcmFtc11dLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhZ2VOdW1iZXJcbiAgICAgKiBAcmV0dXJucyBUaGUgc3BlY2lmaWVkIHBhZ2Ugd2l0aCB0aGUgZGVmaW5lZCBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgUGFnZS5wcm90b3R5cGUuZ2V0UGFnZSA9IGZ1bmN0aW9uIChwYWdlTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXdQYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1N0YXRpY1BhZ2luYXRpb24odGhpcy5wYWdpbmF0aW9uUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihQQUdJTkFUSU9OX0VSUk9SX01FU1NBR0UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdQYWdpbmF0aW9uUGFyYW1zID0gdGhpcy5wYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICAgICAgICAgIG5ld1BhZ2luYXRpb25QYXJhbXMucGFnZU51bWJlciA9IHBhZ2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1BhZ2UocGFnZU51bWJlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGVyZSBpcyBubyBwYWdlIG51bWJlcjogXCIgKyBwYWdlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2VhcmNoKG5ld1BhZ2luYXRpb25QYXJhbXMpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBwYWdlIHdpdGggdGhlIGdpdmVuIHBhZ2UgbnVtYmVyIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBbW2dldFBhZ2VdXSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWdlTnVtYmVyXG4gICAgICovXG4gICAgUGFnZS5wcm90b3R5cGUuaGFzUGFnZSA9IGZ1bmN0aW9uIChwYWdlTnVtYmVyKSB7XG4gICAgICAgIHZhciBzdGF0aWNQYWdpbmF0aW9uUGFyYW1zID0gdGhpcy5wYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICB2YXIgbnVtYmVyT2ZUb3RhbFBhZ2VzID0gTWF0aC5jZWlsKHRoaXMucmVzcG9uc2VEYXRhLm51bVJvd3MgLyBzdGF0aWNQYWdpbmF0aW9uUGFyYW1zLnBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIG51bWJlck9mVG90YWxQYWdlcyA+IHBhZ2VOdW1iZXIgJiYgcGFnZU51bWJlciA+PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIFtbbmV4dF1dIGZ1bmN0aW9uIHdvdWxkIHNlbmQgYSB2YWxpZCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbbmV4dF1dIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIFBhZ2UucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHluYW1pY1BhZ2luYXRpb24odGhpcy5wYWdpbmF0aW9uUGFyYW1zKSAmJiB0aGlzLnBhZ2luYXRpb25QYXJhbXMuc3RhcnQgKyB0aGlzLnBhZ2luYXRpb25QYXJhbXMucm93cyA8IHRoaXMucmVzcG9uc2VEYXRhLm51bVJvd3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljUGFnaW5hdGlvbih0aGlzLnBhZ2luYXRpb25QYXJhbXMpICYmIHRoaXMucGFnaW5hdGlvblBhcmFtcy5wYWdlU2l6ZSAqICh0aGlzLnBhZ2luYXRpb25QYXJhbXMucGFnZU51bWJlciArIDEpIDwgdGhpcy5yZXNwb25zZURhdGEubnVtUm93cykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIFtbcHJldl1dIGZ1bmN0aW9uIHdvdWxkIHNlbmQgYSB2YWxpZCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbcHJldl1dIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIFBhZ2UucHJvdG90eXBlLmhhc1ByZXYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljUGFnaW5hdGlvbih0aGlzLnBhZ2luYXRpb25QYXJhbXMpICYmIHRoaXMucGFnaW5hdGlvblBhcmFtcy5wYWdlTnVtYmVyID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEeW5hbWljUGFnaW5hdGlvbih0aGlzLnBhZ2luYXRpb25QYXJhbXMpICYmIHRoaXMucGFnaW5hdGlvblBhcmFtcy5zdGFydCA+PSB0aGlzLnBhZ2luYXRpb25QYXJhbXMucm93cykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIEFQSSByZXNwb25zZSBjb250YWlucyB0aGUgbmV4dCBtYXRjaGVzIGJhc2VkIG9uIHRoZSBwcmV2aW91c2x5IHNldCBwYWdpbmF0aW9uIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQYWdlXV0gY29udGFpbmluZyBhbGwgdGhlIHNlYXJjaCByZXN1bHRzIGZvciB0aGF0IHBhZ2UuXG4gICAgICovXG4gICAgUGFnZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5leHRQYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNOZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGVyZSBpcyBubyBuZXh0IHBhZ2UuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0UGFnaW5hdGlvblBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRHluYW1pY1BhZ2luYXRpb24odGhpcy5wYWdpbmF0aW9uUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UGFnaW5hdGlvblBhcmFtcyA9IF9fYXNzaWduKHt9LCB0aGlzLnBhZ2luYXRpb25QYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0UGFnaW5hdGlvblBhcmFtcy5zdGFydCArPSB0aGlzLnBhZ2luYXRpb25QYXJhbXMucm93cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWNQYWdpbmF0aW9uKHRoaXMucGFnaW5hdGlvblBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBhZ2luYXRpb25QYXJhbXMgPSB0aGlzLnBhZ2luYXRpb25QYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQYWdpbmF0aW9uUGFyYW1zLnBhZ2VOdW1iZXIrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuc2VhcmNoKG5leHRQYWdpbmF0aW9uUGFyYW1zKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgQVBJIHJlc3BvbnNlIGNvbnRhaW5zIHRoZSBwcmV2aW91cyBtYXRjaGVzIGJhc2VkIG9uIHRoZSBwcmV2aW91c2x5IHNldCBwYWdpbmF0aW9uIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQYWdlXV0gY29udGFpbmluZyBhbGwgdGhlIHNlYXJjaCByZXN1bHRzIGZvciB0aGF0IHBhZ2UuXG4gICAgICovXG4gICAgUGFnZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHByZXZQYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNQcmV2KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGVyZSBpcyBubyBwcmV2aW91cyBwYWdlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldlBhZ2luYXRpb25QYXJhbXMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXRpY1BhZ2luYXRpb24odGhpcy5wYWdpbmF0aW9uUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2UGFnaW5hdGlvblBhcmFtcyA9IHRoaXMucGFnaW5hdGlvblBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhZ2luYXRpb25QYXJhbXMucGFnZU51bWJlci0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0R5bmFtaWNQYWdpbmF0aW9uKHRoaXMucGFnaW5hdGlvblBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldlBhZ2luYXRpb25QYXJhbXMgPSB0aGlzLnBhZ2luYXRpb25QYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHByZXZQYWdpbmF0aW9uUGFyYW1zLnN0YXJ0IC09IHByZXZQYWdpbmF0aW9uUGFyYW1zLnJvd3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLnNlYXJjaChwcmV2UGFnaW5hdGlvblBhcmFtcyldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBvciB1cGRhdGVzIGFsbCBmYWNldCBwYXJhbWV0ZXJzIGluIHRoZSBnaXZlbiBsaXN0IGFuZCByZXR1cm5zIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2VsZWN0ZWQgdmFsdWVzIG9mIGFsbCBmYWNldHNcbiAgICAgKiBvbiB0aGlzIHBhZ2UuXG4gICAgICogQHBhcmFtIHBhcmFtTGlzdCBUaGUgbGlzdCB0byBiZSB1cGRhdGVkXG4gICAgICovXG4gICAgUGFnZS5wcm90b3R5cGUuYWRkT3JVcGRhdGVGYWNldFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbUxpc3QpIHtcbiAgICAgICAgdmFyIHJldHVybmxpc3QgPSBuZXcgVVJMUGFyYW1MaXN0KHBhcmFtTGlzdC5saXN0KTtcbiAgICAgICAgdGhpcy5mYWNldHMuZm9yRWFjaChmdW5jdGlvbiAoZmFjZXQpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZFBhcmFtcyA9IGZhY2V0LmdldFNlbGVjdGVkUGFyYW1ldGVycygpO1xuICAgICAgICAgICAgcmV0dXJubGlzdCA9IChfYSA9IHJldHVybmxpc3QuZGVsZXRlQWxsKGZhY2V0LmdldEZpbHRlclBhcmFtTmFtZSgpKSkuYWRkLmFwcGx5KF9hLCBzZWxlY3RlZFBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0dXJubGlzdDtcbiAgICB9O1xuICAgIFBhZ2UucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChwYWdpbmF0aW9uUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmZXRjaFBhcmFtcywgcGFyYW1zLCBqc29uLCBlcnJvcl8xO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQYXJhbXMgPSB0aGlzLmJ1aWxkRmV0Y2hQYXJhbXMocGFnaW5hdGlvblBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSAoX2EgPSB0aGlzLmZldGNoQ2xpZW50LnBhcmFtZXRlckxpc3QpLmFkZE9yVXBkYXRlLmFwcGx5KF9hLCBmZXRjaFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZldGNoQ2xpZW50LnBhcmFtZXRlckxpc3QgPSB0aGlzLmFkZE9yVXBkYXRlRmFjZXRQYXJhbXMocGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZmV0Y2hDbGllbnQuZmV0Y2goKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb24gPSAoX2Iuc2VudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUGFnZSh0aGlzLmZldGNoQ2xpZW50LCBqc29uKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2UucHJvdG90eXBlLmJ1aWxkRmV0Y2hQYXJhbXMgPSBmdW5jdGlvbiAocGFnaW5hdGlvblBhcmFtcykge1xuICAgICAgICB2YXIgZmV0Y2hQYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkUXVlcnlQYXJhbXMgPSB0aGlzLnRyYW5zZm9ybVBhZ2luYXRpb25QYXJhbXNUb0ZldGNoUGFyYW1zKHBhZ2luYXRpb25QYXJhbXMpO1xuICAgICAgICBmZXRjaFBhcmFtcyA9IGZldGNoUGFyYW1zLmNvbmNhdCh0cmFuc2Zvcm1lZFF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIGZldGNoUGFyYW1zO1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUudHJhbnNmb3JtUGFnaW5hdGlvblBhcmFtc1RvRmV0Y2hQYXJhbXMgPSBmdW5jdGlvbiAocXVlcnlQYXJhbXMpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkUGFyYW1zID0gW107XG4gICAgICAgIGlmICh0aGlzLmlzRHluYW1pY1BhZ2luYXRpb24ocXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcyA9IHRoaXMuYnVpbGREeW5hbWljUGFnaW5hdGlvblBhcmFtcyhxdWVyeVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWNQYWdpbmF0aW9uKHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMgPSB0aGlzLmJ1aWxkU3RhdGljUGFnaW5hdGlvblBhcmFtcyhxdWVyeVBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkUGFyYW1zO1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUuYnVpbGREeW5hbWljUGFnaW5hdGlvblBhcmFtcyA9IGZ1bmN0aW9uIChxdWVyeVBhcmFtcykge1xuICAgICAgICB2YXIgcGFnaW5hdGlvblBhcmFtcyA9IFtdO1xuICAgICAgICBwYWdpbmF0aW9uUGFyYW1zLnB1c2goeyBoYXVwaWFfcm93czogcXVlcnlQYXJhbXMucm93cy50b1N0cmluZygpIH0pO1xuICAgICAgICBwYWdpbmF0aW9uUGFyYW1zLnB1c2goeyBoYXVwaWFfc3RhcnQ6IHF1ZXJ5UGFyYW1zLnN0YXJ0LnRvU3RyaW5nKCkgfSk7XG4gICAgICAgIHJldHVybiBwYWdpbmF0aW9uUGFyYW1zO1xuICAgIH07XG4gICAgUGFnZS5wcm90b3R5cGUuYnVpbGRTdGF0aWNQYWdpbmF0aW9uUGFyYW1zID0gZnVuY3Rpb24gKHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIHZhciBwYWdpbmF0aW9uUGFyYW1zID0gW107XG4gICAgICAgIHBhZ2luYXRpb25QYXJhbXMucHVzaCh7IGhhdXBpYV9wYWdlTnVtYmVyOiBxdWVyeVBhcmFtcy5wYWdlTnVtYmVyLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgIHBhZ2luYXRpb25QYXJhbXMucHVzaCh7IGhhdXBpYV9wYWdlU2l6ZTogcXVlcnlQYXJhbXMucGFnZVNpemUudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgcmV0dXJuIHBhZ2luYXRpb25QYXJhbXM7XG4gICAgfTtcbiAgICBQYWdlLnByb3RvdHlwZS5pc0R5bmFtaWNQYWdpbmF0aW9uID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zLnJvd3MgIT09IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFBhZ2UucHJvdG90eXBlLmlzU3RhdGljUGFnaW5hdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5wYWdlTnVtYmVyICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnZTtcbn0oKSk7XG5leHBvcnQgeyBQYWdlIH07XG4iLCJpbXBvcnQgeyBEaWRZb3VNZWFuVGVtcGxhdGUgfSBmcm9tIFwiLi90ZW1wbGF0ZXMvZGlkWW91TWVhblRlbXBsYXRlXCI7XG5pbXBvcnQgeyBQYWdpbmF0aW9uVGVtcGxhdGUgfSBmcm9tIFwiLi90ZW1wbGF0ZXMvcGFnaW5hdGlvblRlbXBsYXRlXCI7XG5pbXBvcnQgeyBTZWFyY2hSZXN1bHRUZW1wbGF0ZSB9IGZyb20gXCIuL3RlbXBsYXRlcy9zZWFyY2hSZXN1bHRUZW1wbGF0ZVwiO1xudmFyIFBBR0lOQVRJT05fRVJST1JfTUVTU0FHRSA9IFwiU3RhdGljIHBhZ2luYXRpb24gcGFyYW1ldGVycyBhcmUgZXhwZWN0ZWQuXCI7XG4vKipcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyB0aGUgaW5kaXZpZHVhbCBlbGVtZW50cyBvZiBhIHNlYXJjaCByZXN1bHQgcGFnZS5cbiAqL1xudmFyIFBhZ2VSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcGFnZSBUaGUgY29ycmVzcG9uZGluZyBwYWdlIHdob3NlIGNvbnRlbnQgaXMgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFnZVJlbmRlcmVyKHBhZ2UpIHtcbiAgICAgICAgdGhpcy5wYWdlID0gcGFnZTtcbiAgICAgICAgdGhpcy5fZGlkWW91TWVhblRlbXBsYXRlID0gbmV3IERpZFlvdU1lYW5UZW1wbGF0ZSgpO1xuICAgICAgICB0aGlzLl9wYWdpbmF0aW9uVGVtcGxhdGUgPSBuZXcgUGFnaW5hdGlvblRlbXBsYXRlKCk7XG4gICAgICAgIHRoaXMuX3NlYXJjaFJlc3VsdFRlbXBsYXRlID0gbmV3IFNlYXJjaFJlc3VsdFRlbXBsYXRlKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlUmVuZGVyZXIucHJvdG90eXBlLCBcImRpZFlvdU1lYW5UZW1wbGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ0RpZCB5b3UgbWVhbicgdGVtcGxhdGUgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciBhbHRlcm5hdGl2ZSBzZWFyY2ggc3VnZ2VzdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWRZb3VNZWFuVGVtcGxhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWdlUmVuZGVyZXIucHJvdG90eXBlLCBcInBhZ2luYXRpb25UZW1wbGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFnaW5hdGlvbiB0ZW1wbGF0ZSB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIGEgc2luZ2xlIHBhZ2luYXRpb24gZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZ2luYXRpb25UZW1wbGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhZ2VSZW5kZXJlci5wcm90b3R5cGUsIFwic2VhcmNoUmVzdWx0VGVtcGxhdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlYXJjaCByZXN1bHQgdGVtcGxhdGUgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgc2VhcmNoIHJlc3VsdHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWFyY2hSZXN1bHRUZW1wbGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIG5leHQgYnV0dG9uIChpZiBhIG5leHQgcGFnZSBleGlzdHMpIHVzaW5nIHRoZSBbW3BhZ2luYXRpb25UZW1wbGF0ZV1dLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBsYWJlbCB1c2VkIHRvIGRlc2NyaWJlIHRoZSBidXR0b24uXG4gICAgICovXG4gICAgUGFnZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJOZXh0QnV0dG9uID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICAgIGlmIChsYWJlbCA9PT0gdm9pZCAwKSB7IGxhYmVsID0gXCJOZXh0XCI7IH1cbiAgICAgICAgaWYgKCF0aGlzLnBhZ2UuaXNTdGF0aWNQYWdpbmF0aW9uKHRoaXMucGFnZS5wYWdpbmF0aW9uUGFyYW1zKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoUEFHSU5BVElPTl9FUlJPUl9NRVNTQUdFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYWdlLmhhc05leHQoKSkge1xuICAgICAgICAgICAgdmFyIHN0YXRpY1BhZ2luYXRpb25QYXJhbXMgPSB0aGlzLnBhZ2UucGFnaW5hdGlvblBhcmFtcztcbiAgICAgICAgICAgIHZhciBuZXh0UGFnZU51bWJlciA9IHN0YXRpY1BhZ2luYXRpb25QYXJhbXMucGFnZU51bWJlciArIDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJQYWdpbmF0aW9uRWxlbWVudCh0aGlzLl9wYWdpbmF0aW9uVGVtcGxhdGUuY3NzQ2xhc3Nlcy5uZXh0QnV0dG9uLCBuZXh0UGFnZU51bWJlciwgdGhpcy5fcGFnaW5hdGlvblRlbXBsYXRlLnJlbmRlck5leHQsIGxhYmVsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIG5leHQgYnV0dG9uIChpZiBhIG5leHQgcGFnZSBleGlzdHMpIHVzaW5nIHRoZSBbW3BhZ2luYXRpb25UZW1wbGF0ZV1dIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIEhUTUwgZWxlbWVudCB0byB3aGljaCB0aGUgYnV0dG9uIGlzIGF0dGFjaGVkLlxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgdXNlZCB0byBkZXNjcmliZSB0aGUgYnV0dG9uLlxuICAgICAqL1xuICAgIFBhZ2VSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyTmV4dEJ1dHRvblRvSFRNTEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgbGFiZWwpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSB2b2lkIDApIHsgbGFiZWwgPSBcIk5leHRcIjsgfVxuICAgICAgICB2YXIgbmV4dEJ1dHRvbiA9IHRoaXMucmVuZGVyTmV4dEJ1dHRvbihsYWJlbCk7XG4gICAgICAgIGlmIChuZXh0QnV0dG9uKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZChuZXh0QnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIHByZXZpb3VzIGJ1dHRvbiAoaWYgYSBwcmV2aW91cyBwYWdlIGV4aXN0cykgdXNpbmcgdGhlIFtbcGFnaW5hdGlvblRlbXBsYXRlXV0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGxhYmVsIHVzZWQgdG8gZGVzY3JpYmUgdGhlIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclByZXZCdXR0b24gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSB2b2lkIDApIHsgbGFiZWwgPSBcIlByZXZcIjsgfVxuICAgICAgICBpZiAoIXRoaXMucGFnZS5pc1N0YXRpY1BhZ2luYXRpb24odGhpcy5wYWdlLnBhZ2luYXRpb25QYXJhbXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihQQUdJTkFUSU9OX0VSUk9SX01FU1NBR0UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhZ2UuaGFzUHJldigpKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGljUGFnaW5hdGlvblBhcmFtcyA9IHRoaXMucGFnZS5wYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICAgICAgdmFyIHByZXZQYWdlTnVtYmVyID0gc3RhdGljUGFnaW5hdGlvblBhcmFtcy5wYWdlTnVtYmVyIC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclBhZ2luYXRpb25FbGVtZW50KHRoaXMuX3BhZ2luYXRpb25UZW1wbGF0ZS5jc3NDbGFzc2VzLnByZXZCdXR0b24sIHByZXZQYWdlTnVtYmVyLCB0aGlzLl9wYWdpbmF0aW9uVGVtcGxhdGUucmVuZGVyUHJldiwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGEgcHJldmlvdXMgYnV0dG9uIChpZiBhIHByZXZpb3VzIHBhZ2UgZXhpc3RzKSB1c2luZyB0aGUgW1twYWdpbmF0aW9uVGVtcGxhdGVdXSBhbmQgYXBwZW5kcyBpdCB0byB0aGVcbiAgICAgKiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIEhUTUwgZWxlbWVudCB0byB3aGljaCB0aGUgYnV0dG9uIGlzIGF0dGFjaGVkLlxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgbGFiZWwgdXNlZCB0byBkZXNjcmliZSB0aGUgYnV0dG9uLlxuICAgICAqL1xuICAgIFBhZ2VSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyUHJldkJ1dHRvblRvSFRNTEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgbGFiZWwpIHtcbiAgICAgICAgaWYgKGxhYmVsID09PSB2b2lkIDApIHsgbGFiZWwgPSBcIlByZXZcIjsgfVxuICAgICAgICB2YXIgcHJldkJ1dHRvbiA9IHRoaXMucmVuZGVyUHJldkJ1dHRvbihsYWJlbCk7XG4gICAgICAgIGlmIChwcmV2QnV0dG9uKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZChwcmV2QnV0dG9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgYnV0dG9ucyB0aGF0IGFyZSB1c2VkIHRvIG5hdmlnYXRlIHRvIGEgc3BlY2lmaWMgcGFnZSB1c2luZyB0aGUgW1twYWdpbmF0aW9uVGVtcGxhdGVdXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgVGhlIG51bWJlciBvZiBwYWdlIGJ1dHRvbnMgdGhhdCBhcmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgUGFnZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJQYWdlQnV0dG9ucyA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhZ2UuaXNTdGF0aWNQYWdpbmF0aW9uKHRoaXMucGFnZS5wYWdpbmF0aW9uUGFyYW1zKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoUEFHSU5BVElPTl9FUlJPUl9NRVNTQUdFKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGljUGFnaW5hdGlvblBhcmFtcyA9IHRoaXMucGFnZS5wYWdpbmF0aW9uUGFyYW1zO1xuICAgICAgICB2YXIgbnVtYmVyT2ZQYWdlcyA9IE1hdGguY2VpbCh0aGlzLnBhZ2UubnVtYmVyT2ZSZXN1bHRzIC8gc3RhdGljUGFnaW5hdGlvblBhcmFtcy5wYWdlU2l6ZSk7XG4gICAgICAgIHZhciBmaXJzdFBhZ2VOdW1iZXIgPSB0aGlzLmNhbGN1bGF0ZUZpcnN0UGFnZU51bWJlcihhbW91bnQsIG51bWJlck9mUGFnZXMpO1xuICAgICAgICB2YXIgcmVuZGVyZWRQYWdlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFnZU51bWJlciA9IGZpcnN0UGFnZU51bWJlciArIGk7XG4gICAgICAgICAgICB2YXIgcGFnZSA9IHRoaXMucmVuZGVyUGFnaW5hdGlvbkVsZW1lbnQodGhpcy5fcGFnaW5hdGlvblRlbXBsYXRlLmNzc0NsYXNzZXMucGFnZUJ1dHRvbiwgcGFnZU51bWJlciwgdGhpcy5fcGFnaW5hdGlvblRlbXBsYXRlLnJlbmRlclBhZ2UpO1xuICAgICAgICAgICAgcmVuZGVyZWRQYWdlcy5wdXNoKHBhZ2UpO1xuICAgICAgICAgICAgaWYgKGZpcnN0UGFnZU51bWJlciArIGkgKyAxID09PSBudW1iZXJPZlBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlTnVtYmVyID0gc3RhdGljUGFnaW5hdGlvblBhcmFtcy5wYWdlTnVtYmVyO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodEN1cnJlbnRQYWdlKHJlbmRlcmVkUGFnZXMsIGN1cnJlbnRQYWdlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkUGFnZXM7XG4gICAgfTtcbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLmNhbGN1bGF0ZUZpcnN0UGFnZU51bWJlciA9IGZ1bmN0aW9uIChhbW91bnQsIG51bWJlck9mUGFnZXMpIHtcbiAgICAgICAgdmFyIHN0YXRpY1BhZ2luYXRpb25QYXJhbXMgPSB0aGlzLnBhZ2UucGFnaW5hdGlvblBhcmFtcztcbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlTnVtYmVyID0gc3RhdGljUGFnaW5hdGlvblBhcmFtcy5wYWdlTnVtYmVyO1xuICAgICAgICB2YXIgZmlyc3RQYWdlTnVtYmVyID0gY3VycmVudFBhZ2VOdW1iZXIgLSBNYXRoLmZsb29yKGFtb3VudCAvIDIpO1xuICAgICAgICBpZiAoTWF0aC5jZWlsKGFtb3VudCAvIDIpID4gbnVtYmVyT2ZQYWdlcyAtIGN1cnJlbnRQYWdlTnVtYmVyKSB7XG4gICAgICAgICAgICBmaXJzdFBhZ2VOdW1iZXIgLT0gTWF0aC5jZWlsKGFtb3VudCAvIDIpIC0gKG51bWJlck9mUGFnZXMgLSBjdXJyZW50UGFnZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGZpcnN0UGFnZU51bWJlcik7XG4gICAgfTtcbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLmhpZ2hsaWdodEN1cnJlbnRQYWdlID0gZnVuY3Rpb24gKHBhZ2VzLCBjdXJyZW50UGFnZU51bWJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwYWdlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFnZSkgeyByZXR1cm4gcGFnZS5nZXRBdHRyaWJ1dGUoXCJzbWFydC1zZWFyY2gtcGFnZS12YWx1ZVwiKSA9PT0gY3VycmVudFBhZ2VOdW1iZXIudG9TdHJpbmcoKTsgfSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcGFnZS5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgX3RoaXMuX3BhZ2luYXRpb25UZW1wbGF0ZS5jc3NDbGFzc2VzLmN1cnJlbnRQYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBidXR0b25zIHRoYXQgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdG8gYSBzcGVjaWZpYyBwYWdlIHVzaW5nIHRoZSBbW3BhZ2luYXRpb25UZW1wbGF0ZV1dIGFuZCBhcHBlbmRzIGl0XG4gICAgICogdG8gdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgSFRNTCBlbGVtZW50IHRvIHdoaWNoIHRoZSBidXR0b24gaXMgYXR0YWNoZWQuXG4gICAgICogQHBhcmFtIGFtb3VudCBUaGUgbnVtYmVyIG9mIHBhZ2UgYnV0dG9ucyB0aGF0IGFyZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclBhZ2VCdXR0b25zVG9IVE1MRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBhbW91bnQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQuYXBwbHkoZWxlbWVudCwgdGhpcy5yZW5kZXJQYWdlQnV0dG9ucyhhbW91bnQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNvbXBsZXRlIG5hdmlnYXRpb24gKHByZXZpb3VzIGJ1dHRvbiwgcGFnZSBidXR0b25zIGFuZCBuZXh0IGJ1dHRvbikgdXNpbmcgdGhlIFtbcGFnaW5hdGlvblRlbXBsYXRlXV0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IFRoZSBudW1iZXIgb2YgcGFnZSBidXR0b25zIHRoYXQgYXJlIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIFBhZ2VSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyUGFnaW5hdGlvbiA9IGZ1bmN0aW9uIChhbW91bnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgd3JhcHBlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIHRoaXMucmVuZGVyUHJldkJ1dHRvblRvSFRNTEVsZW1lbnQod3JhcHBlckVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJlbmRlclBhZ2VCdXR0b25zVG9IVE1MRWxlbWVudCh3cmFwcGVyRWxlbWVudCwgYW1vdW50KTtcbiAgICAgICAgdGhpcy5yZW5kZXJOZXh0QnV0dG9uVG9IVE1MRWxlbWVudCh3cmFwcGVyRWxlbWVudCk7XG4gICAgICAgIChfYSA9IHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9hLCB0aGlzLl9wYWdpbmF0aW9uVGVtcGxhdGUuY3NzQ2xhc3Nlcy5wYWdpbmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXJFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY29tcGxldGUgbmF2aWdhdGlvbiAocHJldmlvdXMgYnV0dG9uLCBwYWdlIGJ1dHRvbnMgYW5kIG5leHQgYnV0dG9uKSB1c2luZyB0aGUgW1twYWdpbmF0aW9uVGVtcGxhdGVdXVxuICAgICAqIGFuZCBhcHBlbmRzIHRoZW0gdG8gdGhlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgSFRNTCBlbGVtZW50IHRvIHdoaWNoIHRoZSBidXR0b24gaXMgYXR0YWNoZWQuXG4gICAgICogQHBhcmFtIGFtb3VudCBUaGUgbnVtYmVyIG9mIHBhZ2UgYnV0dG9ucyB0aGF0IGFyZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclBhZ2luYXRpb25Ub0hUTUxFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGFtb3VudCkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZCh0aGlzLnJlbmRlclBhZ2luYXRpb24oYW1vdW50KSk7XG4gICAgfTtcbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclBhZ2luYXRpb25FbGVtZW50ID0gZnVuY3Rpb24gKGNzc0NsYXNzZXMsIHZhbHVlLCByZW5kZXJGdW5jdGlvbiwgbGFiZWwpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgKF9hID0gZWxlbWVudC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgY3NzQ2xhc3Nlcyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwic21hcnQtc2VhcmNoLXBhZ2UtdmFsdWVcIiwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gcmVuZGVyRnVuY3Rpb24obGFiZWwgfHwgKHZhbHVlICsgMSkudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbGwgc2VhcmNoIHJlc3VsdHMgaW50byBhIGRpdi1lbGVtZW50IHVzaW5nIHRoZSBbW3NlYXJjaFJlc3VsdFRlbXBsYXRlXV0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlbGVtZW50IGZvciB5b3UgdG8gcGxhY2Ugd2hlcmV2ZXIgeW91IHdhbnQgaW4geW91ciBET00gVHJlZS5cbiAgICAgKi9cbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlYXJjaFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlbmRlcmVkUmVzdWx0cyA9IHRoaXMucGFnZS5zZWFyY2hSZXN1bHRzLm1hcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcmVzdWx0Qm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHJlc3VsdEJveC5pbm5lckhUTUwgPSByZXN1bHQucmVuZGVyKF90aGlzLl9zZWFyY2hSZXN1bHRUZW1wbGF0ZS50ZW1wbGF0ZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIChfYSA9IHJlc3VsdEJveC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgX3RoaXMuX3NlYXJjaFJlc3VsdFRlbXBsYXRlLmNzc0NsYXNzZXMuZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0Qm94O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHdyYXBwZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgKF9hID0gd3JhcHBlckVsZW1lbnQuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIHRoaXMuX3NlYXJjaFJlc3VsdFRlbXBsYXRlLmNzc0NsYXNzZXMud3JhcHBlcik7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LmFwcGVuZC5hcHBseSh3cmFwcGVyRWxlbWVudCwgcmVuZGVyZWRSZXN1bHRzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXJFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbGwgc2VhcmNoIHJlc3VsdHMgaW50byBhIGRpdi1lbGVtZW50IHVzaW5nIHRoZSBbW3NlYXJjaFJlc3VsdFRlbXBsYXRlXV0gYW5kIGFwcGVuZHMgaXQgdG8gdGhlXG4gICAgICogZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBodG1sIGRpdiBlbGVtZW50IHRvIGF0dGFjaCB0aGUgc2VhcmNoIHJlc3VsdHMgdG8uXG4gICAgICovXG4gICAgUGFnZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWFyY2hSZXN1bHRzVG9IVE1MRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJTZWFyY2hSZXN1bHRzKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbGwgJ0RpZCB5b3UgbWVhbicgc3VnZ2VzdGlvbnMgaW50byBhIGRpdi1lbGVtZW50IHVzaW5nIHRoZSBwcm92aWRlZCBbW2RpZFlvdU1lYW5UZW1wbGF0ZV1dLlxuICAgICAqXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgbm8gJ0RpZCB5b3UgbWVhbicgc2VhcmNoIHN1Z2dlc3Rpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gZWxlbWVudCBmb3IgeW91IHRvIHBsYWNlIHdoZXJldmVyIHlvdSB3YW50IGluIHlvdXIgRE9NIFRyZWUuXG4gICAgICovXG4gICAgUGFnZVJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJEaWRZb3VNZWFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnBhZ2UuZGlkWW91TWVhbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlcmUgYXJlIG5vIHNlYXJjaCBxdWVyeSBzdWdnZXN0aW9ucy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbmRlcmVkU3VnZ2VzdGlvbnMgPSB0aGlzLnBhZ2UuZGlkWW91TWVhbi5tYXAoZnVuY3Rpb24gKHN1Z2dlc3Rpb24pIHsgcmV0dXJuIF90aGlzLl9kaWRZb3VNZWFuVGVtcGxhdGUucmVuZGVyRGlkWW91TWVhbihzdWdnZXN0aW9uKTsgfSk7XG4gICAgICAgIHZhciByZXR1cm5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAoX2EgPSByZXR1cm5EaXYuY2xhc3NMaXN0KS5hZGQuYXBwbHkoX2EsIHRoaXMuX2RpZFlvdU1lYW5UZW1wbGF0ZS5jc3NDbGFzc2VzLndyYXBwZXIpO1xuICAgICAgICByZXR1cm5EaXYuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYWZ0ZXJiZWdpblwiLCByZW5kZXJlZFN1Z2dlc3Rpb25zLmpvaW4oXCJcIikpO1xuICAgICAgICBBcnJheS5mcm9tKHJldHVybkRpdi5jaGlsZHJlbilcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZWxlbWVudC5jbGFzc0xpc3QpLmFkZC5hcHBseShfYSwgX3RoaXMuX2RpZFlvdU1lYW5UZW1wbGF0ZS5jc3NDbGFzc2VzLmVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldHVybkRpdjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYWxsICdEaWQgeW91IG1lYW4nIHN1Z2dlc3Rpb25zIGludG8gYSBkaXYtZWxlbWVudCB1c2luZyB0aGUgcHJvdmlkZWQgW1tkaWRZb3VNZWFuVGVtcGxhdGVdXSBhbmQgYXBwZW5kc1xuICAgICAqIGl0IHRvIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgbm8gJ0RpZCB5b3UgbWVhbicgc2VhcmNoIHN1Z2dlc3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGh0bWwgZGl2IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBzdWdnZXN0aW9ucyB0by5cbiAgICAgKi9cbiAgICBQYWdlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckRpZFlvdU1lYW5Ub0hUTUxFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlckRpZFlvdU1lYW4oKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnZVJlbmRlcmVyO1xufSgpKTtcbmV4cG9ydCB7IFBhZ2VSZW5kZXJlciB9O1xuIiwiLyoqXG4gKiBSZXByZXNlbnRzIGEgc2luZ2xlIFNtYXJ0U2VhcmNoIHNlYXJjaCByZXN1bHQuXG4gKi9cbnZhciBTZWFyY2hSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VhcmNoUmVzdWx0KHNlYXJjaFJlc3VsdCwgaGlnaGxpZ2h0cykge1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHNlYXJjaFJlc3VsdDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRzID0gaGlnaGxpZ2h0c1tzZWFyY2hSZXN1bHQuaWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBzZWFyY2ggcmVzdWx0IHVzaW5nIHRoZSBwYXNzZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVGdW5jdGlvblxuICAgICAqL1xuICAgIFNlYXJjaFJlc3VsdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRlbXBsYXRlRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlRnVuY3Rpb24odGhpcy5yZXN1bHQsIHRoaXMuaGlnaGxpZ2h0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VhcmNoUmVzdWx0O1xufSgpKTtcbmV4cG9ydCB7IFNlYXJjaFJlc3VsdCB9O1xuIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmltcG9ydCB7IFBhZ2UgfSBmcm9tIFwiLi9wYWdlXCI7XG5pbXBvcnQgeyBBdXRvY29tcGxldGVXaWRnZXQgfSBmcm9tIFwiLi9hdXRvY29tcGxldGVXaWRnZXRcIjtcbmltcG9ydCB7IEFQSV9FTkRQT0lOVCwgVkVSU0lPTiB9IGZyb20gXCIuLi9kZWZhdWx0c1wiO1xuaW1wb3J0IHsgRmV0Y2hDbGllbnQgfSBmcm9tIFwiLi9mZXRjaENsaWVudFwiO1xuaW1wb3J0IHsgUGFnZVJlbmRlcmVyIH0gZnJvbSBcIi4vcGFnZVJlbmRlcmVyXCI7XG4vKipcbiAqIFdyYXBwZXIgZm9yIHRoZSBTbWFydFNlYXJjaCBwcmVwYXJlZCBzZWFyY2ggQVBJLiBNYWluIGNsYXNzIGFuZCBlbnRyeXBvaW50IGZvciB0aGlzIGxpYnJhcnkuXG4gKi9cbnZhciBTbWFydFNlYXJjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaG9zdCBUaGUgaG9zdG5hbWUgaW5jbHVkaW5nIHByb3RvY29sIChlZy46IGh0dHBzOi8vbXkuc21hcnRzZWFyY2guYmFja2VuZCkuXG4gICAgICogQHBhcmFtIHByZXBhcmVkU2VhcmNoIFRoZSBuYW1lIG9mIHRoZSBwcmVwYXJlZCBzZWFyY2ggdG8gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgYWRkaXRpb25hbCBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgb2YgdGhlIEFQSSBlbmRwb2ludCwgdGhlIHJlbmRlciBmdW5jdGlvblxuICAgICAqICBhbmQgYXV0b2NvbXBsZXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNtYXJ0U2VhcmNoKGhvc3QsIHByZXBhcmVkU2VhcmNoLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLnByZXBhcmVkU2VhcmNoID0gcHJlcGFyZWRTZWFyY2g7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYXBpRW5kcG9pbnQgPSAoKF9hID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwaUVuZHBvaW50KSB8fCBBUElfRU5EUE9JTlQ7XG4gICAgICAgIHZhciBiYXNlVVJMID0gXCJcIiArIHRoaXMuaG9zdCArIHRoaXMuYXBpRW5kcG9pbnQgKyBcIi9cIiArIHRoaXMucHJlcGFyZWRTZWFyY2ggKyBcIi9cIjtcbiAgICAgICAgdmFyIGZldGNoQ2xpZW50T3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoKF9iID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmN1c3RvbVBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuY3VzdG9tUGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXN0b21QYXJhbXMgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZldGNoQ2xpZW50T3B0aW9ucy5jdXN0b21QYXJhbXMgPSBvcHRpb25zLmN1c3RvbVBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWFyY2hDbGllbnQgPSBuZXcgRmV0Y2hDbGllbnQoYmFzZVVSTCwgZmV0Y2hDbGllbnRPcHRpb25zKTtcbiAgICAgICAgdmFyIGF1dG9jb21wbGV0ZVdpZGdldE9wdGlvbnMgPSAoX2MgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYXV0b2NvbXBsZXRlT3B0aW9ucztcbiAgICAgICAgdmFyIGF1dG9jb21wbGV0ZUNsaWVudE9wdGlvbnMgPSBmZXRjaENsaWVudE9wdGlvbnM7XG4gICAgICAgIGF1dG9jb21wbGV0ZUNsaWVudE9wdGlvbnMuYXV0b2NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgdmFyIGF1dG9jb21wbGV0ZUNsaWVudCA9IG5ldyBGZXRjaENsaWVudChiYXNlVVJMLCBhdXRvY29tcGxldGVDbGllbnRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlV2lkZ2V0ID0gbmV3IEF1dG9jb21wbGV0ZVdpZGdldChhdXRvY29tcGxldGVDbGllbnQsIGF1dG9jb21wbGV0ZVdpZGdldE9wdGlvbnMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU21hcnRTZWFyY2gucHJvdG90eXBlLCBcInNlYXJjaENsaWVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlYXJjaENsaWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNtYXJ0U2VhcmNoLnByb3RvdHlwZSwgXCJhdXRvY29tcGxldGVXaWRnZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvY29tcGxldGVXaWRnZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNtYXJ0U2VhcmNoLnZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBzZWFyY2ggcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBxdWVyeSB0ZXJtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5VGVybSBUaGUgc2VhcmNoIHRlcm0gdG8gdXNlIGluIHRoZSBhcGkgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gY3VzdG9tUGFyYW1zIE9uZSB0aW1lIHVzZSBvbmx5IHBhcmFtZXRlcnMgdG8gYXBwZW5kIHRvIHRoaXMgcmVxdWVzdFxuICAgICAqIEByZXR1cm5zIFRoZSBbW1BhZ2VdXSBjb250YWluaW5nIGFsbCB0aGUgc2VhcmNoIHJlc3VsdHMgZm9yIHRoYXQgcGFnZS5cbiAgICAgKi9cbiAgICBTbWFydFNlYXJjaC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKHF1ZXJ5VGVybSkge1xuICAgICAgICB2YXIgY3VzdG9tUGFyYW1zID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjdXN0b21QYXJhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywgcmVzcG9uc2VEYXRhLCBlcnJvcl8xO1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gKF9hID0gdGhpcy5zZWFyY2hDbGllbnQucGFyYW1ldGVyTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRPclVwZGF0ZVNlYXJjaFRlcm0ocXVlcnlUZXJtKSkuYWRkLmFwcGx5KF9hLCBjdXN0b21QYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hDbGllbnQucGFyYW1ldGVyTGlzdCA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuc2VhcmNoQ2xpZW50LmZldGNoKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZURhdGEgPSAoX2Iuc2VudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoQ2xpZW50LnBhcmFtZXRlckxpc3QgPSBwYXJhbXMuZGVsZXRlLmFwcGx5KHBhcmFtcywgY3VzdG9tUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUGFnZSh0aGlzLnNlYXJjaENsaWVudCwgcmVzcG9uc2VEYXRhKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaENsaWVudC5wYXJhbWV0ZXJMaXN0ID0gcGFyYW1zLmRlbGV0ZS5hcHBseShwYXJhbXMsIGN1c3RvbVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JfMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNtYXJ0U2VhcmNoLnByb3RvdHlwZS5tYXBQYWdlcyA9IGZ1bmN0aW9uIChyZXNwb25zZURhdGEsIGdyb3VwRmllbGQsIHF1ZXJ5VGVybSkge1xuICAgICAgICB2YXIgZ3JvdXBCeUZpZWxkID0gcmVzcG9uc2VEYXRhLmdyb3Vwcy5maW5kKGZ1bmN0aW9uIChncm91cCkgeyByZXR1cm4gZ3JvdXAubmFtZSA9PT0gZ3JvdXBGaWVsZDsgfSk7XG4gICAgICAgIGlmIChncm91cEJ5RmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTZWFyY2hlZCBncm91cCBub3QgZm91bmQhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXBwZWRQYWdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuc2VhcmNoQ2xpZW50LnBhcmFtZXRlckxpc3QuYWRkT3JVcGRhdGVTZWFyY2hUZXJtKHF1ZXJ5VGVybSk7XG4gICAgICAgIHRoaXMuc2VhcmNoQ2xpZW50LnBhcmFtZXRlckxpc3QgPSBwYXJhbXM7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBncm91cEJ5RmllbGQuZ3JvdXBzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNwb25zZURhdGEpKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLnJlc3VsdHMgPSBncm91cC5yZXN1bHRzO1xuICAgICAgICAgICAgcmVzcG9uc2UubnVtUm93cyA9IGdyb3VwLm51bVJvd3M7XG4gICAgICAgICAgICB2YXIgcGFnZSA9IG5ldyBQYWdlKHRoaXMuc2VhcmNoQ2xpZW50LCByZXNwb25zZSk7XG4gICAgICAgICAgICBtYXBwZWRQYWdlcy5zZXQoZ3JvdXAudmFsdWUsIHBhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWRQYWdlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgc2VhcmNoIHJlcXVlc3Qgd2l0aCB0aGUgcXVlcnkgdGVybSBhbmQgdGhlIGdyb3VwaW5nIG9wdGlvbnMuIEZvciB0aGUgbWV0aG9kIHRvIHdvcmssIHRoZSBmb2xsb3dpbmcgZ3Jvb3Z5XG4gICAgICogc2NyaXB0IG11c3QgYmUgYWRkZWQgdG8gdGhlIHByZXBhcmVkIHNlYXJjaC5cbiAgICAgKlxuICAgICAqIDxwcmU+PGNvZGU+XG4gICAgICogZGVmIGdyb3VwaW5nID0gXCJvZmZcIlxuICAgICAqIGdyb3VwaW5nID0gcGFyYW1ldGVyLmdldChcImdyb3VwaW5nXCIpPy5nZXQoMClcbiAgICAgKiBkZWYgZ3JvdXBGaWVsZCA9IHBhcmFtZXRlci5nZXQoXCJncm91cEZpZWxkXCIpPy5nZXQoMClcbiAgICAgKiBkZWYgZ3JvdXBMaW1pdCA9IHBhcmFtZXRlci5nZXQoXCJncm91cExpbWl0XCIpPy5nZXQoMClcbiAgICAgKlxuICAgICAqIGlmIChncm91cGluZz8uZXF1YWxzKFwib25cIikpIHtcbiAgICAgKiAgICAgc29sclF1ZXJ5LnNldChcImdyb3VwXCIsIHRydWUpXG4gICAgICogICAgIHNvbHJRdWVyeS5zZXQoXCJncm91cC5maWVsZFwiLCBncm91cEZpZWxkKVxuICAgICAqICAgICBzb2xyUXVlcnkuc2V0KFwiZ3JvdXAubGltaXRcIiwgZ3JvdXBMaW1pdClcbiAgICAgKiB9XG4gICAgICogPC9jb2RlPjwvcHJlPlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5VGVybSBUaGUgc2VhcmNoIHRlcm0gdG8gdXNlIGluIHRoZSBhcGkgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBGaWVsZCBUaGUgbmFtZSBvZiB0aGUgZmllbGQgYnkgd2hpY2ggdG8gZ3JvdXAgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0gZ3JvdXBMaW1pdCBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuIGZvciBlYWNoIGdyb3VwLlxuICAgICAqIEBwYXJhbSBjdXN0b21QYXJhbXNcbiAgICAgKiBAcmV0dXJucyBBIG1hcCBjb25zaXN0aW5nIG9mIHRoZSBncm91cCB2YWx1ZSBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgW1tQYWdlXV0gdGhhdCBjb250YWlucyB0aGUgc2VhcmNoIHJlc3VsdHMuXG4gICAgICovXG4gICAgU21hcnRTZWFyY2gucHJvdG90eXBlLnNlYXJjaFdpdGhHcm91cCA9IGZ1bmN0aW9uIChxdWVyeVRlcm0sIGdyb3VwRmllbGQsIGdyb3VwTGltaXQpIHtcbiAgICAgICAgdmFyIGN1c3RvbVBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY3VzdG9tUGFyYW1zW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeVBhcmFtcywgcGFyYW1zLCByZXNwb25zZURhdGEsIGVycm9yXzI7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBxdWVyeTogcXVlcnlUZXJtIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBncm91cGluZzogXCJvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBncm91cEZpZWxkOiBncm91cEZpZWxkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBncm91cExpbWl0OiBncm91cExpbWl0LnRvU3RyaW5nKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSAoX2EgPSAoX2IgPSB0aGlzLnNlYXJjaENsaWVudC5wYXJhbWV0ZXJMaXN0KS5hZGRPclVwZGF0ZS5hcHBseShfYiwgcXVlcnlQYXJhbXMpKS5hZGQuYXBwbHkoX2EsIGN1c3RvbVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaENsaWVudC5wYXJhbWV0ZXJMaXN0ID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zZWFyY2hDbGllbnQuZmV0Y2goKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRGF0YSA9IChfYy5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hDbGllbnQucGFyYW1ldGVyTGlzdCA9IHBhcmFtcy5kZWxldGUuYXBwbHkocGFyYW1zLCBjdXN0b21QYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMubWFwUGFnZXMocmVzcG9uc2VEYXRhLCBncm91cEZpZWxkLCBxdWVyeVRlcm0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMiA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoQ2xpZW50LnBhcmFtZXRlckxpc3QgPSBwYXJhbXMuZGVsZXRlLmFwcGx5KHBhcmFtcywgY3VzdG9tUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcl8yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zIG1hdGNoaW5nIHRoZSBnaXZlbiBwcmVmaXggZnJvbSB0aGUgYmFja2VuZC4gVGhlIHJlc3VsdGluZyBhcnJheSBhbHdheXMgaGFzXG4gICAgICogdGhlIGxlbmd0aCA8c3Ryb25nPjU8L3N0cm9uZz4gYW5kIGlzIHNvcnRlZCBieSByZWxldmFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJlZml4IFdoYXQgdGhlIHVzZXIgdHlwZWQgc28gZmFyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgU21hcnRTZWFyY2gucHJvdG90eXBlLmZldGNoQXV0b2NvbXBsZXRlTGlzdCA9IGZ1bmN0aW9uIChwcmVmaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0b2NvbXBsZXRlV2lkZ2V0LmdldEF1dG9jb21wbGV0ZUxpc3QocHJlZml4LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8vIFRPRE86IFRoZSBDU1MtY2xhc3NlcyBzaG91bGQgYmUgY29uZmlndXJhYmxlLiBUaGUgQVBJIGNvbW1lbnQgc2hvdWxkIHRoZW4gYmUgbW92ZWQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgY29uc3RhbnQuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhbiBhdXRvY29tcGxldGUgd2lkZ2V0IHRvIHRoZSBnaXZlbiBpbnB1dCBlbGVtZW50LiBUaGUgY3NzIHN0eWxpbmcgY2xhc3NlcyBhcmU6XG4gICAgICpcbiAgICAgKiA8Y29kZT4uc21hcnQtc2VhcmNoLWF1dG9jb21wbGV0ZS13aWRnZXQ8L2NvZGU+IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGRpdi1jb250YWluZXIgZGlzcGxheWluZyB0aGUgbGlzdCBvZiBhdXRvY29tcGxldGVcbiAgICAgKiAgc3VnZ2VzdGlvbnMuPGJyPlxuICAgICAqIDxjb2RlPi5zbWFydC1zZWFyY2gtYXV0b2NvbXBsZXRlLWFjdGl2ZTwvY29kZT4gd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY3Vyc29yIGZvciB0aGUgYWN0aXZlbHkgc2VsZWN0ZWQgYXV0b2NvbXBsZXRlIHdpZGdldFxuICAgICAqICAuPGJyPlxuICAgICAqIDxjb2RlPi5zbWFydC1zZWFyY2gtYXV0b2NvbXBsZXRlLWl0ZW08L2NvZGU+IHdpbGwgYmUgYXR0YWNoZWQgdG8gYSBzaW5nbGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb24uPGJyPlxuICAgICAqIDxjb2RlPiNpbnB1dEVsZW1lbnQuaWQgYXV0b2NvbXBsZXRlLXdpZGdldDwvY29kZT4gd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgYXV0b2NvbXBsZXRlLWxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRFbGVtZW50IFRoZSBpbnB1dCBlbGVtZW50IHRvIGF0dGFjaCB0aGlzIHdpZGdldCB0b1xuICAgICAqIEBwYXJhbSByZW5kZXJUYXJnZXQgT3B0aW9uYWwuIEEgZGl2IHRvIGF0dGFjaCB0aGUgYXV0b2NvbXBsZXRlIHdpZGdldCB0by4gSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbGVmdCBlbXB0eSxcbiAgICAgKiB0aGUgd2lkZ2V0IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIHBhcmVudCBvZiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBTbWFydFNlYXJjaC5wcm90b3R5cGUuYXR0YWNoQXV0b2NvbXBsZXRlV2lkZ2V0ID0gZnVuY3Rpb24gKGlucHV0RWxlbWVudCwgcmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlV2lkZ2V0LmluaXRpYWxpemVBbmRBdHRhY2goaW5wdXRFbGVtZW50LCByZW5kZXJUYXJnZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhZ2UgcmVuZGVyZXIgb2JqZWN0IHRoYXQgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIHJlbmRlciBwYWdpbmF0aW9uIGFuZCBzZWFyY2ggcmVzdWx0c1xuICAgICAqIEBwYXJhbSBwYWdlIHRoZSBwYWdlIHRvIGJlcmVuZGVyZWRcbiAgICAgKi9cbiAgICBTbWFydFNlYXJjaC5wcm90b3R5cGUuZ2V0UGFnZVJlbmRlcmVyID0gZnVuY3Rpb24gKHBhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWdlUmVuZGVyZXIocGFnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU21hcnRTZWFyY2g7XG59KCkpO1xuZXhwb3J0IHsgU21hcnRTZWFyY2ggfTtcbiIsImltcG9ydCB7IERJRF9ZT1VfTUVBTl9GVU5DVElPTiwgQ1NTX0RJRF9ZT1VfTUVBTl9FTEVNRU5ULCBDU1NfRElEX1lPVV9NRUFOX1dSQVBQRVIgfSBmcm9tIFwiLi4vLi4vZGVmYXVsdHNcIjtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGVzaXJlZCBzaGFwZSBvZiB0aGUgJ0RpZCB5b3UgbWVhbicgc2VhcmNoIHF1ZXJ5IHN1Z2dlc3Rpb25zLlxuICovXG52YXIgRGlkWW91TWVhblRlbXBsYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpZFlvdU1lYW5UZW1wbGF0ZSgpIHtcbiAgICAgICAgdGhpcy5jc3NDbGFzc2VzID0gdGhpcy5pbml0RGVmYXVsdENsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJEaWRZb3VNZWFuID0gRElEX1lPVV9NRUFOX0ZVTkNUSU9OO1xuICAgIH1cbiAgICBEaWRZb3VNZWFuVGVtcGxhdGUucHJvdG90eXBlLmluaXREZWZhdWx0Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdyYXBwZXI6IFtDU1NfRElEX1lPVV9NRUFOX1dSQVBQRVJdLFxuICAgICAgICAgICAgZWxlbWVudDogW0NTU19ESURfWU9VX01FQU5fRUxFTUVOVF0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gRGlkWW91TWVhblRlbXBsYXRlO1xufSgpKTtcbmV4cG9ydCB7IERpZFlvdU1lYW5UZW1wbGF0ZSB9O1xuIiwiaW1wb3J0IHsgQ1NTX1BBR0lOQVRJT04sIENTU19ORVhUX0JVVFRPTiwgQ1NTX1BSRVZfQlVUVE9OLCBDU1NfUEFHRV9CVVRUT04sIENTU19DVVJSRU5UX1BBR0UsIFBBR0lOQVRJT05fRlVOQ1RJT04sIH0gZnJvbSBcIi4uLy4uL2RlZmF1bHRzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHVzZXJzIGRlc2lyZWQgc2hhcGUgb2YgdGhlIHBhZ2luYXRpb24uIElmIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcGFnaW5hdGlvbiBidXR0b25zXG4gKiB5b3UgY2FuIHdyaXRlIGFuZCB1c2UgeW91ciBjdXN0b20gcmVuZGVyIGZ1bmN0aW9uLiBUaGUgZGVmYXVsdCBhcHBlYXJhbmNlIHdvdWxkIGJlXG4gKiBgYGBcbiAqIHByZXYgMSAyIDMgNCA1IG5leHRcbiAqIGBgYFxuICogSWYgeW91IHdhbnRlZCB5b3VyIHBhZ2luYXRpb24gdG8gaW5zdGVhZCBsb29rIGxpa2UgdGhpc1xuICogYGBgXG4gKiA8IDEgMiAzIDQgNSA+XG4gKiBgYGBcbiAqIFlvdSB3b3VsZCBoYXZlIHRvIHdyaXRlIGN1c3RvbSByZW5kZXJOZXh0IGFuZCByZW5kZXJQcmV2IGZ1bmN0aW9ucyBsaWtlIHRoaXNcbiAqIGBgYFxuICogcGFnZS5wYWdpbmF0aW9uVGVtcGxhdGUucmVuZGVyTmV4dCA9ICh2YWx1ZSkgPT4ge1xuICogICAgICByZXR1cm4gYD5gXG4gKiB9XG4gKiBwYWdlLnBhZ2luYXRpb25UZW1wbGF0ZS5yZW5kZXJQcmV2ID0gKHZhbHVlKSA9PiB7XG4gKiAgICAgIHJldHVybiBgPGBcbiAqIH1cbiAqIGBgYFxuICogV2hhdGV2ZXIgZ2V0cyByZXR1cm5lZCBieSB5b3VyIGZ1bmN0aW9uIHdpbGwgYmUgd3JhcHBlZCBpbiBhIFxcPGxpPiB0YWdcbiAqL1xudmFyIFBhZ2luYXRpb25UZW1wbGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVuZGVyUGFnaW5hdGlvbkZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB0byByZW5kZXIgYSBzaW5nbGUgcGFnaW5hdGlvbiBlbGVtZW50LCBlZy4gdGhlIHByZXZpb3VzIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0gY3NzQ2xhc3NlcyBUaGUgQ1NTIGNsYXNzZXMgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhZ2luYXRpb25UZW1wbGF0ZSgpIHtcbiAgICAgICAgdGhpcy5jc3NDbGFzc2VzID0gdGhpcy5pbml0RGVmYXVsdENsYXNzZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJOZXh0ID0gUEFHSU5BVElPTl9GVU5DVElPTjtcbiAgICAgICAgdGhpcy5yZW5kZXJQYWdlID0gUEFHSU5BVElPTl9GVU5DVElPTjtcbiAgICAgICAgdGhpcy5yZW5kZXJQcmV2ID0gUEFHSU5BVElPTl9GVU5DVElPTjtcbiAgICB9XG4gICAgUGFnaW5hdGlvblRlbXBsYXRlLnByb3RvdHlwZS5pbml0RGVmYXVsdENsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uOiBbQ1NTX1BBR0lOQVRJT05dLFxuICAgICAgICAgICAgbmV4dEJ1dHRvbjogW0NTU19ORVhUX0JVVFRPTl0sXG4gICAgICAgICAgICBwcmV2QnV0dG9uOiBbQ1NTX1BSRVZfQlVUVE9OXSxcbiAgICAgICAgICAgIHBhZ2VCdXR0b246IFtDU1NfUEFHRV9CVVRUT05dLFxuICAgICAgICAgICAgY3VycmVudFBhZ2U6IFtDU1NfQ1VSUkVOVF9QQUdFXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBQYWdpbmF0aW9uVGVtcGxhdGU7XG59KCkpO1xuZXhwb3J0IHsgUGFnaW5hdGlvblRlbXBsYXRlIH07XG4iLCJpbXBvcnQgeyBDU1NfU0VBUkNIX1JFU1VMVF9XUkFQUEVSLCBDU1NfU0VBUkNIX1JFU1VMVF9FTEVNRU5ULCBTRUFSQ0hfUkVTVUxUX0ZVTkNUSU9OIH0gZnJvbSBcIi4uLy4uL2RlZmF1bHRzXCI7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHVzZXJzIGRlc2lyZWQgc2hhcGUgb2YgdGhlIFtbU2VhcmNoUmVzdWx0XV0gZGF0YS5cbiAqL1xudmFyIFNlYXJjaFJlc3VsdFRlbXBsYXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlYXJjaFJlc3VsdFRlbXBsYXRlKCkge1xuICAgICAgICB0aGlzLmNzc0NsYXNzZXMgPSB0aGlzLmluaXREZWZhdWx0Q2xhc3NlcygpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlRnVuY3Rpb24gPSBTRUFSQ0hfUkVTVUxUX0ZVTkNUSU9OO1xuICAgIH1cbiAgICBTZWFyY2hSZXN1bHRUZW1wbGF0ZS5wcm90b3R5cGUuaW5pdERlZmF1bHRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd3JhcHBlcjogW0NTU19TRUFSQ0hfUkVTVUxUX1dSQVBQRVJdLFxuICAgICAgICAgICAgZWxlbWVudDogW0NTU19TRUFSQ0hfUkVTVUxUX0VMRU1FTlRdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNlYXJjaFJlc3VsdFRlbXBsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFNlYXJjaFJlc3VsdFRlbXBsYXRlIH07XG4iLCJpbXBvcnQgeyBMaXN0IH0gZnJvbSBcImltbXV0YWJsZVwiO1xuLyoqXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIFVSTCBwYXJhbWV0ZXJzIHVzZWQgd2l0aGluIGVhY2ggcmVxdWVzdCBzZW50IHRvIHRoZSBTbWFydFNlYXJjaCBiYWNrZW5kLlxuICovXG52YXIgVVJMUGFyYW1MaXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVSTFBhcmFtTGlzdChwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fbGlzdCA9IExpc3QoW10pLmNvbmNhdChwYXJhbXMgfHwgW10pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVVJMUGFyYW1MaXN0LnByb3RvdHlwZSwgXCJsaXN0XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRhaW5zIHRoZSBwYXJhbWV0ZXJzIHRoYXQgYXJlIGdvaW5nIHRvIGJlIHJlZmVyZW5jZWQgaW4gdGhlIG1ldGhvZHMgZG93biBiZWxvdy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHBhcmFtZXRlcnMgb3IgdXBkYXRlcyB0aGVtIGlmIHRoZXkgYWxyZWFkeSBleGlzdC5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJhbWV0ZXJzIHdpdGggdGhlIHNhbWUga2V5LCBvbmx5IHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdXBkYXRlZC4gSWYgeW91IHdhbnQgdG8gdXBkYXRlXG4gICAgICogbXVsdGlwbGUgcGFyYW1ldGVycyB3aXRoIHRoZSBzYW1lIGtleSB1c2UgdGhlIFtbZGVsZXRlQWxsXV0gZnVuY3Rpb24gZmlyc3QgdGhlbiBhZGQgdGhlIG5ldyBwYXJhbWV0ZXJzIHVzaW5nXG4gICAgICogW1thZGRdXVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgdG8gYWRkIG9yIHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IGxpc3Qgd2l0aCB0aGUgbmV3IG9yIG1vZGlmaWVkIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgVVJMUGFyYW1MaXN0LnByb3RvdHlwZS5hZGRPclVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBkYXRlZExpc3QgPSBuZXcgVVJMUGFyYW1MaXN0KHRoaXMubGlzdCk7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgcGFyYW1ldGVyc18xID0gcGFyYW1ldGVyczsgX2EgPCBwYXJhbWV0ZXJzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1ldGVyc18xW19hXTtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmNvbnZlcnQocGFyYW1ldGVyKVswXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHVwZGF0ZWRMaXN0LmdldEluZGV4Rm9yS2V5KGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZExpc3QgPSBuZXcgVVJMUGFyYW1MaXN0KHVwZGF0ZWRMaXN0Lmxpc3Quc2V0KGluZGV4LCBwYXJhbWV0ZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRMaXN0ID0gdXBkYXRlZExpc3QuYWRkKHBhcmFtZXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRMaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNlYXJjaCB0ZXJtIGFzIHBhcmFtZXRlciAod2l0aCB0aGUga2V5ICpxdWVyeSopIG9yIHVwZGF0ZXMgaXQgaWYgYSBzZWFyY2ggdGVybSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWFyY2hUZXJtIFRoZSBzZWFyY2ggdGVybSB0byBhZGQgb3IgdXBkYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgbGlzdCB3aXRoIHRoZSBuZXcgb3IgbW9kaWZpZWQgc2VhcmNoIHRlcm0uIElmIHRoZSBzZWFyY2ggdGVybSBpcyBlbXB0eSwgYSBjb3B5IG9mIHRoZSBvcmlnaW5hbFxuICAgICAqIGxpc3Qgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBVUkxQYXJhbUxpc3QucHJvdG90eXBlLmFkZE9yVXBkYXRlU2VhcmNoVGVybSA9IGZ1bmN0aW9uIChzZWFyY2hUZXJtKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0O1xuICAgICAgICBpZiAoIXNlYXJjaFRlcm0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMUGFyYW1MaXN0KGxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE9yVXBkYXRlKHsgcXVlcnk6IHNlYXJjaFRlcm0gfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgdG8gYWRkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgbGlzdCB3aXRoIHRoZSBuZXcgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBVUkxQYXJhbUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMubGlzdC5jb25jYXQocGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiBuZXcgVVJMUGFyYW1MaXN0KGxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzaW5nbGUgW1tVUkxQYXJhbV1dIGludG8gYSBzdHJpbmcgYXJyYXkgb2YgbGVuZ3RoIDIsIHdpdGgga2V5IGF0IHBvc2l0aW9uIDAgYW5kIHZhbHVlIGF0IHBvc2l0aW9uIDEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyIFRoZSBwYXJhbWV0ZXIgdG8gY29udmVydC5cbiAgICAgKi9cbiAgICBVUkxQYXJhbUxpc3QucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAocGFyYW1ldGVyKSB7XG4gICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXIpWzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbWV0ZXJba2V5XTtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IHBhcmFtZXRlciBtYXRjaGluZyB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBzZWFyY2hlZCBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgVVJMUGFyYW1MaXN0LnByb3RvdHlwZS5nZXRPbmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuZmluZChmdW5jdGlvbiAocGFyYW1ldGVyKSB7IHJldHVybiBPYmplY3Qua2V5cyhwYXJhbWV0ZXIpWzBdID09PSBrZXk7IH0pIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBwYXJhbWV0ZXJzIG1hdGNoaW5nIHRoZSBnaXZlbiBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIHNlYXJjaGVkIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgVVJMUGFyYW1MaXN0LnByb3RvdHlwZS5nZXRNYW55ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmZpbHRlcihmdW5jdGlvbiAocGFyYW1ldGVyKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVyS2V5ID0gX3RoaXMuY29udmVydChwYXJhbWV0ZXIpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gcGFyYW1ldGVyS2V5O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYWxsIHBhcmFtZXRlcnMgbWF0Y2hpbmcgdGhlIGdpdmVuIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgcGFyYW1ldGVycyB0byBiZSBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgbGlzdCB3aXRob3V0IHRoZSBkZWxldGVkIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgVVJMUGFyYW1MaXN0LnByb3RvdHlwZS5kZWxldGVBbGwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMUGFyYW1MaXN0KHRoaXMubGlzdC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtZXRlcikgeyByZXR1cm4gT2JqZWN0LmtleXMocGFyYW1ldGVyKVswXSAhPT0ga2V5OyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFsbCBwYXJhbWV0ZXJzIG1hdGNoaW5nIGJvdGgga2V5cyBhbmQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgdG8gYmUgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQSBuZXcgbGlzdCB3aXRob3V0IHRoZSBkZWxldGVkIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgVVJMUGFyYW1MaXN0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWRMaXN0ID0gbmV3IFVSTFBhcmFtTGlzdCh0aGlzLmxpc3QpO1xuICAgICAgICBwYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdXBkYXRlZExpc3QuZ2V0SW5kZXhGb3JQYXJhbWV0ZXIocGFyYW1ldGVyKTtcbiAgICAgICAgICAgIHVwZGF0ZWRMaXN0ID0gbmV3IFVSTFBhcmFtTGlzdCh1cGRhdGVkTGlzdC5saXN0LmRlbGV0ZShpbmRleCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRMaXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHN0b3JlZCBwYXJhbWV0ZXJzIGludG8gYSBzdHJpbmcgdGhhdCBjYW4gYmUgYXBwZW5kZWQgdG8gYSBVUkwuXG4gICAgICovXG4gICAgVVJMUGFyYW1MaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgICAgICAgICAgdmFyIGtleSA9IF90aGlzLmNvbnZlcnQocGFyYW1ldGVyKVswXTtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBwYXJhbWV0ZXJba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBVUkxQYXJhbUxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QudG9BcnJheSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZmlyc3QgcGFyYW1ldGVyIG1hdGNoaW5nIHRoZSBrZXkgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgb25seSBpZiB5b3Uga25vdyB5b3VyIHBhcmFtZXRlciBpcyB1bmlxdWUuIEZvciB1cGRhdGluZyBhbGwgcGFyYW1ldGVycyB3aXRoIHRoZSBzYW1lIGtleSwgZGVsZXRlIHRoZW1cbiAgICAgKiBmaXJzdCB1c2luZyBbW2RlbGV0ZUFsbF1dIGFuZCB0aGVuIGFkZCB0aGUgbmV3IG9uZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyIFRoZSBwYXJhbWV0ZXIgdG8gdXBkYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgbGlzdCB3aXRoIHRoZSB1cGRhdGVkIHBhcmFtZXRlci4gSWYgdGhlIHBhcmFtZXRlcidzIGtleSBkb2Vzbid0IGV4aXN0LCBhIGNvcHkgb2YgdGhlIG9yaWdpbmFsIGxpc3RcbiAgICAgKiB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqL1xuICAgIFVSTFBhcmFtTGlzdC5wcm90b3R5cGUudXBkYXRlRmlyc3QgPSBmdW5jdGlvbiAocGFyYW1ldGVyKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0O1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5jb252ZXJ0KHBhcmFtZXRlcilbMF07XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXhGb3JLZXkoa2V5KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVUkxQYXJhbUxpc3QobGlzdC5zZXQoaW5kZXgsIHBhcmFtZXRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVVJMUGFyYW1MaXN0KGxpc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHNwZWNpZmljIHBhcmFtZXRlciBtYXRjaGluZyBib3RoIGtleSBhbmQgdmFsdWUgd2l0aCB0aGUgZ2l2ZW4gbmV3IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvbGRQYXJhbWV0ZXIgVGhlIHBhcmFtZXRlciB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIG5ld1BhcmFtZXRlciBUaGUgbmV3IHBhcmFtZXRlciB0byB1cGRhdGUgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBsaXN0IHdpdGggdGhlIHVwZGF0ZWQgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIFVSTFBhcmFtTGlzdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9sZFBhcmFtZXRlciwgbmV3UGFyYW1ldGVyKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4Rm9yUGFyYW1ldGVyKG9sZFBhcmFtZXRlcik7XG4gICAgICAgIHJldHVybiBuZXcgVVJMUGFyYW1MaXN0KGxpc3Quc2V0KGluZGV4LCBuZXdQYXJhbWV0ZXIpKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVVJMUGFyYW1MaXN0LnByb3RvdHlwZS5nZXRJbmRleEZvcktleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5maW5kSW5kZXgoZnVuY3Rpb24gKGxpc3RQYXJhbSkge1xuICAgICAgICAgICAgdmFyIGxpc3RQYXJhbUtleSA9IE9iamVjdC5rZXlzKGxpc3RQYXJhbSlbMF07XG4gICAgICAgICAgICByZXR1cm4gbGlzdFBhcmFtS2V5ID09PSBrZXk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVUkxQYXJhbUxpc3QucHJvdG90eXBlLmdldEluZGV4Rm9yUGFyYW1ldGVyID0gZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmZpbmRJbmRleChmdW5jdGlvbiAobGlzdFBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5jb252ZXJ0KGxpc3RQYXJhbSksIGxpc3RQYXJhbUtleSA9IF9hWzBdLCBsaXN0UGFyYW1WYWx1ZSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMuY29udmVydChwYXJhbWV0ZXIpLCBrZXkgPSBfYlswXSwgdmFsdWUgPSBfYlsxXTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0UGFyYW1LZXkgPT09IGtleSAmJiBsaXN0UGFyYW1WYWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVSTFBhcmFtTGlzdDtcbn0oKSk7XG5leHBvcnQgeyBVUkxQYXJhbUxpc3QgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5CYWNvbiA9IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbm9wKCkgeyB9XG4vKiogQGhpZGRlbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykgeyByZXR1cm4geHMgaW5zdGFuY2VvZiBBcnJheTsgfTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBpc09ic2VydmFibGUoeCkge1xuICAgIHJldHVybiB4ICYmIHguX2lzT2JzZXJ2YWJsZTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFsbCh4cywgZikge1xuICAgIGZvciAodmFyIGkgPSAwLCB4OyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeCA9IHhzW2ldO1xuICAgICAgICBpZiAoIWYoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBhbHdheXMoeCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfTsgfVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFueSh4cywgZikge1xuICAgIGZvciAodmFyIGkgPSAwLCB4OyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeCA9IHhzW2ldO1xuICAgICAgICBpZiAoZih4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGJpbmQoZm4sIG1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKHhzLCB4KSB7IHJldHVybiBpbmRleE9mKHhzLCB4KSAhPT0gLTE7IH1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBlYWNoKHhzLCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHhzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeHMsIGtleSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHhzW2tleV07XG4gICAgICAgICAgICBmKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGVtcHR5KHhzKSB7IHJldHVybiB4cy5sZW5ndGggPT09IDA7IH1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBmaWx0ZXIoZiwgeHMpIHtcbiAgICB2YXIgZmlsdGVyZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgeDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHggPSB4c1tpXTtcbiAgICAgICAgaWYgKGYoeCkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGZsYXRNYXAoZiwgeHMpIHtcbiAgICByZXR1cm4gZm9sZCh4cywgW10sIChmdW5jdGlvbiAoeXMsIHgpIHtcbiAgICAgICAgcmV0dXJuIHlzLmNvbmNhdChmKHgpKTtcbiAgICB9KSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZmxpcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBmKGIsIGEpOyB9O1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGZvbGQoeHMsIHNlZWQsIGYpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgeDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHggPSB4c1tpXTtcbiAgICAgICAgc2VlZCA9IGYoc2VlZCwgeCk7XG4gICAgfVxuICAgIHJldHVybiBzZWVkO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGhlYWQoeHMpIHtcbiAgICByZXR1cm4geHNbMF07XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gaWQoeCkgeyByZXR1cm4geDsgfVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGluZGV4T2ZEZWZhdWx0KHhzLCB4KSB7IHJldHVybiB4cy5pbmRleE9mKHgpOyB9XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gaW5kZXhPZkZhbGxiYWNrKHhzLCB4KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHk7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB5ID0geHNbaV07XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA/IGluZGV4T2ZEZWZhdWx0IDogaW5kZXhPZkZhbGxiYWNrO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGluZGV4V2hlcmUoeHMsIGYpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgeTsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHkgPSB4c1tpXTtcbiAgICAgICAgaWYgKGYoeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGYpIHsgcmV0dXJuIHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCI7IH1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBsYXN0KHhzKSB7IHJldHVybiB4c1t4cy5sZW5ndGggLSAxXTsgfVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIG1hcChmLCB4cykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgeDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHggPSB4c1tpXTtcbiAgICAgICAgcmVzdWx0LnB1c2goZih4KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbmVnYXRlKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiAhZih4KTsgfTsgfVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHJlbW92ZSh4LCB4cykge1xuICAgIHZhciBpID0gaW5kZXhPZih4cywgeCk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICByZXR1cm4geHMuc3BsaWNlKGksIDEpO1xuICAgIH1cbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0YWlsKHhzKSB7XG4gICAgcmV0dXJuIHhzLnNsaWNlKDEsIHhzLmxlbmd0aCk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdG9BcnJheSh4cykgeyByZXR1cm4gKGlzQXJyYXkoeHMpID8geHMgOiBbeHNdKTsgfVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHRvRnVuY3Rpb24oZikge1xuICAgIGlmICh0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gZjsgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0b1N0cmluZyhvYmopIHtcbiAgICB2YXIgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuICAgIHRyeSB7XG4gICAgICAgIHJlY3Vyc2lvbkRlcHRoKys7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2lvbkRlcHRoID4gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlsuLl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIltcIiArIG1hcCh0b1N0cmluZywgb2JqKS50b1N0cmluZygpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKChvYmogIT0gbnVsbCA/IG9iai50b1N0cmluZyA6IHZvaWQgMCkgIT0gbnVsbCkgJiYgb2JqLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2lvbkRlcHRoID4gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInsuLn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNQcm9wLmNhbGwob2JqLCBrZXkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godG9TdHJpbmcoa2V5KSArIFwiOlwiICsgdG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIntcIiArIHJlc3VsdHMgKyBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHJlY3Vyc2lvbkRlcHRoLS07XG4gICAgfVxufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHdpdGhvdXQoeCwgeHMpIHtcbiAgICByZXR1cm4gZmlsdGVyKChmdW5jdGlvbiAoeSkgeyByZXR1cm4geSAhPT0geDsgfSksIHhzKTtcbn1cbnZhciBfID0ge1xuICAgIGluZGV4T2Y6IGluZGV4T2YsXG4gICAgaW5kZXhXaGVyZTogaW5kZXhXaGVyZSxcbiAgICBoZWFkOiBoZWFkLFxuICAgIGFsd2F5czogYWx3YXlzLFxuICAgIG5lZ2F0ZTogbmVnYXRlLFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICB0YWlsOiB0YWlsLFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIG1hcDogbWFwLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBjb250YWluczogY29udGFpbnMsXG4gICAgaWQ6IGlkLFxuICAgIGxhc3Q6IGxhc3QsXG4gICAgYWxsOiBhbGwsXG4gICAgYW55OiBhbnksXG4gICAgd2l0aG91dDogd2l0aG91dCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBmb2xkOiBmb2xkLFxuICAgIGZsYXRNYXA6IGZsYXRNYXAsXG4gICAgYmluZDogYmluZCxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIHRvRnVuY3Rpb246IHRvRnVuY3Rpb24sXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG59O1xudmFyIHJlY3Vyc2lvbkRlcHRoID0gMDtcblxuLyoqXG4gKiBSZXBseSBmb3IgXCJtb3JlIGRhdGEsIHBsZWFzZVwiLlxuICovXG52YXIgbW9yZSA9IHVuZGVmaW5lZDtcbi8qKlxuICogUmVwbHkgZm9yIFwibm8gbW9yZSBkYXRhLCBwbGVhc2VcIi5cbiAqL1xudmFyIG5vTW9yZSA9IFwiPG5vLW1vcmU+XCI7XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBhc3NlcnQobWVzc2FnZSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBhc3NlcnRFdmVudFN0cmVhbShldmVudCkge1xuICAgIGlmICghKGV2ZW50ICE9IG51bGwgPyBldmVudC5faXNFdmVudFN0cmVhbSA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIEV2ZW50U3RyZWFtIDogXCIgKyBldmVudCk7XG4gICAgfVxufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFzc2VydE9ic2VydmFibGUob2JzZXJ2YWJsZSkge1xuICAgIGlmICghKG9ic2VydmFibGUgIT0gbnVsbCA/IG9ic2VydmFibGUuX2lzT2JzZXJ2YWJsZSA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIE9ic2VydmFibGUgOiBcIiArIG9ic2VydmFibGUpO1xuICAgIH1cbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGFzc2VydChcIm5vdCBhIGZ1bmN0aW9uIDogXCIgKyBmLCBfLmlzRnVuY3Rpb24oZikpO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFzc2VydEFycmF5KHhzKSB7XG4gICAgaWYgKCFpc0FycmF5KHhzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXkgOiBcIiArIHhzKTtcbiAgICB9XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9Bcmd1bWVudHMoYXJncykge1xuICAgIHJldHVybiBhc3NlcnQoXCJubyBhcmd1bWVudHMgc3VwcG9ydGVkXCIsIGFyZ3MubGVuZ3RoID09PSAwKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbnZhciBkZWZhdWx0U2NoZWR1bGVyID0ge1xuICAgIHNldFRpbWVvdXQ6IGZ1bmN0aW9uIChmLCBkKSB7IHJldHVybiBzZXRUaW1lb3V0KGYsIGQpOyB9LFxuICAgIHNldEludGVydmFsOiBmdW5jdGlvbiAoZiwgaSkgeyByZXR1cm4gc2V0SW50ZXJ2YWwoZiwgaSk7IH0sXG4gICAgY2xlYXJJbnRlcnZhbDogZnVuY3Rpb24gKGlkKSB7IHJldHVybiBjbGVhckludGVydmFsKGlkKTsgfSxcbiAgICBjbGVhclRpbWVvdXQ6IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTsgfSxcbiAgICBub3c6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9XG59O1xudmFyIEdsb2JhbFNjaGVkdWxlciA9IHtcbiAgICBzY2hlZHVsZXI6IGRlZmF1bHRTY2hlZHVsZXJcbn07XG5mdW5jdGlvbiBnZXRTY2hlZHVsZXIoKSB7XG4gICAgcmV0dXJuIEdsb2JhbFNjaGVkdWxlci5zY2hlZHVsZXI7XG59XG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIobmV3U2NoZWR1bGVyKSB7XG4gICAgR2xvYmFsU2NoZWR1bGVyLnNjaGVkdWxlciA9IG5ld1NjaGVkdWxlcjtcbn1cblxudmFyIHJvb3RFdmVudCA9IHVuZGVmaW5lZDtcbnZhciB3YWl0ZXJPYnMgPSBbXTtcbnZhciB3YWl0ZXJzID0ge307XG52YXIgYWZ0ZXJzU3RhY2sgPSBbXTtcbnZhciBhZnRlcnNTdGFja0hlaWdodCA9IDA7XG52YXIgZmx1c2hlZCA9IHt9O1xudmFyIHByb2Nlc3NpbmdBZnRlcnMgPSBmYWxzZTtcbmZ1bmN0aW9uIHRvU3RyaW5nJDEoKSB7XG4gICAgcmV0dXJuIF8udG9TdHJpbmcoeyByb290RXZlbnQ6IHJvb3RFdmVudCwgcHJvY2Vzc2luZ0FmdGVyczogcHJvY2Vzc2luZ0FmdGVycywgd2FpdGVyT2JzOiB3YWl0ZXJPYnMsIHdhaXRlcnM6IHdhaXRlcnMsIGFmdGVyc1N0YWNrOiBhZnRlcnNTdGFjaywgYWZ0ZXJzU3RhY2tIZWlnaHQ6IGFmdGVyc1N0YWNrSGVpZ2h0LCBmbHVzaGVkOiBmbHVzaGVkIH0pO1xufVxuZnVuY3Rpb24gZW5zdXJlU3RhY2tIZWlnaHQoaCkge1xuICAgIGlmIChoIDw9IGFmdGVyc1N0YWNrSGVpZ2h0KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFhZnRlcnNTdGFja1toIC0gMV0pIHtcbiAgICAgICAgYWZ0ZXJzU3RhY2tbaCAtIDFdID0gW1tdLCAwXTtcbiAgICB9XG4gICAgYWZ0ZXJzU3RhY2tIZWlnaHQgPSBoO1xufVxuZnVuY3Rpb24gaXNJblRyYW5zYWN0aW9uKCkge1xuICAgIHJldHVybiByb290RXZlbnQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNvb25CdXROb3RZZXQob2JzLCBmKSB7XG4gICAgaWYgKHJvb3RFdmVudCkge1xuICAgICAgICAvLyBJZiBpbiB0cmFuc2FjdGlvbiAtPiBwZXJmb3JtIHdpdGhpbiB0cmFuc2FjdGlvblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdpbiB0eCcpXG4gICAgICAgIHdoZW5Eb25lV2l0aChvYnMsIGYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIC0+IHBlcmZvcm0gd2l0aCB0aW1lb3V0XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3dpdGggdGltZW91dCcpXG4gICAgICAgIEdsb2JhbFNjaGVkdWxlci5zY2hlZHVsZXIuc2V0VGltZW91dChmLCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZnRlclRyYW5zYWN0aW9uKG9icywgZikge1xuICAgIGlmIChyb290RXZlbnQgfHwgcHJvY2Vzc2luZ0FmdGVycykge1xuICAgICAgICBlbnN1cmVTdGFja0hlaWdodCgxKTtcbiAgICAgICAgdmFyIHN0YWNrSW5kZXhGb3JUaGlzT2JzID0gMDtcbiAgICAgICAgd2hpbGUgKHN0YWNrSW5kZXhGb3JUaGlzT2JzIDwgYWZ0ZXJzU3RhY2tIZWlnaHQgLSAxKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbnNPYnMob2JzLCBhZnRlcnNTdGFja1tzdGFja0luZGV4Rm9yVGhpc09ic11bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBvYnNlcnZhYmxlIGlzIGFscmVhZHkgYmVpbmcgcHJvY2Vzc2VkIGF0IHRoaXMgc3RhY2sgaW5kZXggLT4gdXNlIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrSW5kZXhGb3JUaGlzT2JzKys7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3RGcm9tU3RhY2sgPSBhZnRlcnNTdGFja1tzdGFja0luZGV4Rm9yVGhpc09ic11bMF07XG4gICAgICAgIGxpc3RGcm9tU3RhY2sucHVzaChbb2JzLCBmXSk7XG4gICAgICAgIGlmICghcm9vdEV2ZW50KSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJzKCk7IC8vIHdvdWxkbid0IGJlIGNhbGxlZCBvdGhlcndpc2VcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb250YWluc09icyhvYnMsIGFmdGVyc0xpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFmdGVyc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFmdGVyc0xpc3RbaV1bMF0uaWQgPT0gb2JzLmlkKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NBZnRlcnMoKSB7XG4gICAgdmFyIHN0YWNrU2l6ZUF0U3RhcnQgPSBhZnRlcnNTdGFja0hlaWdodDtcbiAgICBpZiAoIXN0YWNrU2l6ZUF0U3RhcnQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgaXNSb290ID0gIXByb2Nlc3NpbmdBZnRlcnM7XG4gICAgcHJvY2Vzc2luZ0FmdGVycyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKGFmdGVyc1N0YWNrSGVpZ2h0ID49IHN0YWNrU2l6ZUF0U3RhcnQpIHsgLy8gdG8gcHJldmVudCBzaW5raW5nIHRvIGxldmVscyBzdGFydGVkIGJ5IG90aGVyc1xuICAgICAgICAgICAgdmFyIHRvcE9mU3RhY2sgPSBhZnRlcnNTdGFja1thZnRlcnNTdGFja0hlaWdodCAtIDFdO1xuICAgICAgICAgICAgaWYgKCF0b3BPZlN0YWNrKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RhY2sgdG9wOiBcIiArIHRvcE9mU3RhY2spO1xuICAgICAgICAgICAgdmFyIHRvcEFmdGVycyA9IHRvcE9mU3RhY2tbMF0sIGluZGV4ID0gdG9wT2ZTdGFja1sxXTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRvcEFmdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0b3BBZnRlcnNbaW5kZXhdLCBhZnRlciA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHRvcE9mU3RhY2tbMV0rKzsgLy8gaW5jcmVhc2UgaW5kZXggYWxyZWFkeSBoZXJlIHRvIGluZGljYXRlIHRoYXQgdGhpcyBsZXZlbCBpcyBiZWluZyBwcm9jZXNzZWRcbiAgICAgICAgICAgICAgICBlbnN1cmVTdGFja0hlaWdodChhZnRlcnNTdGFja0hlaWdodCArIDEpOyAvLyB0byBlbnN1cmUgdGhlcmUncyBhIG5ldyBsZXZlbCBmb3IgcmVjdXJzaXZlbHkgYWRkZWQgYWZ0ZXJzXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxTdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYWZ0ZXJzU3RhY2tIZWlnaHQgPiBzdGFja1NpemVBdFN0YXJ0ICYmIGFmdGVyc1N0YWNrW2FmdGVyc1N0YWNrSGVpZ2h0IC0gMV1bMF0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyc1N0YWNrSGVpZ2h0LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbFN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyc1N0YWNrID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlcnNTdGFja0hlaWdodCA9IDA7IC8vIHJlc2V0IHN0YXRlIHRvIHByZXZlbnQgc3RhbGUgdXBkYXRlcyBhZnRlciBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wT2ZTdGFja1swXSA9IFtdO1xuICAgICAgICAgICAgICAgIHRvcE9mU3RhY2tbMV0gPSAwOyAvLyByZXNldCB0aGlzIGxldmVsXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmIChpc1Jvb3QpXG4gICAgICAgICAgICBwcm9jZXNzaW5nQWZ0ZXJzID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gd2hlbkRvbmVXaXRoKG9icywgZikge1xuICAgIGlmIChyb290RXZlbnQpIHtcbiAgICAgICAgdmFyIG9ic1dhaXRlcnMgPSB3YWl0ZXJzW29icy5pZF07XG4gICAgICAgIGlmIChvYnNXYWl0ZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic1dhaXRlcnMgPSB3YWl0ZXJzW29icy5pZF0gPSBbZl07XG4gICAgICAgICAgICByZXR1cm4gd2FpdGVyT2JzLnB1c2gob2JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNXYWl0ZXJzLnB1c2goZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKHdhaXRlck9icy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZsdXNoV2FpdGVycygwLCB0cnVlKTtcbiAgICB9XG4gICAgZmx1c2hlZCA9IHt9O1xufVxuZnVuY3Rpb24gZmx1c2hXYWl0ZXJzKGluZGV4LCBkZXBzKSB7XG4gICAgdmFyIG9icyA9IHdhaXRlck9ic1tpbmRleF07XG4gICAgdmFyIG9ic0lkID0gb2JzLmlkO1xuICAgIHZhciBvYnNXYWl0ZXJzID0gd2FpdGVyc1tvYnNJZF07XG4gICAgd2FpdGVyT2JzLnNwbGljZShpbmRleCwgMSk7XG4gICAgZGVsZXRlIHdhaXRlcnNbb2JzSWRdO1xuICAgIGlmIChkZXBzICYmIHdhaXRlck9icy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZsdXNoRGVwc09mKG9icyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBmOyBpIDwgb2JzV2FpdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmID0gb2JzV2FpdGVyc1tpXTtcbiAgICAgICAgZigpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZsdXNoRGVwc09mKG9icykge1xuICAgIGlmIChmbHVzaGVkW29icy5pZF0pXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZGVwcyA9IG9icy5pbnRlcm5hbERlcHMoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgZGVwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZXAgPSBkZXBzW2ldO1xuICAgICAgICBmbHVzaERlcHNPZihkZXApO1xuICAgICAgICBpZiAod2FpdGVyc1tkZXAuaWRdKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBfLmluZGV4T2Yod2FpdGVyT2JzLCBkZXApO1xuICAgICAgICAgICAgZmx1c2hXYWl0ZXJzKGluZGV4LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2hlZFtvYnMuaWRdID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGluVHJhbnNhY3Rpb24oZXZlbnQsIGNvbnRleHQsIGYsIGFyZ3MpIHtcbiAgICBpZiAocm9vdEV2ZW50KSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJpbiB0eFwiKVxuICAgICAgICByZXR1cm4gZi5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJzdGFydCB0eFwiKVxuICAgICAgICByb290RXZlbnQgPSBldmVudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBmLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImRvbmUgd2l0aCB0eFwiKVxuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJvb3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGN1cnJlbnRFdmVudElkKCkge1xuICAgIHJldHVybiByb290RXZlbnQgPyByb290RXZlbnQuaWQgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB3cmFwcGVkU3Vic2NyaWJlKG9icywgc3Vic2NyaWJlLCBzaW5rKSB7XG4gICAgYXNzZXJ0RnVuY3Rpb24oc2luayk7XG4gICAgdmFyIHVuc3ViZCA9IGZhbHNlO1xuICAgIHZhciBzaG91bGRVbnN1YiA9IGZhbHNlO1xuICAgIHZhciBkb1Vuc3ViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzaG91bGRVbnN1YiA9IHRydWU7XG4gICAgfTtcbiAgICB2YXIgdW5zdWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVuc3ViZCA9IHRydWU7XG4gICAgICAgIGRvVW5zdWIoKTtcbiAgICB9O1xuICAgIGRvVW5zdWIgPSBzdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGFmdGVyVHJhbnNhY3Rpb24ob2JzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXVuc3ViZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXBseSA9IHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBseSA9PT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFVuc3ViKSB7XG4gICAgICAgIGRvVW5zdWIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuc3ViO1xufVxuZnVuY3Rpb24gaGFzV2FpdGVycygpIHsgcmV0dXJuIHdhaXRlck9icy5sZW5ndGggPiAwOyB9XG52YXIgVXBkYXRlQmFycmllciA9IHsgdG9TdHJpbmc6IHRvU3RyaW5nJDEsIHdoZW5Eb25lV2l0aDogd2hlbkRvbmVXaXRoLCBoYXNXYWl0ZXJzOiBoYXNXYWl0ZXJzLCBpblRyYW5zYWN0aW9uOiBpblRyYW5zYWN0aW9uLCBjdXJyZW50RXZlbnRJZDogY3VycmVudEV2ZW50SWQsIHdyYXBwZWRTdWJzY3JpYmU6IHdyYXBwZWRTdWJzY3JpYmUsIGFmdGVyVHJhbnNhY3Rpb246IGFmdGVyVHJhbnNhY3Rpb24sIHNvb25CdXROb3RZZXQ6IHNvb25CdXROb3RZZXQsIGlzSW5UcmFuc2FjdGlvbjogaXNJblRyYW5zYWN0aW9uIH07XG5cbnZhciBEZXNjID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlc2MoY29udGV4dCwgbWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IFtdOyB9XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2lzRGVzYyA9IHRydWU7XG4gICAgICAgIC8vYXNzZXJ0KFwiY29udGV4dCBtaXNzaW5nXCIsIGNvbnRleHQpXG4gICAgICAgIC8vYXNzZXJ0KFwibWV0aG9kIG1pc3NpbmdcIiwgbWV0aG9kKVxuICAgICAgICAvL2Fzc2VydChcImFyZ3MgbWlzc2luZ1wiLCBhcmdzKVxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgRGVzYy5wcm90b3R5cGUuZGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlZERlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkRGVwcyA9IGZpbmREZXBzKFt0aGlzLmNvbnRleHRdLmNvbmNhdCh0aGlzLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWREZXBzO1xuICAgIH07XG4gICAgRGVzYy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gXy5tYXAoXy50b1N0cmluZywgdGhpcy5hcmdzKTtcbiAgICAgICAgcmV0dXJuIF8udG9TdHJpbmcodGhpcy5jb250ZXh0KSArIFwiLlwiICsgXy50b1N0cmluZyh0aGlzLm1ldGhvZCkgKyBcIihcIiArIGFyZ3MgKyBcIilcIjtcbiAgICB9O1xuICAgIHJldHVybiBEZXNjO1xufSgpKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBkZXNjcmliZShjb250ZXh0LCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZWYgPSBjb250ZXh0IHx8IG1ldGhvZDtcbiAgICBpZiAocmVmICYmIHJlZi5faXNEZXNjKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0IHx8IG1ldGhvZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVzYyhjb250ZXh0LCBtZXRob2QsIGFyZ3MpO1xuICAgIH1cbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBmaW5kRGVwcyh4KSB7XG4gICAgaWYgKGlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuIF8uZmxhdE1hcChmaW5kRGVwcywgeCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZSh4KSkge1xuICAgICAgICByZXR1cm4gW3hdO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZW9mIHggIT09IFwidW5kZWZpbmVkXCIgJiYgeCAhPT0gbnVsbCkgPyB4Ll9pc1NvdXJjZSA6IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3gub2JzXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG52YXIgbnVsbFNpbmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3JlOyB9O1xuLyoqIEBoaWRkZW4gKi9cbnZhciBudWxsVm9pZFNpbmsgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3JlOyB9O1xuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gd2l0aFN0YXRlTWFjaGluZShpbml0U3RhdGUsIGYsIHNyYykge1xuICAgIHJldHVybiBzcmMudHJhbnNmb3JtKHdpdGhTdGF0ZU1hY2hpbmVUKGluaXRTdGF0ZSwgZiksIG5ldyBEZXNjKHNyYywgXCJ3aXRoU3RhdGVNYWNoaW5lXCIsIFtpbml0U3RhdGUsIGZdKSk7XG59XG5mdW5jdGlvbiB3aXRoU3RhdGVNYWNoaW5lVChpbml0U3RhdGUsIGYpIHtcbiAgICB2YXIgc3RhdGUgPSBpbml0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgc2luaykge1xuICAgICAgICB2YXIgZnJvbUYgPSBmKHN0YXRlLCBldmVudCk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IGZyb21GWzBdLCBvdXRwdXRzID0gZnJvbUZbMV07XG4gICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHZhciByZXBseSA9IG1vcmU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IG91dHB1dHNbaV07XG4gICAgICAgICAgICByZXBseSA9IHNpbmsob3V0cHV0KTtcbiAgICAgICAgICAgIGlmIChyZXBseSA9PT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBseTtcbiAgICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xudmFyIFNvbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU29tZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pc1NvbWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgU29tZS5wcm90b3R5cGUuZ2V0T3JFbHNlID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy52YWx1ZTsgfTtcbiAgICBTb21lLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9O1xuICAgIFNvbWUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGlmIChmKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNvbWUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTm9uZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU29tZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb21lKGYodGhpcy52YWx1ZSkpO1xuICAgIH07XG4gICAgU29tZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGYodGhpcy52YWx1ZSk7XG4gICAgfTtcbiAgICBTb21lLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3RoaXMudmFsdWVdOyB9O1xuICAgIFNvbWUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIlNvbWUoXCIgKyB0aGlzLnZhbHVlICsgXCIpXCI7IH07XG4gICAgU29tZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmluc3BlY3QoKTsgfTtcbiAgICByZXR1cm4gU29tZTtcbn0oKSk7XG4vKiogQGhpZGRlbiAqL1xudmFyIE5vbmUgPSB7XG4gICAgX2lzTm9uZTogdHJ1ZSxcbiAgICBnZXRPckVsc2U6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IG5ldyBFcnJvcihcIk5vbmUuZ2V0KClcIik7IH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBOb25lOyB9LFxuICAgIG1hcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTm9uZTsgfSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiAoKSB7IH0sXG4gICAgaXNEZWZpbmVkOiBmYWxzZSxcbiAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICBpbnNwZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBcIk5vbmVcIjsgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pbnNwZWN0KCk7IH1cbn07XG5mdW5jdGlvbiBub25lKCkgeyByZXR1cm4gTm9uZTsgfVxuZnVuY3Rpb24gdG9PcHRpb24odikge1xuICAgIGlmICh2ICYmICh2Ll9pc1NvbWUgfHwgdi5faXNOb25lKSkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU29tZSh2KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc05vbmUob2JqZWN0KSB7XG4gICAgcmV0dXJuICgodHlwZW9mIG9iamVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvYmplY3QgIT09IG51bGwpID8gb2JqZWN0Ll9pc05vbmUgOiBmYWxzZSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG52YXIgZXZlbnRJZENvdW50ZXIgPSAwO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgZXZlbnRzIHBhc3NlZCB0aHJvdWdoIFtFdmVudFN0cmVhbXNdKGV2ZW50c3RyZWFtLmh0bWwpIGFuZCBbUHJvcGVydGllc10ocHJvcGVydHkuaHRtbCkuXG4gKi9cbnZhciBFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudCgpIHtcbiAgICAgICAgdGhpcy5pZCA9ICsrZXZlbnRJZENvdW50ZXI7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuaXNFdmVudCA9IHRydWU7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2lzRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbml0aWFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNOZXh0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgRXZlbnQucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiB0cnVlOyB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgRXZlbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBFdmVudC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgRXZlbnQucHJvdG90eXBlLnRvTmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgcmV0dXJuIEV2ZW50O1xufSgpKTtcbi8qKlxuICogIEJhc2UgY2xhc3MgZm9yIGFsbCBbRXZlbnRzXShldmVudC5odG1sKSBjYXJyeWluZyBhIHZhbHVlLlxuICpcbiAqICBDYW4gYmUgZGlzdGluZ3Vpc2hlZCBmcm9tIG90aGVyIGV2ZW50cyB1c2luZyBbaGFzVmFsdWVdKC4uL2dsb2JhbHMuaHRtbCNoYXN2YWx1ZSlcbiAqKi9cbnZhciBWYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsdWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yJDEoXCJXcmFwcGluZyBhbiBldmVudCBpbnNpZGUgb3RoZXIgZXZlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFZhbHVlLnByb3RvdHlwZS5mbWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkoZih0aGlzLnZhbHVlKSk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFZhbHVlLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZih0aGlzLnZhbHVlKTsgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFZhbHVlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF8udG9TdHJpbmcodGhpcy52YWx1ZSk7IH07XG4gICAgLy90b1N0cmluZygpOiBzdHJpbmcgeyByZXR1cm4gXCI8dmFsdWUgXCIgKyB0aGlzLmlkICsgXCI+XCIgKyBfLnRvU3RyaW5nKHRoaXMudmFsdWUpIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFZhbHVlLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnZhbHVlOyB9O1xuICAgIHJldHVybiBWYWx1ZTtcbn0oRXZlbnQpKTtcbi8qKlxuICogIEluZGljYXRlcyBhIG5ldyB2YWx1ZSBpbiBhbiBbRXZlbnRTdHJlYW1dKGV2ZW50c3RyZWFtLmh0bWwpIG9yIGEgW1Byb3BlcnR5XShwcm9wZXJ0eS5odG1sKS5cbiAqXG4gKiAgQ2FuIGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBvdGhlciBldmVudHMgdXNpbmcgW2lzTmV4dF0oLi4vZ2xvYmFscy5odG1sI2lzbmV4dClcbiAqL1xudmFyIE5leHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5leHQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV4dCh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNOZXh0ID0gdHJ1ZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgX3RoaXMuX2lzTmV4dCA9IHRydWU7IC8vIHNvbWUgY29tcGF0aWJpbGl0eSBzdHVmZj9cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIE5leHQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBuZXcgTmV4dCh2YWx1ZSk7IH07XG4gICAgcmV0dXJuIE5leHQ7XG59KFZhbHVlKSk7XG4vKipcbiAqIEFuIGV2ZW50IGNhcnJ5aW5nIHRoZSBpbml0aWFsIHZhbHVlIG9mIGEgW1Byb3BlcnR5XShjbGFzc2VzL3Byb3BlcnR5Lmh0bWwpLiBUaGlzIGV2ZW50IGNhbiBiZSBlbWl0dGVkIGJ5IGEgcHJvcGVydHlcbiAqIGltbWVkaWF0ZWx5IHdoZW4gc3Vic2NyaWJpbmcgdG8gaXQuXG4gKlxuICogQ2FuIGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBvdGhlciBldmVudHMgdXNpbmcgW2lzSW5pdGlhbF0oLi4vZ2xvYmFscy5odG1sI2lzaW5pdGlhbClcbiAqL1xudmFyIEluaXRpYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluaXRpYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5pdGlhbCh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNJbml0aWFsID0gdHJ1ZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgX3RoaXMuX2lzSW5pdGlhbCA9IHRydWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBJbml0aWFsLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gbmV3IEluaXRpYWwodmFsdWUpOyB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgSW5pdGlhbC5wcm90b3R5cGUudG9OZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE5leHQodGhpcy52YWx1ZSk7IH07XG4gICAgcmV0dXJuIEluaXRpYWw7XG59KFZhbHVlKSk7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGV2ZW50cyBub3QgY2FycnlpbmcgYSB2YWx1ZS5cbiAqL1xudmFyIE5vVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vVmFsdWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9WYWx1ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBOb1ZhbHVlLnByb3RvdHlwZS5mbWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gTm9WYWx1ZTtcbn0oRXZlbnQpKTtcbi8qKlxuICogQW4gZXZlbnQgdGhhdCBpbmRpY2F0ZXMgdGhlIGVuZCBvZiBhbiBbRXZlbnRTdHJlYW1dKGNsYXNzZXMvZXZlbnRzdHJlYW0uaHRtbCkgb3IgYSBbUHJvcGVydHldKGNsYXNzZXMvcHJvcGVydHkuaHRtbCkuXG4gKiBObyBtb3JlIGV2ZW50cyBjYW4gYmUgZW1pdHRlZCBhZnRlciB0aGlzIG9uZS5cbiAqXG4gKiBDYW4gYmUgZGlzdGluZ3Vpc2hlZCBmcm9tIG90aGVyIGV2ZW50cyB1c2luZyBbaXNFbmRdKC4uL2dsb2JhbHMuaHRtbCNpc2VuZClcbiAqL1xudmFyIEVuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW5kLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVuZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzRW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEVuZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBcIjxlbmQ+XCI7IH07XG4gICAgcmV0dXJuIEVuZDtcbn0oTm9WYWx1ZSkpO1xuLyoqXG4gKiAgQW4gZXZlbnQgY2FycnlpbmcgYW4gZXJyb3IuIFlvdSBjYW4gdXNlIFtvbkVycm9yXShvYnNlcnZhYmxlLmh0bWwjb25lcnJvcikgdG8gc3Vic2NyaWJlIHRvIGVycm9ycy5cbiAqL1xudmFyIEVycm9yJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVycm9yKGVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzRXJyb3IgPSB0cnVlO1xuICAgICAgICBfdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCI8ZXJyb3I+IFwiICsgXy50b1N0cmluZyh0aGlzLmVycm9yKTtcbiAgICB9O1xuICAgIHJldHVybiBFcnJvcjtcbn0oTm9WYWx1ZSkpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGluaXRpYWxFdmVudCh2YWx1ZSkgeyByZXR1cm4gbmV3IEluaXRpYWwodmFsdWUpOyB9XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbmV4dEV2ZW50KHZhbHVlKSB7IHJldHVybiBuZXcgTmV4dCh2YWx1ZSk7IH1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBlbmRFdmVudCgpIHsgcmV0dXJuIG5ldyBFbmQoKTsgfVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHRvRXZlbnQoeCkge1xuICAgIGlmICh4ICYmIHguX2lzRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV4dEV2ZW50KHgpO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gW0V2ZW50XShjbGFzc2VzL2V2ZW50Lmh0bWwpLlxuICovXG5mdW5jdGlvbiBpc0V2ZW50KGUpIHtcbiAgICByZXR1cm4gZSAmJiBlLl9pc0V2ZW50O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFuIFtJbml0aWFsXShjbGFzc2VzL2luaXRpYWwuaHRtbCkgdmFsdWUgb2YgYSBbUHJvcGVydHldKGNsYXNzZXMvcHJvcGVydHkuaHRtbCkuXG4gKi9cbmZ1bmN0aW9uIGlzSW5pdGlhbChlKSB7XG4gICAgcmV0dXJuIGUgJiYgZS5faXNJbml0aWFsO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFuIFtFcnJvcl0oY2xhc3Nlcy9lcnJvci5odG1sKSBldmVudCBvZiBhbiBbT2JzZXJ2YWJsZV0oY2xhc3Nlcy9vYnNlcnZhYmxlLmh0bWwpLlxuICovXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgICByZXR1cm4gZS5pc0Vycm9yO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGEgW1ZhbHVlXShjbGFzc2VzL3ZhbHVlLmh0bWwpLCBpLmUuIGEgW05leHRdKGNsYXNzZXMvbmV4dC5odG1sKSBvclxuICogYW4gW0luaXRpYWxdKGNsYXNzZXMvZXJyb3IuaHRtbCkgdmFsdWUgb2YgYW4gW09ic2VydmFibGVdKGNsYXNzZXMvb2JzZXJ2YWJsZS5odG1sKS5cbiAqL1xuZnVuY3Rpb24gaGFzVmFsdWUoZSkge1xuICAgIHJldHVybiBlLmhhc1ZhbHVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFuIFtFbmRdKGNsYXNzZXMvZW5kLmh0bWwpXG4gKi9cbmZ1bmN0aW9uIGlzRW5kKGUpIHtcbiAgICByZXR1cm4gZS5pc0VuZDtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhIFtOZXh0XShjbGFzc2VzL25leHQuaHRtbClcbiAqL1xuZnVuY3Rpb24gaXNOZXh0KGUpIHtcbiAgICByZXR1cm4gZS5pc05leHQ7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikgeyByZXR1cm4gYSA9PT0gYjsgfVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHNraXBEdXBsaWNhdGVzKHNyYywgaXNFcXVhbCkge1xuICAgIGlmIChpc0VxdWFsID09PSB2b2lkIDApIHsgaXNFcXVhbCA9IGVxdWFsczsgfVxuICAgIHZhciBkZXNjID0gbmV3IERlc2Moc3JjLCBcInNraXBEdXBsaWNhdGVzXCIsIFtdKTtcbiAgICByZXR1cm4gd2l0aFN0YXRlTWFjaGluZShub25lKCksIGZ1bmN0aW9uIChwcmV2LCBldmVudCkge1xuICAgICAgICBpZiAoIWhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcmV2LCBbZXZlbnRdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5pc0luaXRpYWwgfHwgaXNOb25lKHByZXYpIHx8ICFpc0VxdWFsKHByZXYuZ2V0KCksIGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgU29tZShldmVudC52YWx1ZSksIFtldmVudF1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtwcmV2LCBbXV07XG4gICAgICAgIH1cbiAgICB9LCBzcmMpLndpdGhEZXNjKGRlc2MpO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdGFrZShjb3VudCwgc3JjLCBkZXNjKSB7XG4gICAgcmV0dXJuIHNyYy50cmFuc2Zvcm0odGFrZVQoY291bnQpLCBkZXNjIHx8IG5ldyBEZXNjKHNyYywgXCJ0YWtlXCIsIFtjb3VudF0pKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0YWtlVChjb3VudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSwgc2luaykge1xuICAgICAgICBpZiAoIWUuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaW5rKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaW5rKGVuZEV2ZW50KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub01vcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbG9nKGFyZ3MsIHNyYykge1xuICAgIHNyYy5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncy5jb25jYXQoW2V2ZW50LmxvZygpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3JlO1xuICAgIH0pO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZG9Mb2dUKGFyZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBzaW5rKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlICE9PSBudWxsICYmIHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzLmNvbmNhdChbZXZlbnQubG9nKCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgIH07XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBkb0Vycm9yVChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgc2luaykge1xuICAgICAgICBpZiAoaXNFcnJvcihldmVudCkpIHtcbiAgICAgICAgICAgIGYoZXZlbnQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZG9BY3Rpb25UKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBzaW5rKSB7XG4gICAgICAgIGlmIChoYXNWYWx1ZShldmVudCkpIHtcbiAgICAgICAgICAgIGYoZXZlbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZG9FbmRUKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBzaW5rKSB7XG4gICAgICAgIGlmIChpc0VuZChldmVudCkpIHtcbiAgICAgICAgICAgIGYoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luayhldmVudCk7XG4gICAgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHNjYW4oc3JjLCBzZWVkLCBmKSB7XG4gICAgdmFyIHJlc3VsdFByb3BlcnR5O1xuICAgIHZhciBhY2MgPSBzZWVkO1xuICAgIHZhciBpbml0SGFuZGxlZCA9IGZhbHNlO1xuICAgIHZhciBzdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB2YXIgaW5pdFNlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVuc3ViID0gbm9wO1xuICAgICAgICB2YXIgcmVwbHkgPSBtb3JlO1xuICAgICAgICB2YXIgc2VuZEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWluaXRTZW50KSB7XG4gICAgICAgICAgICAgICAgaW5pdFNlbnQgPSBpbml0SGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVwbHkgPSBzaW5rKG5ldyBJbml0aWFsKGFjYykpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBseSA9PT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgICAgICAgICAgIHVuc3ViID0gbm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBseTtcbiAgICAgICAgfTtcbiAgICAgICAgdW5zdWIgPSBzcmMuc3Vic2NyaWJlSW50ZXJuYWwoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaGFzVmFsdWUoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRIYW5kbGVkICYmIGV2ZW50LmlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nIFwic2tpcCBJTklUSUFMXCJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcmU7IC8vIGluaXQgYWxyZWFkeSBzZW50LCBza2lwIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZEluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbml0U2VudCA9IGluaXRIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBhY2M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZihwcmV2LCBldmVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cgcHJldiAsIFwiLFwiLCBldmVudC52YWx1ZSwgXCItPlwiLCBuZXh0XG4gICAgICAgICAgICAgICAgICAgIGFjYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW5rKGV2ZW50LmFwcGx5KG5leHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuaXNFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkgPSBzZW5kSW5pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVwbHkgIT09IG5vTW9yZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2luayhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXBseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFVwZGF0ZUJhcnJpZXIud2hlbkRvbmVXaXRoKHJlc3VsdFByb3BlcnR5LCBzZW5kSW5pdCk7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICB9O1xuICAgIHJldHVybiByZXN1bHRQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eShuZXcgRGVzYyhzcmMsIFwic2NhblwiLCBbc2VlZCwgZl0pLCBzdWJzY3JpYmUpO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbWFwRW5kVChmKSB7XG4gICAgdmFyIHRoZUYgPSBfLnRvRnVuY3Rpb24oZik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgc2luaykge1xuICAgICAgICBpZiAoaXNFbmQoZXZlbnQpKSB7XG4gICAgICAgICAgICBzaW5rKG5leHRFdmVudCh0aGVGKGV2ZW50KSkpO1xuICAgICAgICAgICAgc2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgICAgIHJldHVybiBub01vcmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2luayhldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbWFwRXJyb3JUKGYpIHtcbiAgICB2YXIgdGhlRiA9IF8udG9GdW5jdGlvbihmKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50LCBzaW5rKSB7XG4gICAgICAgIGlmIChpc0Vycm9yKGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmsobmV4dEV2ZW50KHRoZUYoZXZlbnQuZXJyb3IpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2luayhldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gc2tpcEVycm9ycyhzcmMpIHtcbiAgICByZXR1cm4gc3JjLnRyYW5zZm9ybShmdW5jdGlvbiAoZXZlbnQsIHNpbmspIHtcbiAgICAgICAgaWYgKGlzRXJyb3IoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sIG5ldyBEZXNjKHNyYywgXCJza2lwRXJyb3JzXCIsIFtdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBsYXN0JDEoc3JjKSB7XG4gICAgdmFyIGxhc3RFdmVudDtcbiAgICByZXR1cm4gc3JjLnRyYW5zZm9ybShmdW5jdGlvbiAoZXZlbnQsIHNpbmspIHtcbiAgICAgICAgaWYgKGlzRW5kKGV2ZW50KSkge1xuICAgICAgICAgICAgaWYgKGxhc3RFdmVudCkge1xuICAgICAgICAgICAgICAgIHNpbmsobGFzdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9Nb3JlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgICAgICAgbGFzdEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gbW9yZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0pLndpdGhEZXNjKG5ldyBEZXNjKHNyYywgXCJsYXN0XCIsIFtdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG52YXIgQ29tcG9zaXRlVW5zdWJzY3JpYmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcG9zaXRlVW5zdWJzY3JpYmUoc3MpIHtcbiAgICAgICAgaWYgKHNzID09PSB2b2lkIDApIHsgc3MgPSBbXTsgfVxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlID0gXy5iaW5kKHRoaXMudW5zdWJzY3JpYmUsIHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFydGluZyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgczsgaSA8IHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzID0gc3NbaV07XG4gICAgICAgICAgICB0aGlzLmFkZChzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb21wb3NpdGVVbnN1YnNjcmliZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMudW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB2YXIgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciB1bnN1YiA9IG5vcDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRpbmcucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgdmFyIHVuc3ViTWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmUodW5zdWIpO1xuICAgICAgICAgICAgICAgIF8ucmVtb3ZlKHN1YnNjcmlwdGlvbiwgX3RoaXMuc3RhcnRpbmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVuc3ViID0gc3Vic2NyaXB0aW9uKHRoaXMudW5zdWJzY3JpYmUsIHVuc3ViTWUpO1xuICAgICAgICAgICAgaWYgKCEodGhpcy51bnN1YnNjcmliZWQgfHwgZW5kZWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godW5zdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF8ucmVtb3ZlKHN1YnNjcmlwdGlvbiwgdGhpcy5zdGFydGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBvc2l0ZVVuc3Vic2NyaWJlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAodW5zdWIpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfLnJlbW92ZSh1bnN1YiwgdGhpcy5zdWJzY3JpcHRpb25zKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuc3ViKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbXBvc2l0ZVVuc3Vic2NyaWJlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlcmFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRpbmcgPSBbXTtcbiAgICB9O1xuICAgIENvbXBvc2l0ZVVuc3Vic2NyaWJlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCArIHRoaXMuc3RhcnRpbmcubGVuZ3RoO1xuICAgIH07XG4gICAgQ29tcG9zaXRlVW5zdWJzY3JpYmUucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudCgpID09PSAwO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBvc2l0ZVVuc3Vic2NyaWJlO1xufSgpKTtcblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHN0cmVhbVN1YnNjcmliZVRvUHJvcGVydHlTdWJzY3JpYmUoaW5pdFZhbHVlLCBzdHJlYW1TdWJzY3JpYmUpIHtcbiAgICAvL2Fzc2VydEZ1bmN0aW9uKHN0cmVhbVN1YnNjcmliZSlcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgdmFyIGluaXRTZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBzdWJiZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHVuc3ViID0gbm9wO1xuICAgICAgICB2YXIgcmVwbHkgPSBtb3JlO1xuICAgICAgICB2YXIgc2VuZEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWluaXRTZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRWYWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbml0U2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5ID0gc2luayhuZXcgSW5pdGlhbCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbHkgPT09IG5vTW9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3ViID0gbm9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1bnN1YiA9IHN0cmVhbVN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmlzSW5pdGlhbCAmJiAhc3ViYmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRWYWx1ZSA9IG5ldyBTb21lKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZEluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbml0U2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluaXRWYWx1ZSA9IG5ldyBTb21lKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5pc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXBseSA9IHNlbmRJbml0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXBseSAhPT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3ViYmVkID0gdHJ1ZTtcbiAgICAgICAgc2VuZEluaXQoKTtcbiAgICAgICAgcmV0dXJuIHVuc3ViO1xuICAgIH07XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBwcm9wZXJ0eUZyb21TdHJlYW1TdWJzY3JpYmUoZGVzYywgc3Vic2NyaWJlKSB7XG4gICAgYXNzZXJ0RnVuY3Rpb24oc3Vic2NyaWJlKTtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRlc2MsIHN0cmVhbVN1YnNjcmliZVRvUHJvcGVydHlTdWJzY3JpYmUobm9uZSgpLCBzdWJzY3JpYmUpKTtcbn1cblxuLyoqXG4gQ3JlYXRlcyBhbiBFdmVudFN0cmVhbSB0aGF0IGRlbGl2ZXJzIHRoZSBnaXZlblxuIHNpbmdsZSB2YWx1ZSBmb3IgdGhlIGZpcnN0IHN1YnNjcmliZXIuIFRoZSBzdHJlYW0gd2lsbCBlbmQgaW1tZWRpYXRlbHlcbiBhZnRlciB0aGlzIHZhbHVlLiBZb3UgY2FuIGFsc28gc2VuZCBhbiBbYEJhY29uLkVycm9yYF0oI2JhY29uLWVycm9yKSBldmVudCBpbnN0ZWFkIG9mIGFcbiB2YWx1ZTogYEJhY29uLm9uY2UobmV3IEJhY29uLkVycm9yKFwiZmFpbFwiKSlgLlxuXG4gQHBhcmFtICAgdmFsdWUgICB0aGUgdmFsdWUgb3IgZXZlbnQgdG8gZW1pdFxuIEB0eXBlcGFyYW0gViBUeXBlIG9mIHN0cmVhbSBlbGVtZW50c1xuICovXG5mdW5jdGlvbiBvbmNlKHZhbHVlKSB7XG4gICAgdmFyIHMgPSBuZXcgRXZlbnRTdHJlYW0obmV3IERlc2MoXCJCYWNvblwiLCBcIm9uY2VcIiwgW3ZhbHVlXSksIGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIFVwZGF0ZUJhcnJpZXIuc29vbkJ1dE5vdFlldChzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaW5rKHRvRXZlbnQodmFsdWUpKTtcbiAgICAgICAgICAgIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9wO1xuICAgIH0pO1xuICAgIHJldHVybiBzO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZmxhdE1hcF8oc3Bhd25lciwgc3JjLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICB2YXIgcm9vdCA9IHNyYztcbiAgICB2YXIgcm9vdERlcCA9IFtyb290XTtcbiAgICB2YXIgY2hpbGREZXBzID0gW107XG4gICAgdmFyIGlzUHJvcGVydHkgPSBzcmMuX2lzUHJvcGVydHk7XG4gICAgdmFyIGN0b3IgPSAoaXNQcm9wZXJ0eSA/IHByb3BlcnR5RnJvbVN0cmVhbVN1YnNjcmliZSA6IG5ld0V2ZW50U3RyZWFtQWxsb3dTeW5jKTtcbiAgICB2YXIgaW5pdGlhbFNwYXduZWQgPSBmYWxzZTtcbiAgICB2YXIgZGVzYyA9IHBhcmFtcy5kZXNjIHx8IG5ldyBEZXNjKHNyYywgXCJmbGF0TWFwX1wiLCBbc3Bhd25lcl0pO1xuICAgIHZhciByZXN1bHQgPSBjdG9yKGRlc2MsIGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHZhciBjb21wb3NpdGUgPSBuZXcgQ29tcG9zaXRlVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHNwYXduKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eSAmJiBldmVudC5pc0luaXRpYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFNwYXduZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluaXRpYWxTcGF3bmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG1ha2VPYnNlcnZhYmxlKHNwYXduZXIoZXZlbnQpKTtcbiAgICAgICAgICAgIGNoaWxkRGVwcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGUuYWRkKGZ1bmN0aW9uICh1bnN1YkFsbCwgdW5zdWJNZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zdWJzY3JpYmVJbnRlcm5hbChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmlzRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnJlbW92ZShjaGlsZCwgY2hpbGREZXBzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRW5kKHVuc3ViTWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vTW9yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQudG9OZXh0KCk7IC8vIFRvIHN1cHBvcnQgUHJvcGVydHkgYXMgdGhlIHNwYXduZWQgc3RyZWFtXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbHkgPSBzaW5rKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBseSA9PT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBseTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tRdWV1ZSgpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzcGF3bihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tFbmQodW5zdWIpIHtcbiAgICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRlLmVtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvc2l0ZS5hZGQoZnVuY3Rpb24gKF9fLCB1bnN1YlJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiByb290LnN1YnNjcmliZUludGVybmFsKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5pc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFbmQodW5zdWJSb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuaXNFcnJvciAmJiAhcGFyYW1zLm1hcEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW1zLmZpcnN0T25seSAmJiBjb21wb3NpdGUuY291bnQoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRlLnVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vTW9yZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxpbWl0ICYmIGNvbXBvc2l0ZS5jb3VudCgpID4gcGFyYW1zLmxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYXduKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGUudW5zdWJzY3JpYmU7XG4gICAgfSk7XG4gICAgcmVzdWx0LmludGVybmFsRGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNoaWxkRGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByb290RGVwLmNvbmNhdChjaGlsZERlcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3REZXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXZlbnRWYWx1ZVdpdGgoZikge1xuICAgIGlmICh0eXBlb2YgZiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChoYXNWYWx1ZShldmVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihldmVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZjsgfSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbWFrZU9ic2VydmFibGUoeCkge1xuICAgIGlmIChpc09ic2VydmFibGUoeCkpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb25jZSh4KTtcbiAgICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBmbGF0TWFwRXZlbnQoc3JjLCBmKSB7XG4gICAgcmV0dXJuIGZsYXRNYXBfKGYsIHNyYywge1xuICAgICAgICBtYXBFcnJvcjogdHJ1ZSxcbiAgICAgICAgZGVzYzogbmV3IERlc2Moc3JjLCBcImZsYXRNYXBFdmVudFwiLCBbZl0pXG4gICAgfSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBlbmRBc1ZhbHVlKHNyYykge1xuICAgIHJldHVybiBzcmMudHJhbnNmb3JtKGZ1bmN0aW9uIChldmVudCwgc2luaykge1xuICAgICAgICBpZiAoaXNFbmQoZXZlbnQpKSB7XG4gICAgICAgICAgICBzaW5rKG5leHRFdmVudCh7fSkpO1xuICAgICAgICAgICAgc2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgICAgIHJldHVybiBub01vcmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgfSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBlbmRPbkVycm9yKHNyYywgcHJlZGljYXRlKSB7XG4gICAgaWYgKHByZWRpY2F0ZSA9PT0gdm9pZCAwKSB7IHByZWRpY2F0ZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB0cnVlOyB9OyB9XG4gICAgcmV0dXJuIHNyYy50cmFuc2Zvcm0oZnVuY3Rpb24gKGV2ZW50LCBzaW5rKSB7XG4gICAgICAgIGlmIChpc0Vycm9yKGV2ZW50KSAmJiBwcmVkaWNhdGUoZXZlbnQuZXJyb3IpKSB7XG4gICAgICAgICAgICBzaW5rKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBzaW5rKGVuZEV2ZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSwgbmV3IERlc2Moc3JjLCBcImVuZE9uRXJyb3JcIiwgW10pKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbnZhciBTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU291cmNlKG9icywgc3luYykge1xuICAgICAgICB0aGlzLl9pc1NvdXJjZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZmxhdHRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnMgPSBvYnM7XG4gICAgICAgIHRoaXMuc3luYyA9IHN5bmM7XG4gICAgfVxuICAgIFNvdXJjZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzLnN1YnNjcmliZUludGVybmFsKHNpbmspO1xuICAgIH07XG4gICAgU291cmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICBTb3VyY2UucHJvdG90eXBlLm1hcmtFbmRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBTb3VyY2UucHJvdG90eXBlLm1heUhhdmUgPSBmdW5jdGlvbiAoY291bnQpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgcmV0dXJuIFNvdXJjZTtcbn0oKSk7XG4vKiogQGhpZGRlbiAqL1xudmFyIERlZmF1bHRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmF1bHRTb3VyY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmYXVsdFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEZWZhdWx0U291cmNlLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9O1xuICAgIERlZmF1bHRTb3VyY2UucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnZhbHVlID0geDtcbiAgICB9O1xuICAgIERlZmF1bHRTb3VyY2UucHJvdG90eXBlLmhhc0F0TGVhc3QgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gISF0aGlzLnZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmF1bHRTb3VyY2U7XG59KFNvdXJjZSkpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciBDb25zdW1pbmdTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN1bWluZ1NvdXJjZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdW1pbmdTb3VyY2Uob2JzLCBzeW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9icywgc3luYykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZmxhdHRlbiA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnN1bWluZ1NvdXJjZS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICB9O1xuICAgIENvbnN1bWluZ1NvdXJjZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh4KTtcbiAgICB9O1xuICAgIENvbnN1bWluZ1NvdXJjZS5wcm90b3R5cGUubWF5SGF2ZSA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZW5kZWQgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPj0gY291bnQ7XG4gICAgfTtcbiAgICBDb25zdW1pbmdTb3VyY2UucHJvdG90eXBlLmhhc0F0TGVhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUubGVuZ3RoID49IGNvdW50O1xuICAgIH07XG4gICAgcmV0dXJuIENvbnN1bWluZ1NvdXJjZTtcbn0oU291cmNlKSk7XG4vKiogQGhpZGRlbiAqL1xudmFyIEJ1ZmZlcmluZ1NvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQnVmZmVyaW5nU291cmNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlcmluZ1NvdXJjZShvYnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb2JzLCB0cnVlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJ1ZmZlcmluZ1NvdXJjZS5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMucXVldWU7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJ1ZmZlcmluZ1NvdXJjZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnB1c2goeC52YWx1ZSk7XG4gICAgfTtcbiAgICBCdWZmZXJpbmdTb3VyY2UucHJvdG90eXBlLmhhc0F0TGVhc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gQnVmZmVyaW5nU291cmNlO1xufShTb3VyY2UpKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBpc1RyaWdnZXIocykge1xuICAgIGlmIChzID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocy5faXNTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHMuc3luYztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzLl9pc0V2ZW50U3RyZWFtO1xuICAgIH1cbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBmcm9tT2JzZXJ2YWJsZShzKSB7XG4gICAgaWYgKHMgIT0gbnVsbCAmJiBzLl9pc1NvdXJjZSkge1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgZWxzZSBpZiAocyAhPSBudWxsICYmIHMuX2lzUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U291cmNlKHMsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3VtaW5nU291cmNlKHMsIHRydWUpO1xuICAgIH1cbn1cblxuLyoqXG4gQ3JlYXRlcyBhbiBFdmVudFN0cmVhbSB0aGF0IGltbWVkaWF0ZWx5IGVuZHMuXG4gQHR5cGVwYXJhbSBWIFR5cGUgb2Ygc3RyZWFtIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIG5ldmVyKCkge1xuICAgIHJldHVybiBuZXcgRXZlbnRTdHJlYW0oZGVzY3JpYmUoXCJCYWNvblwiLCBcIm5ldmVyXCIpLCBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICBzaW5rKGVuZEV2ZW50KCkpO1xuICAgICAgICByZXR1cm4gbm9wO1xuICAgIH0pO1xufVxuXG4vKipcbiBUaGUgYHdoZW5gIG1ldGhvZCBwcm92aWRlcyBhIGdlbmVyYWxpemF0aW9uIG9mIHRoZSBbYHppcGBdKGNsYXNzZXMvb2JzZXJ2YWJsZS5odG1sI3ppcCkgZnVuY3Rpb24uIFdoaWxlIHppcFxuIHN5bmNocm9uaXplcyBldmVudHMgZnJvbSBtdWx0aXBsZSBzdHJlYW1zIHBhaXJ3c2UsIHRoZSBqb2luIHBhdHRlcm5zIHVzZWQgaW4gYHdoZW5gIGFsbG93XG4gdGhlIGltcGxlbWVudGF0aW9uIG9mIG1vcmUgYWR2YW5jZWQgc3luY2hyb25pemF0aW9uIHBhdHRlcm5zLlxuXG4gQ29uc2lkZXIgaW1wbGVtZW50aW5nIGEgZ2FtZSB3aXRoIGRpc2NyZXRlIHRpbWUgdGlja3MuIFdlIHdhbnQgdG9cbiBoYW5kbGUga2V5LWV2ZW50cyBzeW5jaHJvbml6ZWQgb24gdGljay1ldmVudHMsIHdpdGggYXQgbW9zdCBvbmUga2V5XG4gZXZlbnQgaGFuZGxlZCBwZXIgdGljay4gSWYgdGhlcmUgYXJlIG5vIGtleSBldmVudHMsIHdlIHdhbnQgdG8ganVzdFxuIHByb2Nlc3MgYSB0aWNrLlxuXG4gYGBganNcbiBCYWNvbi53aGVuKFxuIFt0aWNrLCBrZXlFdmVudCwgZnVuY3Rpb24oXywgaykgeyBoYW5kbGVLZXlFdmVudChrKTsgcmV0dXJuIGhhbmRsZVRpY2soKTsgfV0sXG4gW3RpY2ssIGhhbmRsZVRpY2tdKVxuIGBgYFxuXG4gT3JkZXIgaXMgaW1wb3J0YW50IGhlcmUuIElmIHRoZSBbdGlja10gcGF0dGVybnMgaGFkIGJlZW4gd3JpdHRlblxuIGZpcnN0LCB0aGlzIHdvdWxkIGhhdmUgYmVlbiB0cmllZCBmaXJzdCwgYW5kIHByZWZlcnJlZCBhdCBlYWNoIHRpY2suXG5cbiBKb2luIHBhdHRlcm5zIGFyZSBpbmRlZWQgYSBnZW5lcmFsaXphdGlvbiBvZiB6aXAsIGFuZCBmb3IgRXZlbnRTdHJlYW1zLCB6aXAgaXNcbiBlcXVpdmFsZW50IHRvIGEgc2luZ2xlLXJ1bGUgam9pbiBwYXR0ZXJuLiBUaGUgZm9sbG93aW5nIG9ic2VydmFibGVzXG4gaGF2ZSB0aGUgc2FtZSBvdXRwdXQsIGFzc3VtaW5nIHRoYXQgYWxsIHNvdXJjZXMgYXJlIEV2ZW50U3RyZWFtcy5cblxuIGBgYGpzXG4gQmFjb24uemlwV2l0aChhLGIsYywgY29tYmluZSlcbiBCYWNvbi53aGVuKFthLGIsY10sIGNvbWJpbmUpXG4gYGBgXG5cbiBOb3RlIHRoYXQgW2BCYWNvbi53aGVuYF0oI2JhY29uLXdoZW4pIGRvZXMgbm90IHRyaWdnZXIgdXBkYXRlcyBmb3IgZXZlbnRzIGZyb20gUHJvcGVydGllcyB0aG91Z2g7XG4gaWYgeW91IHVzZSBhIFByb3BlcnR5IGluIHlvdXIgcGF0dGVybiwgaXRzIHZhbHVlIHdpbGwgYmUganVzdCBzYW1wbGVkIHdoZW4gYWxsIHRoZVxuIG90aGVyIHNvdXJjZXMgKEV2ZW50U3RyZWFtcykgaGF2ZSBhIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIGEgdmFsdWUgb2YgYSBQcm9wZXJ0eVxuIGluIHlvdXIgY2FsY3VsYXRpb25zLiBJZiB5b3Ugd2FudCB5b3VyIHBhdHRlcm4gdG8gZmlyZSBmb3IgYSBQcm9wZXJ0eSB0b28sIHlvdSBjYW5cbiBjb252ZXJ0IGl0IGludG8gYW4gRXZlbnRTdHJlYW0gdXNpbmcgW2Bwcm9wZXJ0eS5jaGFuZ2VzKClgXSgjcHJvcGVydHktY2hhbmdlcykgb3IgW2Bwcm9wZXJ0eS50b0V2ZW50U3RyZWFtKClgXSgjcHJvcGVydHktdG9ldmVudHN0cmVhbSlcblxuICogQHBhcmFtIHtQYXR0ZXJuPE8+fSBwYXR0ZXJucyBKb2luIHBhdHRlcm5zXG4gKiBAdHlwZXBhcmFtIE8gcmVzdWx0IHR5cGVcbiAqL1xuZnVuY3Rpb24gd2hlbigpIHtcbiAgICB2YXIgcGF0dGVybnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwYXR0ZXJuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gd2hlbl8obmV3RXZlbnRTdHJlYW0sIHBhdHRlcm5zKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB3aGVuUCgpIHtcbiAgICB2YXIgcGF0dGVybnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwYXR0ZXJuc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gd2hlbl8ocHJvcGVydHlGcm9tU3RyZWFtU3Vic2NyaWJlLCBwYXR0ZXJucyk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gd2hlbl8oY3RvciwgcGF0dGVybnMpIHtcbiAgICBpZiAocGF0dGVybnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBuZXZlcigpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBwcm9jZXNzUmF3UGF0dGVybnMoZXh0cmFjdFJhd1BhdHRlcm5zKHBhdHRlcm5zKSksIHNvdXJjZXMgPSBfYVswXSwgaXhQYXRzID0gX2FbMV07XG4gICAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV2ZXIoKTtcbiAgICB9XG4gICAgdmFyIG5lZWRzQmFycmllciA9IChhbnkoc291cmNlcywgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuZmxhdHRlbjsgfSkpICYmIGNvbnRhaW5zRHVwbGljYXRlRGVwcyhtYXAoKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLm9iczsgfSksIHNvdXJjZXMpKTtcbiAgICB2YXIgZGVzYyA9IG5ldyBEZXNjKFwiQmFjb25cIiwgXCJ3aGVuXCIsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhdHRlcm5zKSk7XG4gICAgdmFyIHJlc3VsdFN0cmVhbSA9IGN0b3IoZGVzYywgZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgdmFyIHRyaWdnZXJzID0gW107XG4gICAgICAgIHZhciBlbmRzID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoKHApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5peHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXggPSBwLml4c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZXNbaXguaW5kZXhdLmhhc0F0TGVhc3QoaXguY291bnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5ub3RNYXRjaChwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAuaXhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl4ID0gcC5peHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VzW2l4LmluZGV4XS5tYXlIYXZlKGl4LmNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbm9uRmxhdHRlbmVkKHRyaWdnZXIpIHsgcmV0dXJuICF0cmlnZ2VyLnNvdXJjZS5mbGF0dGVuOyB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnQoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHVuc3ViQWxsKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZmx1c2hMYXRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVwZGF0ZUJhcnJpZXIud2hlbkRvbmVXaXRoKHJlc3VsdFN0cmVhbSwgZmx1c2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmbHVzaFdoaWxlVHJpZ2dlcnMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlnZ2VyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHRyaWdnZXIgPSB0cmlnZ2Vycy5wb3AoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcGx5ID0gbW9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwOyBpIDwgaXhQYXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGl4UGF0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gocCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHAuaXhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9IHNvdXJjZXNbcC5peHNbal0uaW5kZXhdLmNvbnN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnRfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCB3YXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZXZlbnRfMS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImZsdXNoaW5nIHZhbHVlc1wiLCB2YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcHBsaWVkID0gcC5mLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3NpbmtpbmcnLCBhcHBsaWVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseSA9IHNpbmsoKHRyaWdnZXIpLmUuYXBwbHkoYXBwbGllZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VycyA9IGZpbHRlcihub25GbGF0dGVuZWQsIHRyaWdnZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbHkgPT09IG5vTW9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGx5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsdXNoV2hpbGVUcmlnZ2VycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyBcImZsdXNoaW5nXCIsIF8udG9TdHJpbmcocmVzdWx0U3RyZWFtKVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbHkgPSBmbHVzaFdoaWxlVHJpZ2dlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cgXCJlbmRzIGRldGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGwoc291cmNlcywgY2Fubm90U3luYykgfHwgYWxsKGl4UGF0cywgY2Fubm90TWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyBcImFjdHVhbGx5IGVuZGluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHkgPSBub01vcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbHkgPT09IG5vTW9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJBbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbHkgPSBtb3JlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5pc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyBcImdvdCBlbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UubWFya0VuZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbHVzaExhdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5pc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseSA9IHNpbmsoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVFdmVudCA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nIFwiZ290IHZhbHVlXCIsIGUudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5wdXNoKHZhbHVlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyBcInF1ZXVpbmdcIiwgZS50b1N0cmluZygpLCB0b1N0cmluZyhyZXN1bHRTdHJlYW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnMucHVzaCh7IHNvdXJjZTogc291cmNlLCBlOiB2YWx1ZUV2ZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc0JhcnJpZXIgfHwgVXBkYXRlQmFycmllci5oYXNXYWl0ZXJzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hMYXRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGx5ID09PSBub01vcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3ViQWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGx5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZVVuc3Vic2NyaWJlKG1hcChwYXJ0LCBzb3VyY2VzKSkudW5zdWJzY3JpYmU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdFN0cmVhbTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NSYXdQYXR0ZXJucyhyYXdQYXR0ZXJucykge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgdmFyIHBhdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd1BhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfYSA9IHJhd1BhdHRlcm5zW2ldLCBwYXRTb3VyY2VzID0gX2FbMF0sIGYgPSBfYVsxXTtcbiAgICAgICAgdmFyIHBhdCA9IHsgZjogZiwgaXhzOiBbXSB9O1xuICAgICAgICB2YXIgdHJpZ2dlckZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBzOyBqIDwgcGF0U291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgcyA9IHBhdFNvdXJjZXNbal07XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mKHNvdXJjZXMsIHMpO1xuICAgICAgICAgICAgaWYgKCF0cmlnZ2VyRm91bmQpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRm91bmQgPSBpc1RyaWdnZXIocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKHMpO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc291cmNlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwYXQuaXhzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl4ID0gcGF0Lml4c1trXTtcbiAgICAgICAgICAgICAgICBpZiAoaXguaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGl4LmNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0Lml4cy5wdXNoKHsgaW5kZXg6IGluZGV4LCBjb3VudDogMSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0U291cmNlcy5sZW5ndGggPiAwICYmICF0cmlnZ2VyRm91bmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBFdmVudFN0cmVhbSByZXF1aXJlZCwgbm9uZSBmb3VuZCBpbiBcIiArIHBhdFNvdXJjZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRTb3VyY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhdHMucHVzaChwYXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbWFwKGZyb21PYnNlcnZhYmxlIC8qIHNvcnJ5ICovLCBzb3VyY2VzKSwgcGF0c107XG59XG5mdW5jdGlvbiBleHRyYWN0TGVnYWN5UGF0dGVybnMoc291cmNlQXJncykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gc291cmNlQXJncy5sZW5ndGg7XG4gICAgdmFyIHJhd1BhdHRlcm5zID0gW107XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgdmFyIHBhdFNvdXJjZXMgPSB0b0FycmF5KHNvdXJjZUFyZ3NbaSsrXSk7XG4gICAgICAgIHZhciBmID0gdG9GdW5jdGlvbihzb3VyY2VBcmdzW2krK10pO1xuICAgICAgICByYXdQYXR0ZXJucy5wdXNoKFtwYXRTb3VyY2VzLCBmXSk7XG4gICAgfVxuICAgIHZhciB1c2FnZSA9IFwid2hlbjogZXhwZWN0aW5nIGFyZ3VtZW50cyBpbiB0aGUgZm9ybSAoT2JzZXJ2YWJsZSssZnVuY3Rpb24pK1wiO1xuICAgIGFzc2VydCh1c2FnZSwgKGxlbiAlIDIgPT09IDApKTtcbiAgICByZXR1cm4gcmF3UGF0dGVybnM7XG59XG5mdW5jdGlvbiBpc1R5cGVkT3JSYXdQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gKHBhdHRlcm4gaW5zdGFuY2VvZiBBcnJheSkgJiYgKCFpc09ic2VydmFibGUocGF0dGVybltwYXR0ZXJuLmxlbmd0aCAtIDFdKSk7XG59XG5mdW5jdGlvbiBpc1Jhd1BhdHRlcm4ocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuWzBdIGluc3RhbmNlb2YgQXJyYXk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFJhd1BhdHRlcm5zKHBhdHRlcm5zKSB7XG4gICAgdmFyIHJhd1BhdHRlcm5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgICAgICBpZiAoIWlzVHlwZWRPclJhd1BhdHRlcm4ocGF0dGVybikpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGxlZ2FjeSBwYXR0ZXJuc1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RMZWdhY3lQYXR0ZXJucyhwYXR0ZXJucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmF3UGF0dGVybihwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmF3UGF0dGVybnMucHVzaChbcGF0dGVyblswXSwgdG9GdW5jdGlvbihwYXR0ZXJuWzFdKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyB0eXBlZCBwYXR0ZXJuLCB0aGVuXG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IHBhdHRlcm4uc2xpY2UoMCwgcGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHZhciBmID0gdG9GdW5jdGlvbihwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgcmF3UGF0dGVybnMucHVzaChbc291cmNlcywgZl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYXdQYXR0ZXJucztcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zRHVwbGljYXRlRGVwcyhvYnNlcnZhYmxlcywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkgeyBzdGF0ZSA9IFtdOyB9XG4gICAgZnVuY3Rpb24gY2hlY2tPYnNlcnZhYmxlKG9icykge1xuICAgICAgICBpZiAoY29udGFpbnMoc3RhdGUsIG9icykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRlcHMgPSBvYnMuaW50ZXJuYWxEZXBzKCk7XG4gICAgICAgICAgICBpZiAoZGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wdXNoKG9icyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFueShkZXBzLCBjaGVja09ic2VydmFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucHVzaChvYnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW55KG9ic2VydmFibGVzLCBjaGVja09ic2VydmFibGUpO1xufVxuZnVuY3Rpb24gY2Fubm90U3luYyhzb3VyY2UpIHtcbiAgICByZXR1cm4gIXNvdXJjZS5zeW5jIHx8IHNvdXJjZS5lbmRlZDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tRShzYW1wbGVyLCBzYW1wbGVlLCBmKSB7XG4gICAgdmFyIHJlc3VsdCA9IHdoZW4oW25ldyBEZWZhdWx0U291cmNlKHNhbXBsZWUudG9Qcm9wZXJ0eSgpLCBmYWxzZSksIG5ldyBEZWZhdWx0U291cmNlKHNhbXBsZXIsIHRydWUpLCBmbGlwKGYpXSk7XG4gICAgcmV0dXJuIHJlc3VsdC53aXRoRGVzYyhuZXcgRGVzYyhzYW1wbGVyLCBcIndpdGhMYXRlc3RGcm9tXCIsIFtzYW1wbGVlLCBmXSkpO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tUChzYW1wbGVyLCBzYW1wbGVlLCBmKSB7XG4gICAgdmFyIHJlc3VsdCA9IHdoZW5QKFtuZXcgRGVmYXVsdFNvdXJjZShzYW1wbGVlLnRvUHJvcGVydHkoKSwgZmFsc2UpLCBuZXcgRGVmYXVsdFNvdXJjZShzYW1wbGVyLCB0cnVlKSwgZmxpcChmKV0pO1xuICAgIHJldHVybiByZXN1bHQud2l0aERlc2MobmV3IERlc2Moc2FtcGxlciwgXCJ3aXRoTGF0ZXN0RnJvbVwiLCBbc2FtcGxlZSwgZl0pKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbShzYW1wbGVyLCBzYW1wbGVlLCBmKSB7XG4gICAgaWYgKHNhbXBsZXIgaW5zdGFuY2VvZiBQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gd2l0aExhdGVzdEZyb21QKHNhbXBsZXIsIHNhbXBsZWUsIGYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzYW1wbGVyIGluc3RhbmNlb2YgRXZlbnRTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHdpdGhMYXRlc3RGcm9tRShzYW1wbGVyLCBzYW1wbGVlLCBmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb2JzZXJ2YWJsZTogXCIgKyBzYW1wbGVyKTtcbiAgICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBtYXAkMShzcmMsIGYpIHtcbiAgICBpZiAoZiBpbnN0YW5jZW9mIFByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiB3aXRoTGF0ZXN0RnJvbShzcmMsIGYsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNyYy50cmFuc2Zvcm0obWFwVChmKSwgbmV3IERlc2Moc3JjLCBcIm1hcFwiLCBbZl0pKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBtYXBUKGYpIHtcbiAgICB2YXIgdGhlRiA9IF8udG9GdW5jdGlvbihmKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUsIHNpbmspIHtcbiAgICAgICAgcmV0dXJuIHNpbmsoZS5mbWFwKHRoZUYpKTtcbiAgICB9O1xufVxuXG4vKipcbiBDcmVhdGVzIGEgY29uc3RhbnQgcHJvcGVydHkgd2l0aCB2YWx1ZSBgeGAuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KG5ldyBEZXNjKFwiQmFjb25cIiwgXCJjb25zdGFudFwiLCBbeF0pLCBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICBzaW5rKGluaXRpYWxFdmVudCh4KSk7XG4gICAgICAgIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgIHJldHVybiBub3A7XG4gICAgfSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBhcmd1bWVudHNUb09ic2VydmFibGVzKGFyZ3MpIHtcbiAgICBhcmdzID0gKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgICByZXR1cm4gXy5mbGF0TWFwKHNpbmdsZVRvT2JzZXJ2YWJsZXMsIGFyZ3MpO1xufVxuZnVuY3Rpb24gc2luZ2xlVG9PYnNlcnZhYmxlcyh4KSB7XG4gICAgaWYgKGlzT2JzZXJ2YWJsZSh4KSkge1xuICAgICAgICByZXR1cm4gW3hdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHgpKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNUb09ic2VydmFibGVzKHgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtjb25zdGFudCh4KV07XG4gICAgfVxufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFyZ3VtZW50c1RvT2JzZXJ2YWJsZXNBbmRGdW5jdGlvbihhcmdzKSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihhcmdzWzBdKSkge1xuICAgICAgICByZXR1cm4gW2FyZ3VtZW50c1RvT2JzZXJ2YWJsZXMoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpLCBhcmdzWzBdXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbYXJndW1lbnRzVG9PYnNlcnZhYmxlcyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAwLCBhcmdzLmxlbmd0aCAtIDEpKSwgXy5sYXN0KGFyZ3MpXTtcbiAgICB9XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBncm91cFNpbXVsdGFuZW91cygpIHtcbiAgICB2YXIgc3RyZWFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwU2ltdWx0YW5lb3VzXyhhcmd1bWVudHNUb09ic2VydmFibGVzKHN0cmVhbXMpKTtcbn1cbi8vIFRPRE86IHR5cGUgaXMgbm90IGV4YWN0bHkgY29ycmVjdCwgYmVjYXVzZSBkaWZmZXJlbnQgaW5wdXRzIG1heSBoYXZlIGRpZmZlcmVudCB0eXBlcy5cbi8vIFJlc3VsdCB2YWx1ZXMgYXJlIGFycmF5cyB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgdGhlIGxpc3QgZnJvbSBlYWNoIGlucHV0IG9ic2VydmFibGUuIFR5cGUgdGhpcy5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBncm91cFNpbXVsdGFuZW91c18oc3RyZWFtcywgb3B0aW9ucykge1xuICAgIHZhciBzb3VyY2VzID0gXy5tYXAoZnVuY3Rpb24gKHN0cmVhbSkgeyByZXR1cm4gbmV3IEJ1ZmZlcmluZ1NvdXJjZShzdHJlYW0pOyB9LCBzdHJlYW1zKTtcbiAgICB2YXIgY3RvciA9IGZ1bmN0aW9uIChkZXNjLCBzdWJzY3JpYmUpIHsgcmV0dXJuIG5ldyBFdmVudFN0cmVhbShkZXNjLCBzdWJzY3JpYmUsIHVuZGVmaW5lZCwgb3B0aW9ucyk7IH07XG4gICAgcmV0dXJuIHdoZW5fKGN0b3IsIFtzb3VyY2VzLCAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHhzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHhzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geHM7XG4gICAgICAgIH0pXSkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcImdyb3VwU2ltdWx0YW5lb3VzXCIsIHN0cmVhbXMpKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGF3YWl0aW5nKHNyYywgb3RoZXIpIHtcbiAgICByZXR1cm4gZ3JvdXBTaW11bHRhbmVvdXNfKFtzcmMsIG90aGVyXSwgYWxsb3dTeW5jKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlc1sxXS5sZW5ndGggPT09IDA7IH0pXG4gICAgICAgIC50b1Byb3BlcnR5KGZhbHNlKVxuICAgICAgICAuc2tpcER1cGxpY2F0ZXMoKVxuICAgICAgICAud2l0aERlc2MobmV3IERlc2Moc3JjLCBcImF3YWl0aW5nXCIsIFtvdGhlcl0pKTtcbn1cblxuLyoqXG4gQ29tYmluZXMgUHJvcGVydGllcywgRXZlbnRTdHJlYW1zIGFuZCBjb25zdGFudCB2YWx1ZXMgc28gdGhhdCB0aGUgcmVzdWx0IFByb3BlcnR5IHdpbGwgaGF2ZSBhbiBhcnJheSBvZiB0aGUgbGF0ZXN0XG4gdmFsdWVzIGZyb20gYWxsIHNvdXJjZXMgYXMgaXRzIHZhbHVlLiBUaGUgaW5wdXRzIG1heSBjb250YWluIGJvdGggUHJvcGVydGllcyBhbmQgRXZlbnRTdHJlYW1zLlxuXG5cbiBgYGBqc1xuIHByb3BlcnR5ID0gQmFjb24uY29uc3RhbnQoMSlcbiBzdHJlYW0gPSBCYWNvbi5vbmNlKDIpXG4gY29uc3RhbnQgPSAzXG4gQmFjb24uY29tYmluZUFzQXJyYXkocHJvcGVydHksIHN0cmVhbSwgY29uc3RhbnQpXG4gIyBwcm9kdWNlcyB0aGUgdmFsdWUgWzEsMiwzXVxuIGBgYFxuXG4gKiBAcGFyYW0gc3RyZWFtcyBzdHJlYW1zIGFuZCBwcm9wZXJ0aWVzIHRvIGNvbWJpbmVcbiAqL1xuZnVuY3Rpb24gY29tYmluZUFzQXJyYXkoKSB7XG4gICAgdmFyIHN0cmVhbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzdHJlYW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHN0cmVhbXMgPSBhcmd1bWVudHNUb09ic2VydmFibGVzKHN0cmVhbXMpO1xuICAgIGlmIChzdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSAoaXNPYnNlcnZhYmxlKHN0cmVhbXNbaV0pXG4gICAgICAgICAgICAgICAgPyBzdHJlYW1zW2ldXG4gICAgICAgICAgICAgICAgOiBjb25zdGFudChzdHJlYW1zW2ldKSk7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2god3JhcChzdHJlYW0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2hlblAoW3NvdXJjZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgeHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB4c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geHM7XG4gICAgICAgICAgICB9XSkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcImNvbWJpbmVBc0FycmF5XCIsIHN0cmVhbXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudChbXSk7XG4gICAgfVxufVxuLyoqXG4gIENvbWJpbmVzIGdpdmVuICpuKiBQcm9wZXJ0aWVzLFxuICBFdmVudFN0cmVhbXMgYW5kIGNvbnN0YW50IHZhbHVlcyB1c2luZyB0aGUgZ2l2ZW4gbi1hcnkgZnVuY3Rpb24gYGYodjEsIHYyIC4uLilgLlxuXG4gIFRvIGNhbGN1bGF0ZSB0aGUgY3VycmVudCBzdW0gb2YgdGhyZWUgbnVtZXJpYyBQcm9wZXJ0aWVzLCB5b3UgY2FuIGRvXG5cbmBgYGpzXG5mdW5jdGlvbiBzdW0zKHgseSx6KSB7IHJldHVybiB4ICsgeSArIHogfVxuQmFjb24uY29tYmluZVdpdGgoc3VtMywgcDEsIHAyLCBwMylcbmBgYFxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVXaXRoKGYpIHtcbiAgICB2YXIgc3RyZWFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIC8vIFRPRE86IHVudHlwZWRcbiAgICB2YXIgX2EgPSBhcmd1bWVudHNUb09ic2VydmFibGVzQW5kRnVuY3Rpb24oYXJndW1lbnRzKSwgc3RyZWFtcyA9IF9hWzBdLCBmID0gX2FbMV07XG4gICAgdmFyIGRlc2MgPSBuZXcgRGVzYyhcIkJhY29uXCIsIFwiY29tYmluZVdpdGhcIiwgW2ZdLmNvbmNhdChzdHJlYW1zKSk7XG4gICAgcmV0dXJuIGNvbWJpbmVBc0FycmF5KHN0cmVhbXMpLm1hcChmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBmLmFwcGx5KHZvaWQgMCwgdmFsdWVzKTtcbiAgICB9KS53aXRoRGVzYyhkZXNjKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBjb21iaW5lKGxlZnQsIHJpZ2h0LCBmKSB7XG4gICAgcmV0dXJuIHdoZW5QKFtbd3JhcChsZWZ0KSwgd3JhcChyaWdodCldLCBmXSkud2l0aERlc2MobmV3IERlc2MobGVmdCwgXCJjb21iaW5lXCIsIFtyaWdodCwgZl0pKTtcbn1cbmZ1bmN0aW9uIHdyYXAob2JzKSB7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0U291cmNlKG9icywgdHJ1ZSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBza2lwKHNyYywgY291bnQpIHtcbiAgICByZXR1cm4gc3JjLnRyYW5zZm9ybShmdW5jdGlvbiAoZXZlbnQsIHNpbmspIHtcbiAgICAgICAgaWYgKCFldmVudC5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSwgbmV3IERlc2Moc3JjLCBcInNraXBcIiwgW2NvdW50XSkpO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZmxhdE1hcENvbmNhdChzcmMsIGYpIHtcbiAgICByZXR1cm4gZmxhdE1hcF8oaGFuZGxlRXZlbnRWYWx1ZVdpdGgoZiksIHNyYywge1xuICAgICAgICBkZXNjOiBuZXcgRGVzYyhzcmMsIFwiZmxhdE1hcENvbmNhdFwiLCBbZl0pLFxuICAgICAgICBsaW1pdDogMVxuICAgIH0pO1xufVxuXG4vKipcbiBJZiBub25lIG9mIHRoZSBvdGhlciBmYWN0b3J5IG1ldGhvZHMgYWJvdmUgYXBwbHksIHlvdSBtYXkgb2YgY291cnNlIHJvbGwgeW91ciBvd24gRXZlbnRTdHJlYW0gYnkgdXNpbmcgYGZyb21CaW5kZXJgLlxuXG4gPGEgbmFtZT1cImJhY29uLWZyb21iaW5kZXJcIj48L2E+XG4gW2BCYWNvbi5mcm9tQmluZGVyKHN1YnNjcmliZSlgXSgjYmFjb24tZnJvbWJpbmRlciBcIkJhY29uLmZyb21CaW5kZXIoc3Vic2NyaWJlKVwiKSBUaGUgcGFyYW1ldGVyIGBzdWJzY3JpYmVgIGlzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgYHNpbmtgIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCB5b3VyIGBzdWJzY3JpYmVgIGZ1bmN0aW9uIGNhbiBcInB1c2hcIiBldmVudHMgdG8uXG5cbiBGb3IgZXhhbXBsZTpcblxuIGBgYGpzXG4gdmFyIHN0cmVhbSA9IEJhY29uLmZyb21CaW5kZXIoZnVuY3Rpb24oc2luaykge1xuICBzaW5rKFwiZmlyc3QgdmFsdWVcIilcbiAgc2luayhbbmV3IEJhY29uLk5leHQoXCIybmRcIiksIG5ldyBCYWNvbi5OZXh0KFwiM3JkXCIpXSlcbiAgc2luayhuZXcgQmFjb24uRXJyb3IoXCJvb3BzLCBhbiBlcnJvclwiKSlcbiAgc2luayhuZXcgQmFjb24uRW5kKCkpXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgLy8gdW5zdWIgZnVuY3Rpb25hbGl0eSBoZXJlLCB0aGlzIG9uZSdzIGEgbm8tb3BcbiAgfVxufSlcbiBzdHJlYW0ubG9nKClcbiBgYGBcblxuIEFzIHNob3duIGluIHRoZSBleGFtcGxlLCB5b3UgY2FuIHB1c2hcblxuIC0gQSBwbGFpbiB2YWx1ZSwgbGlrZSBgXCJmaXJzdCB2YWx1ZVwiYFxuIC0gQW4gW2BFdmVudGBdKCNldmVudCkgb2JqZWN0IGluY2x1ZGluZyBbYEJhY29uLkVycm9yYF0oI2JhY29uLWVycm9yKSAod3JhcHMgYW4gZXJyb3IpIGFuZCBbYEJhY29uLkVuZGBdKCNiYWNvbi1lbmQpIChpbmRpY2F0ZXNcbiBzdHJlYW0gZW5kKS5cbiAtIEFuIGFycmF5IG9mIFtldmVudF0oI2V2ZW50KSBvYmplY3RzIGF0IG9uY2VcblxuIE90aGVyIGV4YW1wbGVzIGNhbiBiZSBmb3VuZCBvbiBbSlNGaWRkbGVdKGh0dHA6Ly9qc2ZpZGRsZS5uZXQvUEc0YzQvKSBhbmQgdGhlXG4gW0JhY29uLmpzIGJsb2ddKGh0dHA6Ly9iYWNvbmpzLmJsb2dzcG90LmZpLzIwMTMvMTIvd3JhcHBpbmctdGhpbmdzLWluLWJhY29uLmh0bWwpLlxuXG4gVGhlIGBzdWJzY3JpYmVgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgZnVuY3Rpb24uIExldCdzIGNhbGwgdGhhdCBmdW5jdGlvblxuIGB1bnN1YnNjcmliZWAuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiBjYW4gYmUgdXNlZCBieSB0aGUgc3Vic2NyaWJlciAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseSkgdG9cbiB1bnN1YnNjcmliZSBmcm9tIHRoZSBFdmVudFN0cmVhbS4gSXQgc2hvdWxkIHJlbGVhc2UgYWxsIHJlc291cmNlcyB0aGF0IHRoZSBzdWJzY3JpYmUgZnVuY3Rpb24gcmVzZXJ2ZWQuXG5cbiBUaGUgYHNpbmtgIGZ1bmN0aW9uIG1heSByZXR1cm4gW2BCYWNvbi5ub01vcmVgXSgjYmFjb24tbm9tb3JlKSAoYXMgd2VsbCBhcyBbYEJhY29uLm1vcmVgXSgjYmFjb24tbW9yZSlcbiBvciBhbnkgb3RoZXIgdmFsdWUpLiBJZiBpdCByZXR1cm5zIFtgQmFjb24ubm9Nb3JlYF0oI2JhY29uLW5vbW9yZSksIG5vIGZ1cnRoZXIgZXZlbnRzIHdpbGwgYmUgY29uc3VtZWRcbiBieSB0aGUgc3Vic2NyaWJlci4gVGhlIGBzdWJzY3JpYmVgIGZ1bmN0aW9uIG1heSBjaG9vc2UgdG8gY2xlYW4gdXAgYWxsIHJlc291cmNlcyBhdCB0aGlzIHBvaW50IChlLmcuLFxuIGJ5IGNhbGxpbmcgYHVuc3Vic2NyaWJlYCkuIFRoaXMgaXMgdXN1YWxseSBub3QgbmVjZXNzYXJ5LCBiZWNhdXNlIGZ1cnRoZXIgY2FsbHMgdG8gYHNpbmtgIGFyZSBpZ25vcmVkLFxuIGJ1dCBkb2luZyBzbyBjYW4gaW5jcmVhc2UgcGVyZm9ybWFuY2UgaW4gW3JhcmUgY2FzZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9iYWNvbmpzL2JhY29uLmpzL2lzc3Vlcy80ODQpLlxuXG4gVGhlIEV2ZW50U3RyZWFtIHdpbGwgd3JhcCB5b3VyIGBzdWJzY3JpYmVgIGZ1bmN0aW9uIHNvIHRoYXQgaXQgd2lsbFxuIG9ubHkgYmUgY2FsbGVkIHdoZW4gdGhlIGZpcnN0IHN0cmVhbSBsaXN0ZW5lciBpcyBhZGRlZCwgYW5kIHRoZSBgdW5zdWJzY3JpYmVgXG4gZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgYWZ0ZXIgdGhlIGxhc3QgbGlzdGVuZXIgaGFzIGJlZW4gcmVtb3ZlZC5cbiBUaGUgc3Vic2NyaWJlLXVuc3Vic2NyaWJlIGN5Y2xlIG1heSBvZiBjb3Vyc2UgYmUgcmVwZWF0ZWQgaW5kZWZpbml0ZWx5LFxuIHNvIHByZXBhcmUgZm9yIG11bHRpcGxlIGNhbGxzIHRvIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb24uXG5cblxuIEBwYXJhbSAgYmluZGVyXG4gQHBhcmFtICBldmVudFRyYW5zZm9ybWVyXG4gQHR5cGVwYXJhbSBWIFR5cGUgb2Ygc3RyZWFtIGVsZW1lbnRzXG5cbiAqL1xuZnVuY3Rpb24gZnJvbUJpbmRlcihiaW5kZXIsIGV2ZW50VHJhbnNmb3JtZXIpIHtcbiAgICBpZiAoZXZlbnRUcmFuc2Zvcm1lciA9PT0gdm9pZCAwKSB7IGV2ZW50VHJhbnNmb3JtZXIgPSBfLmlkOyB9XG4gICAgdmFyIGRlc2MgPSBuZXcgRGVzYyhcIkJhY29uXCIsIFwiZnJvbUJpbmRlclwiLCBbYmluZGVyLCBldmVudFRyYW5zZm9ybWVyXSk7XG4gICAgcmV0dXJuIG5ldyBFdmVudFN0cmVhbShkZXNjLCBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB2YXIgdW5ib3VuZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2hvdWxkVW5iaW5kID0gZmFsc2U7XG4gICAgICAgIHZhciB1bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXVuYm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiB1bmJpbmRlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB1bmJpbmRlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5iaW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZFVuYmluZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdW5iaW5kZXIgPSBiaW5kZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlXyA9IGV2ZW50VHJhbnNmb3JtZXIuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZUFycmF5ID0gaXNBcnJheSh2YWx1ZV8pICYmIGlzRXZlbnQoXy5sYXN0KHZhbHVlXykpXG4gICAgICAgICAgICAgICAgPyB2YWx1ZV9cbiAgICAgICAgICAgICAgICA6IFt2YWx1ZV9dO1xuICAgICAgICAgICAgdmFyIHJlcGx5ID0gbW9yZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gdG9FdmVudCh2YWx1ZUFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICByZXBseSA9IHNpbmsoZXZlbnRfMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGx5ID09PSBub01vcmUgfHwgZXZlbnRfMS5pc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZlciBpZiBiaW5kZXIgY2FsbHMgaGFuZGxlciBpbiBzeW5jIGJlZm9yZSByZXR1cm5pbmcgdW5iaW5kZXJcbiAgICAgICAgICAgICAgICAgICAgdW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBseTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVwbHk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hvdWxkVW5iaW5kKSB7XG4gICAgICAgICAgICB1bmJpbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5iaW5kO1xuICAgIH0pO1xufVxuXG4vKipcbiBQb2xscyBnaXZlbiBmdW5jdGlvbiB3aXRoIGdpdmVuIGludGVydmFsLlxuIEZ1bmN0aW9uIHNob3VsZCByZXR1cm4gRXZlbnRzOiBlaXRoZXIgW2BCYWNvbi5OZXh0YF0oY2xhc3Nlcy9uZXh0Lmh0bWwpIG9yIFtgQmFjb24uRW5kYF0oY2xhc3Nlcy9lbmQuaHRtbCkuIFBvbGxpbmcgb2NjdXJzIG9ubHlcbiB3aGVuIHRoZXJlIGFyZSBzdWJzY3JpYmVycyB0byB0aGUgc3RyZWFtLiBQb2xsaW5nIGVuZHMgcGVybWFuZW50bHkgd2hlblxuIGBmYCByZXR1cm5zIFtgQmFjb24uRW5kYF0oY2xhc3Nlcy9lbmQuaHRtbCkuXG4gKiBAcGFyYW0gZGVsYXkgcG9sbCBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSBwb2xsIGZ1bmN0aW9uIHRvIGJlIHBvbGxlZFxuICogQHR5cGVwYXJhbSBWIFR5cGUgb2Ygc3RyZWFtIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGZyb21Qb2xsKGRlbGF5LCBwb2xsKSB7XG4gICAgdmFyIGRlc2MgPSBuZXcgRGVzYyhcIkJhY29uXCIsIFwiZnJvbVBvbGxcIiwgW2RlbGF5LCBwb2xsXSk7XG4gICAgcmV0dXJuIGZyb21CaW5kZXIoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHZhciBpZCA9IEdsb2JhbFNjaGVkdWxlci5zY2hlZHVsZXIuc2V0SW50ZXJ2YWwoaGFuZGxlciwgZGVsYXkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEdsb2JhbFNjaGVkdWxlci5zY2hlZHVsZXIuY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgICAgIH07XG4gICAgfSksIHBvbGwpLndpdGhEZXNjKGRlc2MpO1xufVxuXG4vKipcbiBSZXBlYXRzIHRoZSBzaW5nbGUgZWxlbWVudCBpbmRlZmluaXRlbHkgd2l0aCB0aGUgZ2l2ZW4gaW50ZXJ2YWwgKGluIG1pbGxpc2Vjb25kcylcblxuIEBwYXJhbSAgIGRlbGF5ICAgUmVwZWF0IGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuIEBwYXJhbSAgIHZhbHVlICAgVGhlIHNpbmdsZSB2YWx1ZSB0byByZXBlYXRcbiBAdHlwZXBhcmFtIFYgVHlwZSBvZiBzdHJlYW0gZWxlbWVudHNcbiAqL1xuZnVuY3Rpb24gaW50ZXJ2YWwoZGVsYXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZyb21Qb2xsKGRlbGF5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXh0RXZlbnQodmFsdWUpO1xuICAgIH0pLndpdGhEZXNjKG5ldyBEZXNjKFwiQmFjb25cIiwgXCJpbnRlcnZhbFwiLCBbZGVsYXksIHZhbHVlXSkpO1xufVxuXG5mdW5jdGlvbiBtYWtlQ29tYmluYXRvcihjb21iaW5hdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBjb21iaW5hdG9yID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY29tYmluYXRvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfLmlkO1xuICAgIH1cbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBzYW1wbGVkQnkoc2FtcGxlZSwgc2FtcGxlciwgZikge1xuICAgIGlmIChzYW1wbGVlIGluc3RhbmNlb2YgRXZlbnRTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZWRCeUUoc2FtcGxlZSwgc2FtcGxlciwgZik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2FtcGxlZEJ5UChzYW1wbGVlLCBzYW1wbGVyLCBmKTtcbiAgICB9XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gc2FtcGxlZEJ5UChzYW1wbGVlLCBzYW1wbGVyLCBmKSB7XG4gICAgdmFyIGNvbWJpbmF0b3IgPSBtYWtlQ29tYmluYXRvcihmKTtcbiAgICB2YXIgcmVzdWx0ID0gd2l0aExhdGVzdEZyb20oc2FtcGxlciwgc2FtcGxlZSwgZmxpcChjb21iaW5hdG9yKSk7XG4gICAgcmV0dXJuIHJlc3VsdC53aXRoRGVzYyhuZXcgRGVzYyhzYW1wbGVlLCBcInNhbXBsZWRCeVwiLCBbc2FtcGxlcl0pKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBzYW1wbGVkQnlFKHNhbXBsZWUsIHNhbXBsZXIsIGYpIHtcbiAgICByZXR1cm4gc2FtcGxlZEJ5UChzYW1wbGVlLnRvUHJvcGVydHkoKSwgc2FtcGxlciwgZikud2l0aERlc2MobmV3IERlc2Moc2FtcGxlZSwgXCJzYW1wbGVkQnlcIiwgW3NhbXBsZXJdKSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gc2FtcGxlUChzYW1wbGVlLCBzYW1wbGluZ0ludGVydmFsKSB7XG4gICAgcmV0dXJuIHNhbXBsZWRCeVAoc2FtcGxlZSwgaW50ZXJ2YWwoc2FtcGxpbmdJbnRlcnZhbCwge30pLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYTsgfSkud2l0aERlc2MobmV3IERlc2Moc2FtcGxlZSwgXCJzYW1wbGVcIiwgW3NhbXBsaW5nSW50ZXJ2YWxdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1QKHNyYywgdHJhbnNmb3JtZXIsIGRlc2MpIHtcbiAgICByZXR1cm4gbmV3IFByb3BlcnR5KG5ldyBEZXNjKHNyYywgXCJ0cmFuc2Zvcm1cIiwgW3RyYW5zZm9ybWVyXSksIGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHJldHVybiBzcmMuc3Vic2NyaWJlSW50ZXJuYWwoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcihlLCBzaW5rKTtcbiAgICAgICAgfSk7XG4gICAgfSkud2l0aERlc2MoZGVzYyk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtRShzcmMsIHRyYW5zZm9ybWVyLCBkZXNjKSB7XG4gICAgcmV0dXJuIG5ldyBFdmVudFN0cmVhbShuZXcgRGVzYyhzcmMsIFwidHJhbnNmb3JtXCIsIFt0cmFuc2Zvcm1lcl0pLCBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICByZXR1cm4gc3JjLnN1YnNjcmliZUludGVybmFsKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIoZSwgc2luayk7XG4gICAgICAgIH0pO1xuICAgIH0sIHVuZGVmaW5lZCwgYWxsb3dTeW5jKS53aXRoRGVzYyhkZXNjKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBjb21wb3NlVCh0MSwgdDIpIHtcbiAgICB2YXIgZmluYWxTaW5rOyAvLyBtdXRhdGlvbiB1c2VkIHRvIGF2b2lkIGNsb3N1cmUgY3JlYXRpb24gd2hpbGUgZGlzcGF0Y2hpbmcgZXZlbnRzXG4gICAgdmFyIHNpbmsyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0MihldmVudCwgZmluYWxTaW5rKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsIHNpbmspIHtcbiAgICAgICAgZmluYWxTaW5rID0gc2luaztcbiAgICAgICAgcmV0dXJuIHQxKGV2ZW50LCBzaW5rMik7XG4gICAgfTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHRvUHJlZGljYXRlKGYpIHtcbiAgICBpZiAodHlwZW9mIGYgPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIF8uYWx3YXlzKGYpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZiAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgZnVuY3Rpb246IFwiICsgZik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gd2l0aFByZWRpY2F0ZShzcmMsIGYsIHByZWRpY2F0ZVRyYW5zZm9ybWVyLCBkZXNjKSB7XG4gICAgaWYgKGYgaW5zdGFuY2VvZiBQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gd2l0aExhdGVzdEZyb20oc3JjLCBmLCBmdW5jdGlvbiAocCwgdikgeyByZXR1cm4gW3AsIHZdOyB9KVxuICAgICAgICAgICAgLnRyYW5zZm9ybShjb21wb3NlVChwcmVkaWNhdGVUcmFuc2Zvcm1lcigoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiB0dXBsZVsxXTsgfSkpLCBtYXBUKGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gdHVwbGVbMF07IH0pKSwgZGVzYyk7XG4gICAgICAgIC8vIHRoZSBgYW55YCB0eXBlIGFib3ZlIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSB0eXBlIGFyZ3VtZW50IGZvciBQcmVkaWNhdGUyVHJhbnNmb3JtZXIgaXMgZml4ZWQuIFdlJ2QgbmVlZCBoaWdoZXIta2luZGVkIHR5cGVzIHRvIGJlIGFibGUgdG8gZXhwcmVzcyB0aGlzIHByb3Blcmx5LCBJIHRoaW5rLlxuICAgIH1cbiAgICByZXR1cm4gc3JjLnRyYW5zZm9ybShwcmVkaWNhdGVUcmFuc2Zvcm1lcih0b1ByZWRpY2F0ZShmKSksIGRlc2MpO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZmlsdGVyJDEoc3JjLCBmKSB7XG4gICAgcmV0dXJuIHdpdGhQcmVkaWNhdGUoc3JjLCBmLCBmaWx0ZXJULCBuZXcgRGVzYyhzcmMsIFwiZmlsdGVyXCIsIFtmXSkpO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGZpbHRlclQoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSwgc2luaykge1xuICAgICAgICBpZiAoZS5maWx0ZXIoZikpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbm90KHNyYykge1xuICAgIHJldHVybiBzcmMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiAheDsgfSkud2l0aERlc2MobmV3IERlc2Moc3JjLCBcIm5vdFwiLCBbXSkpO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFuZChsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBsZWZ0LmNvbWJpbmUodG9Qcm9wZXJ0eShyaWdodCksIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiAhISh4ICYmIHkpOyB9KS53aXRoRGVzYyhuZXcgRGVzYyhsZWZ0LCBcImFuZFwiLCBbcmlnaHRdKSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gb3IobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdC5jb21iaW5lKHRvUHJvcGVydHkocmlnaHQpLCBmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geCB8fCB5OyB9KS53aXRoRGVzYyhuZXcgRGVzYyhsZWZ0LCBcIm9yXCIsIFtyaWdodF0pKTtcbn1cbmZ1bmN0aW9uIHRvUHJvcGVydHkoeCkge1xuICAgIGlmIChpc1Byb3BlcnR5KHgpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RhbnQoeCk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBmbGF0TWFwRmlyc3Qoc3JjLCBmKSB7XG4gICAgcmV0dXJuIGZsYXRNYXBfKGhhbmRsZUV2ZW50VmFsdWVXaXRoKGYpLCBzcmMsIHtcbiAgICAgICAgZmlyc3RPbmx5OiB0cnVlLFxuICAgICAgICBkZXNjOiBuZXcgRGVzYyhzcmMsIFwiZmxhdE1hcEZpcnN0XCIsIFtmXSlcbiAgICB9KTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGNvbmNhdEUobGVmdCwgcmlnaHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEV2ZW50U3RyZWFtKG5ldyBEZXNjKGxlZnQsIFwiY29uY2F0XCIsIFtyaWdodF0pLCBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB2YXIgdW5zdWJSaWdodCA9IG5vcDtcbiAgICAgICAgdmFyIHVuc3ViTGVmdCA9IGxlZnQuZGlzcGF0Y2hlci5zdWJzY3JpYmUoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmlzRW5kKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJSaWdodCA9IHJpZ2h0LnRvRXZlbnRTdHJlYW0oKS5kaXNwYXRjaGVyLnN1YnNjcmliZShzaW5rKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW5rKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bnN1YkxlZnQoKSwgdW5zdWJSaWdodCgpO1xuICAgICAgICB9O1xuICAgIH0sIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG59XG4vKipcbiBDb25jYXRlbmF0ZXMgZ2l2ZW4gYXJyYXkgb2YgRXZlbnRTdHJlYW1zIG9yIFByb3BlcnRpZXMuIFdvcmtzIGJ5IHN1YmNyaWJpbmcgdG8gdGhlIGZpcnN0IHNvdXJjZSwgYW5kIGxpc3RlaW5nIHRvIHRoYXRcbiB1bnRpbCBpdCBlbmRzLiBUaGVuIHJlcGVhdGVkbHkgc3Vic2NyaWJlcyB0byB0aGUgbmV4dCBzb3VyY2UsIHVudGlsIGFsbCBzb3VyY2VzIGhhdmUgZW5kZWQuXG5cbiBTZWUgW2Bjb25jYXRgXSgjb2JzZXJ2YWJsZS1jb25jYXQpXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEFsbCgpIHtcbiAgICB2YXIgc3RyZWFtc18gPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBzdHJlYW1zX1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtcyA9IGFyZ3VtZW50c1RvT2JzZXJ2YWJsZXMoc3RyZWFtc18pO1xuICAgIHJldHVybiAoc3RyZWFtcy5sZW5ndGhcbiAgICAgICAgPyBmb2xkKHRhaWwoc3RyZWFtcyksIGhlYWQoc3RyZWFtcykudG9FdmVudFN0cmVhbSgpLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5jb25jYXQoYik7IH0pXG4gICAgICAgIDogbmV2ZXIoKSkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcImNvbmNhdEFsbFwiLCBzdHJlYW1zKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qcm9wZXJ0eUNoYW5nZXMocHJvcGVydHksIGYsIGRlc2MpIHtcbiAgICB2YXIgaW5pdFZhbHVlO1xuICAgIHZhciBjb21ib1Npbms7XG4gICAgLy8gQ3JlYXRlIGEgYGNoYW5nZXNgIHN0cmVhbSB0byBiZSB0cmFuc2Zvcm1lZCwgd2hpY2ggYWxzbyBzbmF0Y2hlcyB0aGUgSW5pdGlhbCB2YWx1ZSBmb3IgbGF0ZXIgdXNlLlxuICAgIHZhciBjaGFuZ2VzID0gbmV3IEV2ZW50U3RyZWFtKGRlc2NyaWJlKHByb3BlcnR5LCBcImNoYW5nZXNcIiwgW10pLCBmdW5jdGlvbiAoc2luaykgeyByZXR1cm4gcHJvcGVydHkuZGlzcGF0Y2hlci5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghaW5pdFZhbHVlICYmIGlzSW5pdGlhbChldmVudCkpIHtcbiAgICAgICAgICAgIGluaXRWYWx1ZSA9IGV2ZW50O1xuICAgICAgICAgICAgVXBkYXRlQmFycmllci53aGVuRG9uZVdpdGgoY29tYm8sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbWJvU2luaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbml0IHNlcXVlbmNlIGZhaWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbWJvU2luayhpbml0VmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFldmVudC5pc0luaXRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9yZTtcbiAgICB9KTsgfSwgdW5kZWZpbmVkLCBhbGxvd1N5bmMpO1xuICAgIHZhciB0cmFuc2Zvcm1lZENoYW5nZXMgPSBmKGNoYW5nZXMpO1xuICAgIHZhciBjb21ibyA9IHByb3BlcnR5RnJvbVN0cmVhbVN1YnNjcmliZShkZXNjLCBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICBjb21ib1NpbmsgPSBzaW5rO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRDaGFuZ2VzLmRpc3BhdGNoZXIuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgc2luayhldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb21ibztcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGZvbGQkMShzcmMsIHNlZWQsIGYpIHtcbiAgICByZXR1cm4gc3JjLnNjYW4oc2VlZCwgZilcbiAgICAgICAgLmxhc3QoKVxuICAgICAgICAud2l0aERlc2MobmV3IERlc2Moc3JjLCBcImZvbGRcIiwgW3NlZWQsIGZdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBzdGFydFdpdGhFKHNyYywgc2VlZCkge1xuICAgIHJldHVybiBvbmNlKHNlZWQpLmNvbmNhdChzcmMpLndpdGhEZXNjKG5ldyBEZXNjKHNyYywgXCJzdGFydFdpdGhcIiwgW3NlZWRdKSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoUChzcmMsIHNlZWQpIHtcbiAgICByZXR1cm4gc3JjLnNjYW4oc2VlZCwgZnVuY3Rpb24gKHByZXYsIG5leHQpIHsgcmV0dXJuIG5leHQ7IH0pLndpdGhEZXNjKG5ldyBEZXNjKHNyYywgXCJzdGFydFdpdGhcIiwgW3NlZWRdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG52YXIgZW5kTWFya2VyID0ge307XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdGFrZVVudGlsKHNyYywgc3RvcHBlcikge1xuICAgIHZhciBlbmRNYXBwZWQgPSBzcmMubWFwRW5kKGVuZE1hcmtlcik7XG4gICAgdmFyIHdpdGhFbmRNYXJrZXIgPSBncm91cFNpbXVsdGFuZW91c18oW2VuZE1hcHBlZCwgc3RvcHBlci5za2lwRXJyb3JzKCldLCBhbGxvd1N5bmMpO1xuICAgIGlmIChzcmMgaW5zdGFuY2VvZiBQcm9wZXJ0eSlcbiAgICAgICAgd2l0aEVuZE1hcmtlciA9IHdpdGhFbmRNYXJrZXIudG9Qcm9wZXJ0eSgpO1xuICAgIHJldHVybiB3aXRoRW5kTWFya2VyLnRyYW5zZm9ybShmdW5jdGlvbiAoZXZlbnQsIHNpbmspIHtcbiAgICAgICAgaWYgKGhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgICAgICAgdmFyIF9hID0gZXZlbnQudmFsdWUsIGRhdGEgPSBfYVswXSwgc3RvcHBlciA9IF9hWzFdO1xuICAgICAgICAgICAgaWYgKHN0b3BwZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbHkgPSBtb3JlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGVuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseSA9IHNpbmsobmV4dEV2ZW50KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSwgbmV3IERlc2Moc3JjLCBcInRha2VVbnRpbFwiLCBbc3RvcHBlcl0pKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGZsYXRNYXAkMShzcmMsIGYpIHtcbiAgICByZXR1cm4gZmxhdE1hcF8oaGFuZGxlRXZlbnRWYWx1ZVdpdGgoZiksIHNyYywgeyBkZXNjOiBuZXcgRGVzYyhzcmMsIFwiZmxhdE1hcFwiLCBbZl0pIH0pO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZmxhdE1hcEVycm9yKHNyYywgZikge1xuICAgIHJldHVybiBmbGF0TWFwXyhmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEVycm9yJDEpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHguZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gZihlcnJvcik7IC8vIEkgZG9uJ3QgdW5kZXJzdGFuZCB3aHkgSSBuZWVkIHRoaXMgbGl0dGxlIGxpZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9LCBzcmMsIHtcbiAgICAgICAgbWFwRXJyb3I6IHRydWUsXG4gICAgICAgIGRlc2M6IG5ldyBEZXNjKHNyYywgXCJmbGF0TWFwRXJyb3JcIiwgW2ZdKVxuICAgIH0pO1xufVxuXG52YXIgc3BpZXMgPSBbXTtcbnZhciBydW5uaW5nID0gZmFsc2U7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJPYnMob2JzKSB7XG4gICAgaWYgKHNwaWVzLmxlbmd0aCkge1xuICAgICAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3BpZXMuZm9yRWFjaChmdW5jdGlvbiAoc3B5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNweShvYnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gQWRkcyB5b3VyIGZ1bmN0aW9uIGFzIGEgXCJzcHlcIiB0aGF0IHdpbGwgZ2V0IG5vdGlmaWVkIG9uIGFsbCBuZXcgT2JzZXJ2YWJsZXMuXG4gVGhpcyB3aWxsIGFsbG93IGEgdmlzdWFsaXphdGlvbi9hbmFseXRpY3MgdG9vbCB0byBzcHkgb24gYWxsIEJhY29uIGFjdGl2aXR5LlxuICovXG52YXIgc3B5ID0gZnVuY3Rpb24gKHNweSkgeyByZXR1cm4gc3BpZXMucHVzaChzcHkpOyB9O1xuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZmxhdE1hcExhdGVzdChzcmMsIGZfKSB7XG4gICAgdmFyIGYgPSBfLnRvRnVuY3Rpb24oZl8pO1xuICAgIHZhciBzdHJlYW0gPSBpc1Byb3BlcnR5KHNyYykgPyBzcmMudG9FdmVudFN0cmVhbShhbGxvd1N5bmMpIDogc3JjO1xuICAgIHZhciBmbGF0TWFwcGVkID0gZmxhdE1hcCQxKHN0cmVhbSwgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBtYWtlT2JzZXJ2YWJsZShmKHZhbHVlKSkudGFrZVVudGlsKHN0cmVhbSk7IH0pO1xuICAgIGlmIChpc1Byb3BlcnR5KHNyYykpXG4gICAgICAgIGZsYXRNYXBwZWQgPSBmbGF0TWFwcGVkLnRvUHJvcGVydHkoKTtcbiAgICByZXR1cm4gZmxhdE1hcHBlZC53aXRoRGVzYyhuZXcgRGVzYyhzcmMsIFwiZmxhdE1hcExhdGVzdFwiLCBbZl0pKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbnZhciBEaXNwYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3BhdGNoZXIob2JzZXJ2YWJsZSwgX3N1YnNjcmliZSwgX2hhbmRsZUV2ZW50KSB7XG4gICAgICAgIHRoaXMucHVzaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJldkVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnVuc3ViU3JjID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBfc3Vic2NyaWJlO1xuICAgICAgICB0aGlzLl9oYW5kbGVFdmVudCA9IF9oYW5kbGVFdmVudDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUgPSBfLmJpbmQodGhpcy5zdWJzY3JpYmUsIHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50ID0gXy5iaW5kKHRoaXMuaGFuZGxlRXZlbnQsIHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNTdWJzY3JpYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgRGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBfLndpdGhvdXQoc3Vic2NyaXB0aW9uLCB0aGlzLnN1YnNjcmlwdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zO1xuICAgIH07XG4gICAgRGlzcGF0Y2hlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNFbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVcGRhdGVCYXJyaWVyLmluVHJhbnNhY3Rpb24oZXZlbnQsIHRoaXMsIHRoaXMucHVzaEl0LCBbZXZlbnRdKTtcbiAgICB9O1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLnB1c2hUb1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gdG1wLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gdG1wW2ldO1xuICAgICAgICAgICAgICAgIHZhciByZXBseSA9IHN1Yi5zaW5rKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbHkgPT09IG5vTW9yZSB8fCBldmVudC5pc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVN1YihzdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5wdXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107IC8vIGRpdGNoIHF1ZXVlIGluIGNhc2Ugb2YgZXhjZXB0aW9uIHRvIGF2b2lkIHVuZXhwZWN0ZWQgYmVoYXZpb3JcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS5wdXNoSXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1c2hpbmcpIHtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gdGhpcy5wcmV2RXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQuaXNFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkVycm9yID0gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wdXNoVG9TdWJzY3JpcHRpb25zKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMucHVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTdWJzY3JpYmVycygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbVNvdXJjZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub01vcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2goZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS51bnN1YnNjcmliZUZyb21Tb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc3ViU3JjKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3ViU3JjKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnN1YlNyYyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICBzaW5rKGVuZEV2ZW50KCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5vcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydEZ1bmN0aW9uKHNpbmspO1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbl8xID0ge1xuICAgICAgICAgICAgICAgIHNpbms6IHNpbmtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb25fMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJTcmMgPSB0aGlzLl9zdWJzY3JpYmUodGhpcy5oYW5kbGVFdmVudCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0RnVuY3Rpb24odGhpcy51bnN1YlNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZVN1YihzdWJzY3JpcHRpb25fMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5oYXNTdWJzY3JpYmVycygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy51bnN1YnNjcmliZUZyb21Tb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlzcGF0Y2hlcjtcbn0oKSk7XG5cbi8qKiBAaGlkZGVuICovXG52YXIgUHJvcGVydHlEaXNwYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9wZXJ0eURpc3BhdGNoZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvcGVydHlEaXNwYXRjaGVyKHByb3BlcnR5LCBzdWJzY3JpYmUsIGhhbmRsZUV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BlcnR5LCBzdWJzY3JpYmUsIGhhbmRsZUV2ZW50KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jdXJyZW50ID0gbm9uZSgpO1xuICAgICAgICBfdGhpcy5wcm9wZXJ0eUVuZGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN1YnNjcmliZSA9IF8uYmluZChfdGhpcy5zdWJzY3JpYmUsIF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcm9wZXJ0eURpc3BhdGNoZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImRpc3BhdGNoXCIsIGV2ZW50LCBcImZyb21cIiwgIHRoaXMpXG4gICAgICAgIGlmIChldmVudC5pc0VuZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBWYWx1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInNldHRpbmcgY3VycmVudFwiKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IFNvbWUoZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmFsdWVSb290SWQgPSBVcGRhdGVCYXJyaWVyLmN1cnJlbnRFdmVudElkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIGV2ZW50LCB0d28gQmFjb25zIGxvYWRlZD9cIiwgZXZlbnQuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbiAgICBQcm9wZXJ0eURpc3BhdGNoZXIucHJvdG90eXBlLm1heWJlU3ViU291cmNlID0gZnVuY3Rpb24gKHNpbmssIHJlcGx5KSB7XG4gICAgICAgIGlmIChyZXBseSA9PT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcGVydHlFbmRlZCkge1xuICAgICAgICAgICAgc2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgICAgIHJldHVybiBub3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBzaW5rKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJvcGVydHlEaXNwYXRjaGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBpbml0IHZhbHVlIGlzIFwiYm91bmNlZFwiIGhlcmUgYmVjYXVzZSB0aGUgYmFzZSBEaXNwYXRjaGVyIGNsYXNzXG4gICAgICAgIC8vIHdvbid0IGFkZCBtb3JlIHRoYW4gb25lIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBvYnNlcnZhYmxlLlxuICAgICAgICAvLyB3aXRob3V0IGJvdW5jaW5nLCB0aGUgaW5pdCB2YWx1ZSB3b3VsZCBiZSBtaXNzaW5nIGZyb20gYWxsIG5ldyBzdWJzY3JpYmVyc1xuICAgICAgICAvLyBhZnRlciB0aGUgZmlyc3Qgb25lXG4gICAgICAgIHZhciByZXBseSA9IG1vcmU7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaXNEZWZpbmVkICYmICh0aGlzLmhhc1N1YnNjcmliZXJzKCkgfHwgdGhpcy5wcm9wZXJ0eUVuZGVkKSkge1xuICAgICAgICAgICAgLy8gc2hvdWxkIGJvdW5jZSBpbml0IHZhbHVlXG4gICAgICAgICAgICB2YXIgZGlzcGF0Y2hpbmdJZCA9IFVwZGF0ZUJhcnJpZXIuY3VycmVudEV2ZW50SWQoKTtcbiAgICAgICAgICAgIHZhciB2YWxJZCA9IHRoaXMuY3VycmVudFZhbHVlUm9vdElkO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BlcnR5RW5kZWQgJiYgdmFsSWQgJiYgZGlzcGF0Y2hpbmdJZCAmJiBkaXNwYXRjaGluZ0lkICE9PSB2YWxJZCkge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gc3Vic2NyaWJpbmcgd2hpbGUgYWxyZWFkeSBkaXNwYXRjaGluZyBhIHZhbHVlIGFuZCB0aGlzIHByb3BlcnR5IGhhc24ndCBiZWVuIHVwZGF0ZWQgeWV0XG4gICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IGJvdW5jZSBiZWZvcmUgdGhpcyBwcm9wZXJ0eSBpcyB1cCB0byBkYXRlLlxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJib3VuY2luZyB3aXRoIHBvc3NpYmx5IHN0YWxlIHZhbHVlXCIsIGV2ZW50LnZhbHVlLCBcInJvb3QgYXRcIiwgdmFsSWQsIFwidnNcIiwgZGlzcGF0Y2hpbmdJZClcbiAgICAgICAgICAgICAgICBVcGRhdGVCYXJyaWVyLndoZW5Eb25lV2l0aCh0aGlzLm9ic2VydmFibGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmN1cnJlbnRWYWx1ZVJvb3RJZCA9PT0gdmFsSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJib3VuY2luZ1wiLCB0aGlzLmN1cnJlbnQuZ2V0KCkudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2luayhpbml0aWFsRXZlbnQoX3RoaXMuY3VycmVudC5nZXQoKS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHN1YnNjcmliaW5nIHRoaW5nIHNob3VsZCBiZSBkZWZlcmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF5YmVTdWJTb3VyY2Uoc2luaywgcmVwbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImJvdW5jaW5nIGltbWRpYXRlbHlcIiwgdGhpcy5jdXJyZW50LmdldCgpLnZhbHVlKVxuICAgICAgICAgICAgICAgIFVwZGF0ZUJhcnJpZXIuaW5UcmFuc2FjdGlvbih1bmRlZmluZWQsIHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkgPSBzaW5rKGluaXRpYWxFdmVudChfdGhpcy5jdXJyZW50LmdldCgpLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBseTtcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF5YmVTdWJTb3VyY2Uoc2luaywgcmVwbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm5vcm1hbCBzdWJzY3JpYmVcIiwgdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heWJlU3ViU291cmNlKHNpbmssIHJlcGx5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJvcGVydHlEaXNwYXRjaGVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlICsgXCIgY3VycmVudD0gXCIgKyB0aGlzLmN1cnJlbnQ7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvcGVydHlEaXNwYXRjaGVyO1xufShEaXNwYXRjaGVyKSk7XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBmbGF0TWFwV2l0aENvbmN1cnJlbmN5TGltaXQoc3JjLCBsaW1pdCwgZikge1xuICAgIHJldHVybiBmbGF0TWFwXyhoYW5kbGVFdmVudFZhbHVlV2l0aChmKSwgc3JjLCB7XG4gICAgICAgIGRlc2M6IG5ldyBEZXNjKHNyYywgXCJmbGF0TWFwV2l0aENvbmN1cnJlbmN5TGltaXRcIiwgW2xpbWl0LCBmXSksXG4gICAgICAgIGxpbWl0OiBsaW1pdFxuICAgIH0pO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gYnVmZmVyV2l0aFRpbWUoc3JjLCBkZWxheSkge1xuICAgIHJldHVybiBidWZmZXJXaXRoVGltZU9yQ291bnQoc3JjLCBkZWxheSwgTnVtYmVyLk1BWF9WQUxVRSkud2l0aERlc2MobmV3IERlc2Moc3JjLCBcImJ1ZmZlcldpdGhUaW1lXCIsIFtkZWxheV0pKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBidWZmZXJXaXRoQ291bnQoc3JjLCBjb3VudCkge1xuICAgIHJldHVybiBidWZmZXJXaXRoVGltZU9yQ291bnQoc3JjLCB1bmRlZmluZWQsIGNvdW50KS53aXRoRGVzYyhuZXcgRGVzYyhzcmMsIFwiYnVmZmVyV2l0aENvdW50XCIsIFtjb3VudF0pKTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBidWZmZXJXaXRoVGltZU9yQ291bnQoc3JjLCBkZWxheSwgY291bnQpIHtcbiAgICB2YXIgZGVsYXlGdW5jID0gdG9EZWxheUZ1bmN0aW9uKGRlbGF5KTtcbiAgICBmdW5jdGlvbiBmbHVzaE9yU2NoZWR1bGUoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIudmFsdWVzLmxlbmd0aCA9PT0gY291bnQpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cgQmFjb24uc2NoZWR1bGVyLm5vdygpICsgXCI6IGNvdW50LWZsdXNoXCJcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZWxheUZ1bmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zY2hlZHVsZShkZWxheUZ1bmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBkZXNjID0gbmV3IERlc2Moc3JjLCBcImJ1ZmZlcldpdGhUaW1lT3JDb3VudFwiLCBbZGVsYXksIGNvdW50XSk7XG4gICAgcmV0dXJuIGJ1ZmZlcihzcmMsIGZsdXNoT3JTY2hlZHVsZSwgZmx1c2hPclNjaGVkdWxlKS53aXRoRGVzYyhkZXNjKTtcbn1cbnZhciBCdWZmZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnVmZmVyKG9uRmx1c2gsIG9uSW5wdXQpIHtcbiAgICAgICAgdGhpcy5wdXNoID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG1vcmU7IH07XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIHRoaXMub25GbHVzaCA9IG9uRmx1c2g7XG4gICAgICAgIHRoaXMub25JbnB1dCA9IG9uSW5wdXQ7XG4gICAgfVxuICAgIEJ1ZmZlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjaGVkdWxlZCkge1xuICAgICAgICAgICAgR2xvYmFsU2NoZWR1bGVyLnNjaGVkdWxlci5jbGVhclRpbWVvdXQodGhpcy5zY2hlZHVsZWQpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nIEJhY29uLnNjaGVkdWxlci5ub3coKSArIFwiOiBmbHVzaCBcIiArIEB2YWx1ZXNcbiAgICAgICAgICAgIHZhciB2YWx1ZXNUb1B1c2ggPSB0aGlzLnZhbHVlcztcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgICAgICB2YXIgcmVwbHkgPSB0aGlzLnB1c2gobmV4dEV2ZW50KHZhbHVlc1RvUHVzaCkpO1xuICAgICAgICAgICAgaWYgKCh0aGlzLmVuZCAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2godGhpcy5lbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVwbHkgIT09IG5vTW9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRmx1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuZW5kICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh0aGlzLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJ1ZmZlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNjaGVkdWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVkID0gZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cgQmFjb24uc2NoZWR1bGVyLm5vdygpICsgXCI6IHNjaGVkdWxlZCBmbHVzaFwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEJ1ZmZlcjtcbn0oKSk7XG5mdW5jdGlvbiB0b0RlbGF5RnVuY3Rpb24oZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHZhciBkZWxheU1zID0gZGVsYXk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyBCYWNvbi5zY2hlZHVsZXIubm93KCkgKyBcIjogc2NoZWR1bGUgZm9yIFwiICsgKEJhY29uLnNjaGVkdWxlci5ub3coKSArIGRlbGF5TXMpXG4gICAgICAgICAgICByZXR1cm4gR2xvYmFsU2NoZWR1bGVyLnNjaGVkdWxlci5zZXRUaW1lb3V0KGYsIGRlbGF5TXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gYnVmZmVyKHNyYywgb25JbnB1dCwgb25GbHVzaCkge1xuICAgIGlmIChvbklucHV0ID09PSB2b2lkIDApIHsgb25JbnB1dCA9IG5vcDsgfVxuICAgIGlmIChvbkZsdXNoID09PSB2b2lkIDApIHsgb25GbHVzaCA9IG5vcDsgfVxuICAgIHZhciByZXBseSA9IG1vcmU7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIob25GbHVzaCwgb25JbnB1dCk7XG4gICAgcmV0dXJuIHNyYy50cmFuc2Zvcm0oZnVuY3Rpb24gKGV2ZW50LCBzaW5rKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoID0gc2luaztcbiAgICAgICAgaWYgKGhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgICAgICAgYnVmZmVyLnZhbHVlcy5wdXNoKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cgQmFjb24uc2NoZWR1bGVyLm5vdygpICsgXCI6IGlucHV0IFwiICsgZXZlbnQudmFsdWVcbiAgICAgICAgICAgIG9uSW5wdXQoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Vycm9yKGV2ZW50KSkge1xuICAgICAgICAgICAgcmVwbHkgPSBzaW5rKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VuZChldmVudCkpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5lbmQgPSBldmVudDtcbiAgICAgICAgICAgIGlmICghYnVmZmVyLnNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cgQmFjb24uc2NoZWR1bGVyLm5vdygpICsgXCI6IGVuZC1mbHVzaFwiXG4gICAgICAgICAgICAgICAgYnVmZmVyLmZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGx5O1xuICAgIH0pLndpdGhEZXNjKG5ldyBEZXNjKHNyYywgXCJidWZmZXJcIiwgW10pKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGFzeW5jV3JhcFN1YnNjcmliZShvYnMsIHN1YnNjcmliZSkge1xuICAgIC8vYXNzZXJ0RnVuY3Rpb24oc3Vic2NyaWJlKVxuICAgIHZhciBzdWJzY3JpYmluZyA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiB3cmFwcGVkU3Vic2NyaWJlKHNpbmspIHtcbiAgICAgICAgLy9hc3NlcnRGdW5jdGlvbihzaW5rKVxuICAgICAgICB2YXIgaW5UcmFuc2FjdGlvbiA9IFVwZGF0ZUJhcnJpZXIuaXNJblRyYW5zYWN0aW9uKCk7XG4gICAgICAgIHN1YnNjcmliaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGFzeW5jRGVsaXZlcmllcztcbiAgICAgICAgZnVuY3Rpb24gZGVsaXZlckFzeW5jKCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImRlbGl2ZXJpbmcgYXN5bmNcIiwgb2JzLCBhc3luY0RlbGl2ZXJpZXMpXG4gICAgICAgICAgICB2YXIgdG9EZWxpdmVyTm93ID0gYXN5bmNEZWxpdmVyaWVzIHx8IFtdO1xuICAgICAgICAgICAgYXN5bmNEZWxpdmVyaWVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0RlbGl2ZXJOb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSB0b0RlbGl2ZXJOb3dbaV07XG4gICAgICAgICAgICAgICAgc2luayhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gd3JhcHBlZFNpbmsoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJpbmcgfHwgYXN5bmNEZWxpdmVyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGl2ZXIgYXN5bmMgaWYgY3VycmVudGx5IHN1YnNjcmliaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28gcXVldWUgZnVydGhlciBldmVudHMgdW50aWwgYXN5bmMgZGVsaXZlcnkgaGFzIGJlZW4gY29tcGxldGVkXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdHJlYW0gcmVzcG9uZGVkIHN5bmNocm9ub3VzbHlcIiwgb2JzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFzeW5jRGVsaXZlcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNEZWxpdmVyaWVzID0gW2V2ZW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRlQmFycmllci5zb29uQnV0Tm90WWV0KG9icywgZGVsaXZlckFzeW5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdsb2JhbFNjaGVkdWxlci5zY2hlZHVsZXIuc2V0VGltZW91dChkZWxpdmVyQXN5bmMsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmNEZWxpdmVyaWVzLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuIE1lcmdlcyBnaXZlbiBhcnJheSBvZiBFdmVudFN0cmVhbXMgb3IgUHJvcGVydGllcywgYnkgY29sbGVjdGluZyB0aGUgdmFsdWVzIGZyb20gYWxsIG9mIHRoZSBzb3VyY2VzIGludG8gYSBzaW5nbGVcbiBFdmVudFN0cmVhbS5cblxuIFNlZSBhbHNvIFtgbWVyZ2VgXShjbGFzc2VzL2V2ZW50c3RyZWFtLmh0bWwjbWVyZ2UpLlxuICovXG5mdW5jdGlvbiBtZXJnZUFsbCgpIHtcbiAgICB2YXIgc3RyZWFtcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHN0cmVhbXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGZsYXR0ZW5lZFN0cmVhbXMgPSBhcmd1bWVudHNUb09ic2VydmFibGVzKHN0cmVhbXMpO1xuICAgIGlmIChmbGF0dGVuZWRTdHJlYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50U3RyZWFtKG5ldyBEZXNjKFwiQmFjb25cIiwgXCJtZXJnZUFsbFwiLCBmbGF0dGVuZWRTdHJlYW1zKSwgZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgICAgIHZhciBlbmRzID0gMDtcbiAgICAgICAgICAgIHZhciBzbWFydFNpbmsgPSBmdW5jdGlvbiAob2JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh1bnN1YkJvdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmVJbnRlcm5hbChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5pc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kcyA9PT0gZmxhdHRlbmVkU3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCA9IGV2ZW50LnRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBseSA9IHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBseSA9PT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3ViQm90aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNpbmtzID0gbWFwKHNtYXJ0U2luaywgZmxhdHRlbmVkU3RyZWFtcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZVVuc3Vic2NyaWJlKHNpbmtzKS51bnN1YnNjcmliZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV2ZXIoKTtcbiAgICB9XG59XG5cbi8qKlxuXG4gQ3JlYXRlcyBhIHNpbmdsZS1lbGVtZW50IHN0cmVhbSB0aGF0IGVtaXRzIGdpdmVuIHZhbHVlIGFmdGVyIGdpdmVuIGRlbGF5IGFuZCBlbmRzLlxuXG4gQHBhcmFtIGRlbGF5IGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBiZSBlbWl0dGVkXG4gQHR5cGVwYXJhbSBWIFR5cGUgb2Ygc3RyZWFtIGVsZW1lbnRzXG5cbiAqL1xuZnVuY3Rpb24gbGF0ZXIoZGVsYXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZyb21CaW5kZXIoZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgdmFyIHNlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5rKFt0b0V2ZW50KHZhbHVlKSwgZW5kRXZlbnQoKV0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaWQgPSBHbG9iYWxTY2hlZHVsZXIuc2NoZWR1bGVyLnNldFRpbWVvdXQoc2VuZGVyLCBkZWxheSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gR2xvYmFsU2NoZWR1bGVyLnNjaGVkdWxlci5jbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICB9O1xuICAgIH0pLndpdGhEZXNjKG5ldyBEZXNjKFwiQmFjb25cIiwgXCJsYXRlclwiLCBbZGVsYXksIHZhbHVlXSkpO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZGVsYXkoc3JjLCBkZWxheSkge1xuICAgIHJldHVybiBzcmMudHJhbnNmb3JtQ2hhbmdlcyhuZXcgRGVzYyhzcmMsIFwiZGVsYXlcIiwgW2RlbGF5XSksIGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmZsYXRNYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF0ZXIoZGVsYXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBkZWJvdW5jZShzcmMsIGRlbGF5KSB7XG4gICAgcmV0dXJuIHNyYy50cmFuc2Zvcm1DaGFuZ2VzKG5ldyBEZXNjKHNyYywgXCJkZWJvdW5jZVwiLCBbZGVsYXldKSwgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZmxhdE1hcExhdGVzdChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXRlcihkZWxheSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBkZWJvdW5jZUltbWVkaWF0ZShzcmMsIGRlbGF5KSB7XG4gICAgcmV0dXJuIHNyYy50cmFuc2Zvcm1DaGFuZ2VzKG5ldyBEZXNjKHNyYywgXCJkZWJvdW5jZUltbWVkaWF0ZVwiLCBbZGVsYXldKSwgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuZmxhdE1hcEZpcnN0KGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9uY2UodmFsdWUpLmNvbmNhdChsYXRlcihkZWxheSwgdmFsdWUpLmVycm9ycygpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0aHJvdHRsZShzcmMsIGRlbGF5KSB7XG4gICAgcmV0dXJuIHNyYy50cmFuc2Zvcm1DaGFuZ2VzKG5ldyBEZXNjKHNyYywgXCJ0aHJvdHRsZVwiLCBbZGVsYXldKSwgZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZXMuYnVmZmVyV2l0aFRpbWUoZGVsYXkpLm1hcChmdW5jdGlvbiAodmFsdWVzKSB7IHJldHVybiB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdOyB9KTtcbiAgICB9KTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGJ1ZmZlcmluZ1Rocm90dGxlKHNyYywgbWluaW11bUludGVydmFsKSB7XG4gICAgdmFyIGRlc2MgPSBuZXcgRGVzYyhzcmMsIFwiYnVmZmVyaW5nVGhyb3R0bGVcIiwgW21pbmltdW1JbnRlcnZhbF0pO1xuICAgIHJldHVybiBzcmMudHJhbnNmb3JtQ2hhbmdlcyhkZXNjLCBmdW5jdGlvbiAoY2hhbmdlcykgeyByZXR1cm4gY2hhbmdlcy5mbGF0TWFwQ29uY2F0KGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBvbmNlKHgpLmNvbmNhdChsYXRlcihtaW5pbXVtSW50ZXJ2YWwsIHgpLmVycm9ycygpKTtcbiAgICB9KTsgfSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0YWtlV2hpbGUoc3JjLCBmKSB7XG4gICAgcmV0dXJuIHdpdGhQcmVkaWNhdGUoc3JjLCBmLCB0YWtlV2hpbGVULCBuZXcgRGVzYyhzcmMsIFwidGFrZVdoaWxlXCIsIFtmXSkpO1xufVxuZnVuY3Rpb24gdGFrZVdoaWxlVChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgc2luaykge1xuICAgICAgICBpZiAoZXZlbnQuZmlsdGVyKGYpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luayhldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaW5rKGVuZEV2ZW50KCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5vTW9yZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBza2lwVW50aWwoc3JjLCBzdGFydGVyKSB7XG4gICAgdmFyIHN0YXJ0ZWQgPSBzdGFydGVyXG4gICAgICAgIC50cmFuc2Zvcm0oY29tcG9zZVQodGFrZVQoMSksIG1hcFQodHJ1ZSkpKVxuICAgICAgICAudG9Qcm9wZXJ0eSgpXG4gICAgICAgIC5zdGFydFdpdGgoZmFsc2UpO1xuICAgIHJldHVybiBzcmMuZmlsdGVyKHN0YXJ0ZWQpLndpdGhEZXNjKG5ldyBEZXNjKHNyYywgXCJza2lwVW50aWxcIiwgW3N0YXJ0ZXJdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBza2lwV2hpbGUoc3JjLCBmKSB7XG4gICAgcmV0dXJuIHdpdGhQcmVkaWNhdGUoc3JjLCBmLCBza2lwV2hpbGVULCBuZXcgRGVzYyhzcmMsIFwic2tpcFdoaWxlXCIsIFtmXSkpO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHNraXBXaGlsZVQoZikge1xuICAgIHZhciBzdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgc2luaykge1xuICAgICAgICBpZiAoc3RhcnRlZCB8fCAhaGFzVmFsdWUoZXZlbnQpIHx8ICFmKGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2luayhldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9yZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBncm91cEJ5KHNyYywga2V5RiwgbGltaXRGKSB7XG4gICAgaWYgKGxpbWl0RiA9PT0gdm9pZCAwKSB7IGxpbWl0RiA9IF8uaWQ7IH1cbiAgICB2YXIgc3RyZWFtcyA9IHt9O1xuICAgIHJldHVybiBzcmMudHJhbnNmb3JtKGNvbXBvc2VUKGZpbHRlclQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICFzdHJlYW1zW2tleUYoeCldOyB9KSwgbWFwVChmdW5jdGlvbiAoZmlyc3RWYWx1ZSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5RihmaXJzdFZhbHVlKTtcbiAgICAgICAgdmFyIHNpbWlsYXJWYWx1ZXMgPSBzcmMuY2hhbmdlcygpLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4ga2V5Rih4KSA9PT0ga2V5OyB9KTtcbiAgICAgICAgdmFyIGRhdGEgPSBvbmNlKGZpcnN0VmFsdWUpLmNvbmNhdChzaW1pbGFyVmFsdWVzKTtcbiAgICAgICAgdmFyIGxpbWl0ZWQgPSBsaW1pdEYoZGF0YSwgZmlyc3RWYWx1ZSkudG9FdmVudFN0cmVhbSgpLnRyYW5zZm9ybShmdW5jdGlvbiAoZXZlbnQsIHNpbmspIHtcbiAgICAgICAgICAgIHZhciByZXBseSA9IHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmlzRW5kKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0cmVhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBseTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbXNba2V5XSA9IGxpbWl0ZWQ7XG4gICAgICAgIHJldHVybiBsaW1pdGVkO1xuICAgIH0pKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBzbGlkaW5nV2luZG93KHNyYywgbWF4VmFsdWVzLCBtaW5WYWx1ZXMpIHtcbiAgICBpZiAobWluVmFsdWVzID09PSB2b2lkIDApIHsgbWluVmFsdWVzID0gMDsgfVxuICAgIHJldHVybiBzcmMuc2NhbihbXSwgKGZ1bmN0aW9uICh3aW5kb3csIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuY29uY2F0KFt2YWx1ZV0pLnNsaWNlKC1tYXhWYWx1ZXMpO1xuICAgIH0pKVxuICAgICAgICAuZmlsdGVyKChmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID49IG1pblZhbHVlcztcbiAgICB9KSkud2l0aERlc2MobmV3IERlc2Moc3JjLCBcInNsaWRpbmdXaW5kb3dcIiwgW21heFZhbHVlcywgbWluVmFsdWVzXSkpO1xufVxuXG52YXIgbnVsbE1hcmtlciA9IHt9O1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGRpZmYoc3JjLCBzdGFydCwgZikge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QKHNjYW4oc3JjLCBbc3RhcnQsIG51bGxNYXJrZXJdLCAoZnVuY3Rpb24gKHByZXZUdXBsZSwgbmV4dCkgeyByZXR1cm4gW25leHQsIGYocHJldlR1cGxlWzBdLCBuZXh0KV07IH0pKSwgY29tcG9zZVQoZmlsdGVyVChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlWzFdICE9PSBudWxsTWFya2VyOyB9KSwgbWFwVChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlWzFdOyB9KSksIG5ldyBEZXNjKHNyYywgXCJkaWZmXCIsIFtzdGFydCwgZl0pKTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGZsYXRTY2FuKHNyYywgc2VlZCwgZikge1xuICAgIHZhciBjdXJyZW50ID0gc2VlZDtcbiAgICByZXR1cm4gc3JjLmZsYXRNYXBDb25jYXQoZnVuY3Rpb24gKG5leHQpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VPYnNlcnZhYmxlKGYoY3VycmVudCwgbmV4dCkpLmRvQWN0aW9uKGZ1bmN0aW9uICh1cGRhdGVkKSB7IHJldHVybiBjdXJyZW50ID0gdXBkYXRlZDsgfSk7XG4gICAgfSkudG9Qcm9wZXJ0eSgpLnN0YXJ0V2l0aChzZWVkKS53aXRoRGVzYyhuZXcgRGVzYyhzcmMsIFwiZmxhdFNjYW5cIiwgW3NlZWQsIGZdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBob2xkV2hlbihzcmMsIHZhbHZlKSB7XG4gICAgdmFyIG9uSG9sZCA9IGZhbHNlO1xuICAgIHZhciBidWZmZXJlZFZhbHVlcyA9IFtdO1xuICAgIHZhciBzcmNJc0VuZGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBFdmVudFN0cmVhbShuZXcgRGVzYyhzcmMsIFwiaG9sZFdoZW5cIiwgW3ZhbHZlXSksIGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIHZhciBjb21wb3NpdGUgPSBuZXcgQ29tcG9zaXRlVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdmFyIHN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVuZElmQm90aEVuZGVkID0gZnVuY3Rpb24gKHVuc3ViKSB7XG4gICAgICAgICAgICBpZiAodW5zdWIpIHtcbiAgICAgICAgICAgICAgICB1bnN1YigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBvc2l0ZS5lbXB0eSgpICYmIHN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICB9O1xuICAgICAgICBjb21wb3NpdGUuYWRkKGZ1bmN0aW9uICh1bnN1YkFsbCwgdW5zdWJNZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHZlLnN1YnNjcmliZUludGVybmFsKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZShldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Ib2xkID0gZXZlbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBtb3JlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9uSG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvU2VuZCA9IGJ1ZmZlcmVkVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9TZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2luayhuZXh0RXZlbnQodG9TZW5kW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3JjSXNFbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zdWJNZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vTW9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5pc0VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kSWZCb3RoRW5kZWQodW5zdWJNZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2luayhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb21wb3NpdGUuYWRkKGZ1bmN0aW9uICh1bnN1YkFsbCwgdW5zdWJNZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zdWJzY3JpYmVJbnRlcm5hbChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Ib2xkICYmIGhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJlZFZhbHVlcy5wdXNoKGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmlzRW5kICYmIGJ1ZmZlcmVkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzcmNJc0VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuZElmQm90aEVuZGVkKHVuc3ViTWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIGVuZElmQm90aEVuZGVkKCk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGUudW5zdWJzY3JpYmU7XG4gICAgfSk7XG59XG5cbi8qKlxuIFppcHMgdGhlIGFycmF5IG9mIEV2ZW50U3RyZWFtcyAvIFByb3BlcnRpZXMgaW4gdG8gYSBuZXdcbiBFdmVudFN0cmVhbSB0aGF0IHdpbGwgaGF2ZSBhbiBhcnJheSBvZiB2YWx1ZXMgZnJvbSBlYWNoIHNvdXJjZSBhc1xuIGl0cyB2YWx1ZS4gWmlwcGluZyBtZWFucyB0aGF0IGV2ZW50cyBmcm9tIGVhY2ggc291cmNlIGFyZSBjb21iaW5lZFxuIHBhaXJ3aXNlIHNvIHRoYXQgdGhlIDFzdCBldmVudCBmcm9tIGVhY2ggc291cmNlIGlzIHB1Ymxpc2hlZCBmaXJzdCwgdGhlblxuIHRoZSAybmQgZXZlbnQgZnJvbSBlYWNoLiBUaGUgcmVzdWx0cyB3aWxsIGJlIHB1Ymxpc2hlZCBhcyBzb29uIGFzIHRoZXJlXG4gaXMgYSB2YWx1ZSBmcm9tIGVhY2ggc291cmNlLlxuXG4gQmUgY2FyZWZ1bCBub3QgdG8gaGF2ZSB0b28gbXVjaCBcImRyaWZ0XCIgYmV0d2VlbiBzdHJlYW1zLiBJZiBvbmUgc3RyZWFtXG4gcHJvZHVjZXMgbWFueSBtb3JlIHZhbHVlcyB0aGFuIHNvbWUgb3RoZXIgZXhjZXNzaXZlIGJ1ZmZlcmluZyB3aWxsXG4gb2NjdXIgaW5zaWRlIHRoZSB6aXBwZWQgb2JzZXJ2YWJsZS5cblxuIEV4YW1wbGU6XG5cbiBgYGBqc1xuIHggPSBCYWNvbi5mcm9tQXJyYXkoWzEsMiwzXSlcbiB5ID0gQmFjb24uZnJvbUFycmF5KFsxMCwgMjAsIDMwXSlcbiB6ID0gQmFjb24uZnJvbUFycmF5KFsxMDAsIDIwMCwgMzAwXSlcbiBCYWNvbi56aXBBc0FycmF5KHgsIHksIHopXG5cbiAjIHByb2R1Y2VzIHZhbHVlcyBbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXSBhbmQgWzMsIDMwLCAzMDBdXG4gYGBgXG5cbiAqL1xuZnVuY3Rpb24gemlwQXNBcnJheSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHN0cmVhbXMgPSBfLm1hcCgoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9FdmVudFN0cmVhbSgpOyB9KSwgYXJndW1lbnRzVG9PYnNlcnZhYmxlcyhhcmdzKSk7XG4gICAgcmV0dXJuIHdoZW4oW3N0cmVhbXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB4cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB4c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHhzO1xuICAgICAgICB9XSkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcInppcEFzQXJyYXlcIiwgYXJncykpO1xufVxuLyoqXG4gTGlrZSBbYHppcEFzQXJyYXlgXSgjYmFjb24temlwYXNhcnJheSkgYnV0IHVzZXMgdGhlIGdpdmVuIG4tYXJ5XG4gZnVuY3Rpb24gdG8gY29tYmluZSB0aGUgbiB2YWx1ZXMgZnJvbSBuIHNvdXJjZXMsIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gYW4gQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHppcFdpdGgoZikge1xuICAgIHZhciBzdHJlYW1zID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgc3RyZWFtc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIF9hID0gYXJndW1lbnRzVG9PYnNlcnZhYmxlc0FuZEZ1bmN0aW9uKGFyZ3VtZW50cyksIHN0cmVhbXMgPSBfYVswXSwgZiA9IF9hWzFdO1xuICAgIHN0cmVhbXMgPSBfLm1hcCgoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMudG9FdmVudFN0cmVhbSgpOyB9KSwgc3RyZWFtcyk7XG4gICAgcmV0dXJuIHdoZW4oW3N0cmVhbXMsIGZdKS53aXRoRGVzYyhuZXcgRGVzYyhcIkJhY29uXCIsIFwiemlwV2l0aFwiLCBbZl0uY29uY2F0KHN0cmVhbXMpKSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gemlwKGxlZnQsIHJpZ2h0LCBmKSB7XG4gICAgcmV0dXJuIHppcFdpdGgoZiB8fCBBcnJheSwgbGVmdCwgcmlnaHQpLndpdGhEZXNjKG5ldyBEZXNjKGxlZnQsIFwiemlwXCIsIFtyaWdodF0pKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgZnVuY3Rpb24gY3VycmVudChjdHhTdGFjaykgeyByZXR1cm4gY3R4U3RhY2tbY3R4U3RhY2subGVuZ3RoIC0gMV07IH1cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZShjdHhTdGFjaywga2V5LCB2YWx1ZSkge1xuICAgICAgICBjdXJyZW50KGN0eFN0YWNrKVtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlTdHJlYW1WYWx1ZShrZXksIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3R4U3RhY2ssIHZhbHVlcykge1xuICAgICAgICAgICAgc2V0VmFsdWUoY3R4U3RhY2ssIGtleSwgdmFsdWVzW2luZGV4XSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnN0YW50VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGN0eFN0YWNrKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZShjdHhTdGFjaywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1rQ29udGV4dCh0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0ZW1wbGF0ZSkgPyBbXSA6IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQ29udGV4dChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY3R4U3RhY2spIHtcbiAgICAgICAgICAgIHZhciBuZXdDb250ZXh0ID0gbWtDb250ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIHNldFZhbHVlKGN0eFN0YWNrLCBrZXksIG5ld0NvbnRleHQpO1xuICAgICAgICAgICAgY3R4U3RhY2sucHVzaChuZXdDb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNPYnNlcnZhYmxlcyh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgJiYgKHZhbHVlLmNvbnN0cnVjdG9yID09IE9iamVjdCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PSBBcnJheSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zT2JzZXJ2YWJsZXMoY2hpbGQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgc3RyZWFtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGZ1bmNzLnB1c2goYXBwbHlTdHJlYW1WYWx1ZShrZXksIHN0cmVhbXMubGVuZ3RoIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zT2JzZXJ2YWJsZXModmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgcG9wQ29udGV4dCA9IGZ1bmN0aW9uIChjdHhTdGFjaykgeyBjdHhTdGFjay5wb3AoKTsgfTtcbiAgICAgICAgICAgIGZ1bmNzLnB1c2gocHVzaENvbnRleHQoa2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgY29tcGlsZVRlbXBsYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGZ1bmNzLnB1c2gocG9wQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdW5jcy5wdXNoKGNvbnN0YW50VmFsdWUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbWJpbmF0b3IodmFsdWVzKSB7XG4gICAgICAgIHZhciByb290Q29udGV4dCA9IG1rQ29udGV4dCh0ZW1wbGF0ZSk7XG4gICAgICAgIHZhciBjdHhTdGFjayA9IFtyb290Q29udGV4dF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBmOyBpIDwgZnVuY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGYgPSBmdW5jc1tpXTtcbiAgICAgICAgICAgIGYoY3R4U3RhY2ssIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RDb250ZXh0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlVGVtcGxhdGUodGVtcGxhdGUpIHsgXy5lYWNoKHRlbXBsYXRlLCBjb21waWxlKTsgfVxuICAgIHZhciBmdW5jcyA9IFtdO1xuICAgIHZhciBzdHJlYW1zID0gW107XG4gICAgdmFyIHJlc3VsdFByb3BlcnR5ID0gY29udGFpbnNPYnNlcnZhYmxlcyh0ZW1wbGF0ZSlcbiAgICAgICAgPyAoY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlKSwgY29tYmluZUFzQXJyYXkoc3RyZWFtcykubWFwKGNvbWJpbmF0b3IpKVxuICAgICAgICA6IGNvbnN0YW50KHRlbXBsYXRlKTtcbiAgICByZXR1cm4gcmVzdWx0UHJvcGVydHkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcImNvbWJpbmVUZW1wbGF0ZVwiLCBbdGVtcGxhdGVdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBkZWNvZGUoc3JjLCBjYXNlcykge1xuICAgIHJldHVybiBzcmMuY29tYmluZShjb21iaW5lVGVtcGxhdGUoY2FzZXMpLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZXMpIHsgcmV0dXJuIHZhbHVlc1trZXldOyB9KVxuICAgICAgICAud2l0aERlc2MobmV3IERlc2Moc3JjLCBcImRlY29kZVwiLCBbY2FzZXNdKSk7XG59XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBmaXJzdFRvUHJvbWlzZShzcmMsIFByb21pc2VDdHIpIHtcbiAgICAvLyBDYW4ndCBkbyBpbiB0aGUgZ2xvYmFsIHNjb3BlLCBhcyBzaGltIGNhbiBiZSBhcHBsaWVkIGFmdGVyIEJhY29uIGlzIGxvYWRlZC5cbiAgICBpZiAodHlwZW9mIFByb21pc2VDdHIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgUHJvbWlzZUN0ciA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBuZXcgUHJvbWlzZShmKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzbid0IGRlZmF1bHQgUHJvbWlzZSwgdXNlIHNoaW0gb3IgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZUN0cihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJldHVybiBzcmMuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGhhc1ZhbHVlKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9uZSBldmVudCBpcyBlbm91Z2hcbiAgICAgICAgICAgIHJldHVybiBub01vcmU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHRvUHJvbWlzZShzcmMsIFByb21pc2VDdHIpIHtcbiAgICByZXR1cm4gc3JjLmxhc3QoKS5maXJzdFRvUHJvbWlzZShQcm9taXNlQ3RyKTtcbn1cblxudmFyIGlkQ291bnRlciA9IDA7XG4vKipcbiBPYnNlcnZhYmxlIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBbRXZlbnRzU3RyZWFtXShldmVudHN0cmVhbS5odG1sKSBhbmQgW1Byb3BlcnR5XShwcm9wZXJ0eS5odG1sKVxuXG4gQHR5cGVwYXJhbSBWICAgVHlwZSBvZiB0aGUgZWxlbWVudHMvdmFsdWVzIGluIHRoZSBzdHJlYW0vcHJvcGVydHlcbiAqL1xudmFyIE9ic2VydmFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZShkZXNjKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlxdWUgbnVtZXJpYyBpZCBvZiB0aGlzIE9ic2VydmFibGUuIEltcGxlbWVudGVkIHVzaW5nIGEgc2ltcGxlIGNvdW50ZXIgc3RhcnRpbmcgZnJvbSAxLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9ICsraWRDb3VudGVyO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9pc09ic2VydmFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc2MgPSBkZXNjO1xuICAgICAgICB0aGlzLmluaXRpYWxEZXNjID0gZGVzYztcbiAgICB9XG4gICAgLyoqXG4gIENyZWF0ZXMgYSBQcm9wZXJ0eSB0aGF0IGluZGljYXRlcyB3aGV0aGVyXG4gIGBvYnNlcnZhYmxlYCBpcyBhd2FpdGluZyBgb3RoZXJPYnNlcnZhYmxlYCwgaS5lLiBoYXMgcHJvZHVjZWQgYSB2YWx1ZSBhZnRlciB0aGUgbGF0ZXN0XG4gIHZhbHVlIGZyb20gYG90aGVyT2JzZXJ2YWJsZWAuIFRoaXMgaXMgaGFuZHkgZm9yIGtlZXBpbmcgdHJhY2sgd2hldGhlciB3ZSBhcmVcbiAgY3VycmVudGx5IGF3YWl0aW5nIGFuIEFKQVggcmVzcG9uc2U6XG4gIFxuICBgYGBqc1xuICB2YXIgc2hvd0FqYXhJbmRpY2F0b3IgPSBhamF4UmVxdWVzdC5hd2FpdGluZyhhamF4UmVzcG9uc2UpXG4gIGBgYFxuICBcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5hd2FpdGluZyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gYXdhaXRpbmcodGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgLyoqXG4gIFRocm90dGxlcyB0aGUgb2JzZXJ2YWJsZSB1c2luZyBhIGJ1ZmZlciBzbyB0aGF0IGF0IG1vc3Qgb25lIHZhbHVlIGV2ZW50IGluIG1pbmltdW1JbnRlcnZhbCBpcyBpc3N1ZWQuXG4gIFVubGlrZSBbYHRocm90dGxlYF0oI29ic2VydmFibGUtdGhyb3R0bGUpLCBpdCBkb2Vzbid0IGRpc2NhcmQgdGhlIGV4Y2Vzc2l2ZSBldmVudHMgYnV0IGJ1ZmZlcnMgdGhlbSBpbnN0ZWFkLCBvdXRwdXR0aW5nXG4gIHRoZW0gd2l0aCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgdmFsdWUgcGVyIG1pbmltdW1JbnRlcnZhbC5cbiAgXG4gIEV4YW1wbGU6XG4gIFxuICBgYGBqc1xuICB2YXIgdGhyb3R0bGVkID0gc291cmNlLmJ1ZmZlcmluZ1Rocm90dGxlKDIpXG4gIGBgYFxuICBcbiAgYGBgXG4gIHNvdXJjZTogICAgYXNkZi0tLS1hc2RmLS0tLVxuICB0aHJvdHRsZWQ6IGEtcy1kLWYtYS1zLWQtZi1cbiAgYGBgXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyaW5nVGhyb3R0bGUgPSBmdW5jdGlvbiAobWluaW11bUludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJpbmdUaHJvdHRsZSh0aGlzLCBtaW5pbXVtSW50ZXJ2YWwpO1xuICAgIH07XG4gICAgLyoqXG4gIENvbWJpbmVzIHRoZSBsYXRlc3QgdmFsdWVzIG9mIHRoZSB0d29cbiAgc3RyZWFtcyBvciBwcm9wZXJ0aWVzIHVzaW5nIGEgdHdvLWFyZyBmdW5jdGlvbi4gU2ltaWxhcmx5IHRvIFtgc2NhbmBdKCNzY2FuKSwgeW91IGNhbiB1c2UgYVxuICBtZXRob2QgbmFtZSBpbnN0ZWFkLCBzbyB5b3UgY291bGQgZG8gYGEuY29tYmluZShiLCBcIi5jb25jYXRcIilgIGZvciB0d29cbiAgcHJvcGVydGllcyB3aXRoIGFycmF5IHZhbHVlLiBUaGUgcmVzdWx0IGlzIGEgW1Byb3BlcnR5XShwcm9wZXJ0eS5odG1sKS5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gKHJpZ2h0LCBmKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lKHRoaXMsIHJpZ2h0LCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICBUaHJvdHRsZXMgc3RyZWFtL3Byb3BlcnR5IGJ5IGdpdmVuIGFtb3VudFxuICBvZiBtaWxsaXNlY29uZHMsIGJ1dCBzbyB0aGF0IGV2ZW50IGlzIG9ubHkgZW1pdHRlZCBhZnRlciB0aGUgZ2l2ZW5cbiAgXCJxdWlldCBwZXJpb2RcIi4gRG9lcyBub3QgYWZmZWN0IGVtaXR0aW5nIHRoZSBpbml0aWFsIHZhbHVlIG9mIGEgW1Byb3BlcnR5XShwcm9wZXJ0eS5odG1sKS5cbiAgVGhlIGRpZmZlcmVuY2Ugb2YgW2B0aHJvdHRsZWBdKCN0aHJvdHRsZSkgYW5kIFtgZGVib3VuY2VgXSgjZGVib3VuY2UpIGlzIHRoZSBzYW1lIGFzIGl0IGlzIGluIHRoZVxuICBzYW1lIG1ldGhvZHMgaW4galF1ZXJ5LlxuICBcbiAgRXhhbXBsZTpcbiAgXG4gIGBgYFxuICBzb3VyY2U6ICAgICAgICAgICAgIGFzZGYtLS0tYXNkZi0tLS1cbiAgc291cmNlLmRlYm91bmNlKDIpOiAtLS0tLWYtLS0tLS0tZi0tXG4gIGBgYFxuICBcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5kZWJvdW5jZSA9IGZ1bmN0aW9uIChtaW5pbXVtSW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlKHRoaXMsIG1pbmltdW1JbnRlcnZhbCk7XG4gICAgfTtcbiAgICAvKipcbiAgUGFzc2VzIHRoZSBmaXJzdCBldmVudCBpbiB0aGVcbiAgc3RyZWFtIHRocm91Z2gsIGJ1dCBhZnRlciB0aGF0LCBvbmx5IHBhc3NlcyBldmVudHMgYWZ0ZXIgYSBnaXZlbiBudW1iZXJcbiAgb2YgbWlsbGlzZWNvbmRzIGhhdmUgcGFzc2VkIHNpbmNlIHByZXZpb3VzIG91dHB1dC5cbiAgXG4gIEV4YW1wbGU6XG4gIFxuICBgYGBcbiAgc291cmNlOiAgICAgICAgICAgICAgICAgICAgICBhc2RmLS0tLWFzZGYtLS0tXG4gIHNvdXJjZS5kZWJvdW5jZUltbWVkaWF0ZSgyKTogYS1kLS0tLS1hLWQtLS0tLVxuICBgYGBcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5kZWJvdW5jZUltbWVkaWF0ZSA9IGZ1bmN0aW9uIChtaW5pbXVtSW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIGRlYm91bmNlSW1tZWRpYXRlKHRoaXMsIG1pbmltdW1JbnRlcnZhbCk7XG4gICAgfTtcbiAgICAvKipcbiAgRGVjb2RlcyBpbnB1dCB1c2luZyB0aGUgZ2l2ZW4gbWFwcGluZy4gSXMgYVxuICBiaXQgbGlrZSBhIHN3aXRjaC1jYXNlIG9yIHRoZSBkZWNvZGUgZnVuY3Rpb24gaW4gT3JhY2xlIFNRTC4gRm9yXG4gIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmcgd291bGQgbWFwIHRoZSB2YWx1ZSAxIGludG8gdGhlIHN0cmluZyBcIm1pa2VcIlxuICBhbmQgdGhlIHZhbHVlIDIgaW50byB0aGUgdmFsdWUgb2YgdGhlIGB3aG9gIHByb3BlcnR5LlxuICBcbiAgYGBganNcbiAgcHJvcGVydHkuZGVjb2RlKHsxIDogXCJtaWtlXCIsIDIgOiB3aG99KVxuICBgYGBcbiAgXG4gIFRoaXMgaXMgYWN0dWFsbHkgYmFzZWQgb24gW2Bjb21iaW5lVGVtcGxhdGVgXSgjY29tYmluZXRlbXBsYXRlKSBzbyB5b3UgY2FuIGNvbXBvc2Ugc3RhdGljXG4gIGFuZCBkeW5hbWljIGRhdGEgcXVpdGUgZnJlZWx5LCBhcyBpblxuICBcbiAgYGBganNcbiAgcHJvcGVydHkuZGVjb2RlKHsxIDogeyB0eXBlOiBcIm1pa2VcIiB9LCAyIDogeyB0eXBlOiBcIm90aGVyXCIsIHdob1RoZW4gOiB3aG8gfX0pXG4gIGBgYFxuICBcbiAgVGhlIHJldHVybiB2YWx1ZSBvZiBbYGRlY29kZWBdKCNkZWNvZGUpIGlzIGFsd2F5cyBhIFtgUHJvcGVydHlgXShwcm9wZXJ0eS5odG1sKS5cbiAgXG4gICAgICovXG4gICAgLy9kZWNvZGU8VCBleHRlbmRzIFJlY29yZDxhbnksIGFueT4+KHNyYzogT2JzZXJ2YWJsZTxrZXlvZiBUPiwgY2FzZXM6IFQpOiBQcm9wZXJ0eTxEZWNvZGVkVmFsdWVPZjxUPj5cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoY2FzZXMpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZSh0aGlzLCBjYXNlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgRGVsYXlzIHRoZSBzdHJlYW0vcHJvcGVydHkgYnkgZ2l2ZW4gYW1vdW50IG9mIG1pbGxpc2Vjb25kcy4gRG9lcyBub3QgZGVsYXkgdGhlIGluaXRpYWwgdmFsdWUgb2YgYSBbYFByb3BlcnR5YF0ocHJvcGVydHkuaHRtbCkuXG4gIFxuICBgYGBqc1xuICB2YXIgZGVsYXllZCA9IHNvdXJjZS5kZWxheSgyKVxuICBgYGBcbiAgXG4gIGBgYFxuICBzb3VyY2U6ICAgIGFzZGYtLS0tYXNkZi0tLS1cbiAgZGVsYXllZDogICAtLWFzZGYtLS0tYXNkZi0tXG4gIGBgYFxuICBcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uIChkZWxheU1zKSB7XG4gICAgICAgIHJldHVybiBkZWxheSh0aGlzLCBkZWxheU1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFuIGFycmF5IG9mIGRlcGVuZGVuY2llcyB0aGF0IHRoZSBPYnNlcnZhYmxlIGhhcy4gRm9yIGluc3RhbmNlLCBmb3IgYGEubWFwKGZ1bmN0aW9uKCkge30pLmRlcHMoKWAsIHdvdWxkIHJldHVybiBgW2FdYC5cbiAgICAgVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgXCJ2aXNpYmxlXCIgZGVwZW5kZW5jaWVzIG9ubHksIHNraXBwaW5nIGludGVybmFsIGRldGFpbHMuICBUaGlzIG1ldGhvZCBpcyB0aHVzIHN1aXRhYmxlIGZvciB2aXN1YWxpemF0aW9uIHRvb2xzLlxuICAgICBJbnRlcm5hbGx5LCBtYW55IGNvbWJpbmF0b3IgZnVuY3Rpb25zIGRlcGVuZCBvbiBvdGhlciBjb21iaW5hdG9ycyB0byBjcmVhdGUgaW50ZXJtZWRpYXRlIE9ic2VydmFibGVzIHRoYXQgdGhlIHJlc3VsdCB3aWxsIGFjdHVhbGx5IGRlcGVuZCBvbi5cbiAgICAgVGhlIGBkZXBzYCBtZXRob2Qgd2lsbCBza2lwIHRoZXNlIGludGVybmFsIGRlcGVuZGVuY2llcy4gU2VlIGFsc286IFtpbnRlcm5hbERlcHNdKCNpbnRlcm5hbGRlcHMpXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzYy5kZXBzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgUmV0dXJucyBhIFByb3BlcnR5IHRoYXQgcmVwcmVzZW50cyB0aGUgcmVzdWx0IG9mIGEgY29tcGFyaXNvblxuICBiZXR3ZWVuIHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCB2YWx1ZSBvZiB0aGUgT2JzZXJ2YWJsZS4gRm9yIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBPYnNlcnZhYmxlLFxuICB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbCBiZSB0aGUgZ2l2ZW4gc3RhcnQuXG4gIFxuICBFeGFtcGxlOlxuICBcbiAgYGBganNcbiAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gTWF0aC5hYnMoYiAtIGEpIH1cbiAgQmFjb24uc2VxdWVudGlhbGx5KDEsIFsxLDIsM10pLmRpZmYoMCwgZGlzdGFuY2UpXG4gIGBgYFxuICBcbiAgVGhpcyB3b3VsZCByZXN1bHQgdG8gZm9sbG93aW5nIGVsZW1lbnRzIGluIHRoZSByZXN1bHQgc3RyZWFtOlxuICBcbiAgICAgIDEgLSAwID0gMVxuICAgICAgMiAtIDEgPSAxXG4gICAgICAzIC0gMiA9IDFcbiAgXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChzdGFydCwgZikge1xuICAgICAgICByZXR1cm4gZGlmZih0aGlzLCBzdGFydCwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgUmV0dXJucyBhIHN0cmVhbS9wcm9wZXJ0eSB3aGVyZSB0aGUgZnVuY3Rpb24gZlxuICBpcyBleGVjdXRlZCBmb3IgZWFjaCB2YWx1ZSwgYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHN1YnNjcmliZXJzLiBUaGlzIGlzXG4gIHVzZWZ1bCBmb3IgZGVidWdnaW5nLCBidXQgYWxzbyBmb3Igc3R1ZmYgbGlrZSBjYWxsaW5nIHRoZVxuICBgcHJldmVudERlZmF1bHQoKWAgbWV0aG9kIGZvciBldmVudHMuIEluIGZhY3QsIHlvdSBjYW5cbiAgYWxzbyB1c2UgYSBwcm9wZXJ0eS1leHRyYWN0b3Igc3RyaW5nIGluc3RlYWQgb2YgYSBmdW5jdGlvbiwgYXMgaW5cbiAgYFwiLnByZXZlbnREZWZhdWx0XCJgLlxuICBcbiAgUGxlYXNlIG5vdGUgdGhhdCBmb3IgUHJvcGVydGllcywgaXQncyBub3QgZ3VhcmFudGVlZCB0aGF0IHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBleGFjdGx5IG9uY2VcbiAgcGVyIGV2ZW50OyB3aGVuIGEgUHJvcGVydHkgbG9zZXMgYWxsIG9mIGl0cyBzdWJzY3JpYmVycyBpdCB3aWxsIHJlLWVtaXQgaXRzIGN1cnJlbnQgdmFsdWUgd2hlbiBhXG4gIG5ldyBzdWJzY3JpYmVyIGlzIGFkZGVkLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmRvQWN0aW9uID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGRvQWN0aW9uVChmKSwgbmV3IERlc2ModGhpcywgXCJkb0FjdGlvblwiLCBbZl0pKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmRvRW5kID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGRvRW5kVChmKSwgbmV3IERlc2ModGhpcywgXCJkb0VuZFwiLCBbZl0pKTtcbiAgICB9O1xuICAgIC8qKlxuICBSZXR1cm5zIGEgc3RyZWFtL3Byb3BlcnR5IHdoZXJlIHRoZSBmdW5jdGlvbiBmXG4gIGlzIGV4ZWN1dGVkIGZvciBlYWNoIGVycm9yLCBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gc3Vic2NyaWJlcnMuXG4gIFRoYXQgaXMsIHNhbWUgYXMgW2Bkb0FjdGlvbmBdKCNvYnNlcnZhYmxlLWRvYWN0aW9uKSBidXQgZm9yIGVycm9ycy5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5kb0Vycm9yID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGRvRXJyb3JUKGYpLCBuZXcgRGVzYyh0aGlzLCBcImRvRXJyb3JcIiwgW2ZdKSk7XG4gICAgfTtcbiAgICAvKipcbiAgTG9ncyBlYWNoIHZhbHVlIG9mIHRoZSBPYnNlcnZhYmxlIHRvIHRoZSBjb25zb2xlLiBkb0xvZygpIGJlaGF2ZXMgbGlrZSBbYGxvZ2BdKCNsb2cpXG4gIGJ1dCBkb2VzIG5vdCBzdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHN0cmVhbS4gWW91IGNhbiB0aGluayBvZiBkb0xvZygpIGFzIGFcbiAgbG9nZ2VyIGZ1bmN0aW9uIHRoYXQg4oCTIHVubGlrZSBsb2coKSDigJMgaXMgc2FmZSB0byB1c2UgaW4gcHJvZHVjdGlvbi4gZG9Mb2coKSBpc1xuICBzYWZlLCBiZWNhdXNlIGl0IGRvZXMgbm90IGNhdXNlIHRoZSBzYW1lIHN1cnByaXNpbmcgc2lkZS1lZmZlY3RzIGFzIGxvZygpXG4gIGRvZXMuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGRvTG9nVChhcmdzKSwgbmV3IERlc2ModGhpcywgXCJkb0xvZ1wiLCBhcmdzKSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5lbmRBc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZW5kQXNWYWx1ZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgIFJldHVybnMgYSBzdHJlYW0vcHJvcGVydHkgdGhhdCBlbmRzIHRoZSBvbiBmaXJzdCBbYEVycm9yYF0oZXJyb3IuaHRtbCkgZXZlbnQuIFRoZVxuICAgIGVycm9yIGlzIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQgb2YgdGhlIHJldHVybmVkIE9ic2VydmFibGUuXG4gICAgXG4gICAgQHBhcmFtICBwcmVkaWNhdGUgICBvcHRpb25hbCBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gZW5kIG9uIGEgZ2l2ZW4gZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5lbmRPbkVycm9yID0gZnVuY3Rpb24gKHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAocHJlZGljYXRlID09PSB2b2lkIDApIHsgcHJlZGljYXRlID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHRydWU7IH07IH1cbiAgICAgICAgcmV0dXJuIGVuZE9uRXJyb3IodGhpcywgcHJlZGljYXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICBSZXR1cm5zIGEgc3RyZWFtIGNvbnRhaW5pbmcgW2BFcnJvcmBdKGVycm9yLmh0bWwpIGV2ZW50cyBvbmx5LlxuICBTYW1lIGFzIGZpbHRlcmluZyB3aXRoIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBmYWxzZS5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5lcnJvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gZmFsc2U7IH0pLndpdGhEZXNjKG5ldyBEZXNjKHRoaXMsIFwiZXJyb3JzXCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICBGaWx0ZXJzIHZhbHVlcyB1c2luZyBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gIEluc3RlYWQgb2YgYSBmdW5jdGlvbiwgeW91IGNhbiB1c2UgYSBjb25zdGFudCB2YWx1ZSAoYHRydWVgIHRvIGluY2x1ZGUgYWxsLCBgZmFsc2VgIHRvIGV4Y2x1ZGUgYWxsKS5cbiAgXG4gIFlvdSBjYW4gYWxzbyBmaWx0ZXIgdmFsdWVzIGJhc2VkIG9uIHRoZSB2YWx1ZSBvZiBhXG4gIHByb3BlcnR5LiBFdmVudCB3aWxsIGJlIGluY2x1ZGVkIGluIG91dHB1dCBbaWYgYW5kIG9ubHkgaWZdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSWZfYW5kX29ubHlfaWYpIHRoZSBwcm9wZXJ0eSBob2xkcyBgdHJ1ZWBcbiAgYXQgdGhlIHRpbWUgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXIkMSh0aGlzLCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICBUYWtlcyB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBzdHJlYW0uIEVzc2VudGlhbGx5IGBvYnNlcnZhYmxlLnRha2UoMSlgLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGFrZSgxLCB0aGlzLCBuZXcgRGVzYyh0aGlzLCBcImZpcnN0XCIpKTtcbiAgICB9O1xuICAgIC8qKlxuICBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGZpcnN0IGV2ZW50IGNvbWluZyBmcm9tIGFuIE9ic2VydmFibGUuXG4gIExpa2UgW2B0b1Byb21pc2VgXSgjdG9wcm9taXNlKSwgdGhlIGdsb2JhbCBFUzYgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgdW5sZXNzIGEgcHJvbWlzZVxuICBjb25zdHJ1Y3RvciBpcyBnaXZlbi5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5maXJzdFRvUHJvbWlzZSA9IGZ1bmN0aW9uIChQcm9taXNlQ3RyKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFRvUHJvbWlzZSh0aGlzLCBQcm9taXNlQ3RyKTtcbiAgICB9O1xuICAgIC8qKlxuICBXb3JrcyBsaWtlIFtgc2NhbmBdKCNzY2FuKSBidXQgb25seSBlbWl0cyB0aGUgZmluYWxcbiAgdmFsdWUsIGkuZS4gdGhlIHZhbHVlIGp1c3QgYmVmb3JlIHRoZSBvYnNlcnZhYmxlIGVuZHMuIFJldHVybnMgYVxuICBbYFByb3BlcnR5YF0ocHJvcGVydHkuaHRtbCkuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIChzZWVkLCBmKSB7XG4gICAgICAgIHJldHVybiBmb2xkJDEodGhpcywgc2VlZCwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgQW4gYWxpYXMgZm9yIFtvblZhbHVlXSgjb252YWx1ZSkuXG4gIFxuICAgICBTdWJzY3JpYmVzIGEgZ2l2ZW4gaGFuZGxlciBmdW5jdGlvbiB0byB0aGUgb2JzZXJ2YWJsZS4gRnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggbmV3IHZhbHVlIChub3QgZm9yIGVycm9ycyBvciBzdHJlYW0gZW5kKS5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgaWYgKGYgPT09IHZvaWQgMCkgeyBmID0gbnVsbFNpbms7IH1cbiAgICAgICAgLy8gVE9ETzogaW5lZmZpY2llbnQgYWxpYXMuIEFsc28sIHNpbWlsYXIgYXNzaWduIGFsaWFzIG1pc3NpbmcuXG4gICAgICAgIHJldHVybiB0aGlzLm9uVmFsdWUoZik7XG4gICAgfTtcbiAgICAvKipcbiAgUGF1c2VzIGFuZCBidWZmZXJzIHRoZSBldmVudCBzdHJlYW0gaWYgbGFzdCBldmVudCBpbiB2YWx2ZSBpcyB0cnV0aHkuXG4gIEFsbCBidWZmZXJlZCBldmVudHMgYXJlIHJlbGVhc2VkIHdoZW4gdmFsdmUgYmVjb21lcyBmYWxzeS5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5ob2xkV2hlbiA9IGZ1bmN0aW9uICh2YWx2ZSkge1xuICAgICAgICByZXR1cm4gaG9sZFdoZW4odGhpcywgdmFsdmUpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTsgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cnVlIGRlcGVuZGVuY2llcyBvZiB0aGUgb2JzZXJ2YWJsZSwgaW5jbHVkaW5nIHRoZSBpbnRlcm1lZGlhdGUgXCJoaWRkZW5cIiBPYnNlcnZhYmxlcy5cbiAgICAgVGhpcyBtZXRob2QgaXMgZm9yIEJhY29uLmpzIGludGVybmFsIHB1cnBvc2VzIGJ1dCBjb3VsZCBiZSB1c2VmdWwgZm9yIGRlYnVnZ2luZy9hbmFseXNpcyB0b29scyBhcyB3ZWxsLlxuICAgICBTZWUgYWxzbzogW2RlcHNdKCNkZXBzKVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmludGVybmFsRGVwcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbERlc2MuZGVwcygpO1xuICAgIH07XG4gICAgLyoqXG4gIFRha2VzIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSB0aGUgc3RyZWFtLiBOb25lLCBpZiBzdHJlYW0gaXMgZW1wdHkuXG4gIFxuICBcbiAgKk5vdGU6KiBgbmV2ZXJFbmRpbmdTdHJlYW0ubGFzdCgpYCBjcmVhdGVzIHRoZSBzdHJlYW0gd2hpY2ggZG9lc24ndCBwcm9kdWNlIGFueSBldmVudHMgYW5kIG5ldmVyIGVuZHMuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxhc3QkMSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICBMb2dzIGVhY2ggdmFsdWUgb2YgdGhlIE9ic2VydmFibGUgdG8gdGhlIGNvbnNvbGUuXG4gIEl0IG9wdGlvbmFsbHkgdGFrZXMgYXJndW1lbnRzIHRvIHBhc3MgdG8gY29uc29sZS5sb2coKSBhbG9uZ3NpZGUgZWFjaFxuICB2YWx1ZS4gVG8gYXNzaXN0IHdpdGggY2hhaW5pbmcsIGl0IHJldHVybnMgdGhlIG9yaWdpbmFsIE9ic2VydmFibGUuIE5vdGVcbiAgdGhhdCBhcyBhIHNpZGUtZWZmZWN0LCB0aGUgb2JzZXJ2YWJsZSB3aWxsIGhhdmUgYSBjb25zdGFudCBsaXN0ZW5lciBhbmRcbiAgd2lsbCBub3QgYmUgZ2FyYmFnZS1jb2xsZWN0ZWQuIFNvLCB1c2UgdGhpcyBmb3IgZGVidWdnaW5nIG9ubHkgYW5kXG4gIHJlbW92ZSBmcm9tIHByb2R1Y3Rpb24gY29kZS4gRm9yIGV4YW1wbGU6XG4gIFxuICBgYGBqc1xuICBteVN0cmVhbS5sb2coXCJOZXcgZXZlbnQgaW4gbXlTdHJlYW1cIilcbiAgYGBgXG4gIFxuICBvciBqdXN0XG4gIFxuICBgYGBqc1xuICBteVN0cmVhbS5sb2coKVxuICBgYGBcbiAgXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGxvZyhhcmdzLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgQWRkcyBhbiBleHRyYSBbYE5leHRgXShuZXh0Lmh0bWwpIGV2ZW50IGp1c3QgYmVmb3JlIEVuZC4gVGhlIHZhbHVlIGlzIGNyZWF0ZWRcbiAgYnkgY2FsbGluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2hlbiB0aGUgc291cmNlIHN0cmVhbSBlbmRzLiBJbnN0ZWFkIG9mIGFcbiAgZnVuY3Rpb24sIGEgc3RhdGljIHZhbHVlIGNhbiBiZSB1c2VkLlxuICAgICAqL1xuICAgIC8vIFRPRE86IG1hcEVuZCBhbmQgbWFwRXJyb3Igc2lnbmF0dXJlcyBzaG91bGQgYWxsb3cgVnxWMlxuICAgIE9ic2VydmFibGUucHJvdG90eXBlLm1hcEVuZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShtYXBFbmRUKGYpLCBuZXcgRGVzYyh0aGlzLCBcIm1hcEVuZFwiLCBbZl0pKTtcbiAgICB9O1xuICAgIC8qKlxuICBNYXBzIGVycm9ycyB1c2luZyBnaXZlbiBmdW5jdGlvbi4gTW9yZVxuICBzcGVjaWZpY2FsbHksIGZlZWRzIHRoZSBcImVycm9yXCIgZmllbGQgb2YgdGhlIGVycm9yIGV2ZW50IHRvIHRoZSBmdW5jdGlvblxuICBhbmQgcHJvZHVjZXMgYSBbYE5leHRgXShuZXh0Lmh0bWwpIGV2ZW50IGJhc2VkIG9uIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwRXJyb3IgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0obWFwRXJyb3JUKGYpLCBuZXcgRGVzYyh0aGlzLCBcIm1hcEVycm9yXCIsIFtmXSkpO1xuICAgIH07XG4gICAgLyoqXG4gIFNldHMgdGhlIG5hbWUgb2YgdGhlIG9ic2VydmFibGUuIE92ZXJyaWRlcyB0aGUgZGVmYXVsdFxuICBpbXBsZW1lbnRhdGlvbiBvZiBbYHRvU3RyaW5nYF0oI3Rvc3RyaW5nKSBhbmQgYGluc3BlY3RgLlxuICBSZXR1cm5zIHRoZSBzYW1lIG9ic2VydmFibGUsIHdpdGggbXV0YXRlZCBuYW1lLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgU3Vic2NyaWJlcyBhIGNhbGxiYWNrIHRvIHN0cmVhbSBlbmQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzdHJlYW0gZW5kcy5cbiAgSnVzdCBsaWtlIGBzdWJzY3JpYmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgZnVuY3Rpb24gZm9yIHVuc3Vic2NyaWJpbmcuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAoZiA9PT0gdm9pZCAwKSB7IGYgPSBudWxsVm9pZFNpbms7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmlzRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICBTdWJzY3JpYmVzIGEgaGFuZGxlciB0byBlcnJvciBldmVudHMuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBlcnJvciBpbiB0aGUgc3RyZWFtLlxuICBKdXN0IGxpa2UgYHN1YnNjcmliZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBmdW5jdGlvbiBmb3IgdW5zdWJzY3JpYmluZy5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgaWYgKGYgPT09IHZvaWQgMCkgeyBmID0gbnVsbFNpbms7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGlzRXJyb3IoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoZXZlbnQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gIFN1YnNjcmliZXMgYSBnaXZlbiBoYW5kbGVyIGZ1bmN0aW9uIHRvIHRoZSBvYnNlcnZhYmxlLiBGdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBuZXcgdmFsdWUuXG4gIFRoaXMgaXMgdGhlIHNpbXBsZXN0IHdheSB0byBhc3NpZ24gYSBzaWRlLWVmZmVjdCB0byBhbiBvYnNlcnZhYmxlLiBUaGUgZGlmZmVyZW5jZVxuICB0byB0aGUgYHN1YnNjcmliZWAgbWV0aG9kIGlzIHRoYXQgdGhlIGFjdHVhbCBzdHJlYW0gdmFsdWVzIGFyZVxuICByZWNlaXZlZCwgaW5zdGVhZCBvZiBbYEV2ZW50YF0oZXZlbnQpIG9iamVjdHMuXG4gIEp1c3QgbGlrZSBgc3Vic2NyaWJlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIGZ1bmN0aW9uIGZvciB1bnN1YnNjcmliaW5nLlxuICBgc3RyZWFtLm9uVmFsdWVgIGFuZCBgcHJvcGVydHkub25WYWx1ZWAgYmVoYXZlIHNpbWlsYXJseSwgZXhjZXB0IHRoYXQgdGhlIGxhdHRlciBhbHNvXG4gIHB1c2hlcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGluIGNhc2UgdGhlcmUgaXMgb25lLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLm9uVmFsdWUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAoZiA9PT0gdm9pZCAwKSB7IGYgPSBudWxsU2luazsgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaGFzVmFsdWUoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYoZXZlbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gIExpa2UgW2BvblZhbHVlYF0oI29udmFsdWUpLCBidXQgc3BsaXRzIHRoZSB2YWx1ZSAoYXNzdW1pbmcgaXRzIGFuIGFycmF5KSBhcyBmdW5jdGlvbiBhcmd1bWVudHMgdG8gYGZgLlxuICBPbmx5IGFwcGxpY2FibGUgZm9yIG9ic2VydmFibGVzIHdpdGggYXJyYXlzIGFzIHZhbHVlcy5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5vblZhbHVlcyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uVmFsdWUoZnVuY3Rpb24gKGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkodm9pZCAwLCBhcmdzKTsgfSk7XG4gICAgfTtcbiAgICAvKiogQSBzeW5vbnltIGZvciBbc2Nhbl0oI3NjYW4pLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChzZWVkLCBmKSB7XG4gICAgICAgIHJldHVybiBmb2xkJDEodGhpcywgc2VlZCwgZik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zYW1wbGVkQnkgPSBmdW5jdGlvbiAoc2FtcGxlcikge1xuICAgICAgICByZXR1cm4gc2FtcGxlZEJ5KHRoaXMsIHNhbXBsZXIsIGFyZ3VtZW50c1sxXSk7IC8vIFRPRE86IGNvbWJpbmF0b3JcbiAgICB9O1xuICAgIC8qKlxuICBTY2FucyBzdHJlYW0vcHJvcGVydHkgd2l0aCBnaXZlbiBzZWVkIHZhbHVlIGFuZFxuICBhY2N1bXVsYXRvciBmdW5jdGlvbiwgcmVzdWx0aW5nIHRvIGEgUHJvcGVydHkuIEZvciBleGFtcGxlLCB5b3UgbWlnaHRcbiAgdXNlIHplcm8gYXMgc2VlZCBhbmQgYSBcInBsdXNcIiBmdW5jdGlvbiBhcyB0aGUgYWNjdW11bGF0b3IgdG8gY3JlYXRlXG4gIGFuIFwiaW50ZWdyYWxcIiBwcm9wZXJ0eS4gSW5zdGVhZCBvZiBhIGZ1bmN0aW9uLCB5b3UgY2FuIGFsc28gc3VwcGx5IGFcbiAgbWV0aG9kIG5hbWUgc3VjaCBhcyBcIi5jb25jYXRcIiwgaW4gd2hpY2ggY2FzZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb25cbiAgdGhlIGFjY3VtdWxhdG9yIHZhbHVlIGFuZCB0aGUgbmV3IHN0cmVhbSB2YWx1ZSBpcyB1c2VkIGFzIGFyZ3VtZW50LlxuICBcbiAgRXhhbXBsZTpcbiAgXG4gIGBgYGpzXG4gIHZhciBwbHVzID0gZnVuY3Rpb24gKGEsYikgeyByZXR1cm4gYSArIGIgfVxuICBCYWNvbi5zZXF1ZW50aWFsbHkoMSwgWzEsMiwzXSkuc2NhbigwLCBwbHVzKVxuICBgYGBcbiAgXG4gIFRoaXMgd291bGQgcmVzdWx0IHRvIGZvbGxvd2luZyBlbGVtZW50cyBpbiB0aGUgcmVzdWx0IHN0cmVhbTpcbiAgXG4gICAgICBzZWVkIHZhbHVlID0gMFxuICAgICAgMCArIDEgPSAxXG4gICAgICAxICsgMiA9IDNcbiAgICAgIDMgKyAzID0gNlxuICBcbiAgV2hlbiBhcHBsaWVkIHRvIGEgUHJvcGVydHkgYXMgaW4gYHIgPSBwLnNjYW4oc2VlZCwgZilgLCB0aGVyZSdzIGEgKGhvcGVmdWxseSBpbnNpZ25pZmljYW50KSBjYXRjaDpcbiAgVGhlIHN0YXJ0aW5nIHZhbHVlIGZvciBgcmAgZGVwZW5kcyBvbiB3aGV0aGVyIGBwYCBoYXMgYW5cbiAgaW5pdGlhbCB2YWx1ZSB3aGVuIHNjYW4gaXMgYXBwbGllZC4gSWYgdGhlcmUncyBubyBpbml0aWFsIHZhbHVlLCB0aGlzIHdvcmtzXG4gIGlkZW50aWNhbGx5IHRvIEV2ZW50U3RyZWFtLnNjYW46IHRoZSBgc2VlZGAgd2lsbCBiZSB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICBgcmAuIEhvd2V2ZXIsIGlmIGByYCBhbHJlYWR5IGhhcyBhIGN1cnJlbnQvaW5pdGlhbCB2YWx1ZSBgeGAsIHRoZVxuICBzZWVkIHdvbid0IGJlIG91dHB1dCBhcyBpcy4gSW5zdGVhZCwgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHJgIHdpbGwgYmUgYGYoc2VlZCwgeClgLiBUaGlzIG1ha2VzIHNlbnNlLFxuICBiZWNhdXNlIHRoZXJlIGNhbiBvbmx5IGJlIDEgaW5pdGlhbCB2YWx1ZSBmb3IgYSBQcm9wZXJ0eSBhdCBhIHRpbWUuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2NhbiA9IGZ1bmN0aW9uIChzZWVkLCBmKSB7XG4gICAgICAgIHJldHVybiBzY2FuKHRoaXMsIHNlZWQsIGYpO1xuICAgIH07XG4gICAgLyoqXG4gIFNraXBzIHRoZSBmaXJzdCBuIGVsZW1lbnRzIGZyb20gdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHNraXAodGhpcywgY291bnQpO1xuICAgIH07XG4gICAgLyoqXG4gIERyb3BzIGNvbnNlY3V0aXZlIGVxdWFsIGVsZW1lbnRzLiBTbyxcbiAgZnJvbSBgWzEsIDIsIDIsIDFdYCB5b3UnZCBnZXQgYFsxLCAyLCAxXWAuIFVzZXMgdGhlIGA9PT1gIG9wZXJhdG9yIGZvciBlcXVhbGl0eVxuICBjaGVja2luZyBieSBkZWZhdWx0LiBJZiB0aGUgaXNFcXVhbCBhcmd1bWVudCBpcyBzdXBwbGllZCwgY2hlY2tzIGJ5IGNhbGxpbmdcbiAgaXNFcXVhbChvbGRWYWx1ZSwgbmV3VmFsdWUpLiBGb3IgaW5zdGFuY2UsIHRvIGRvIGEgZGVlcCBjb21wYXJpc29uLHlvdSBjYW5cbiAgdXNlIHRoZSBpc0VxdWFsIGZ1bmN0aW9uIGZyb20gW3VuZGVyc2NvcmUuanNdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLylcbiAgbGlrZSBgc3RyZWFtLnNraXBEdXBsaWNhdGVzKF8uaXNFcXVhbClgLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnNraXBEdXBsaWNhdGVzID0gZnVuY3Rpb24gKGlzRXF1YWwpIHtcbiAgICAgICAgcmV0dXJuIHNraXBEdXBsaWNhdGVzKHRoaXMsIGlzRXF1YWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzdHJlYW0vcHJvcGVydHkgd2hpY2ggZXhjbHVkZXMgYWxsIFtFcnJvcl0oZXJyb3IuaHRtbCkgZXZlbnRzIGluIHRoZSBzb3VyY2VcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2tpcEVycm9ycyh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBTa2lwcyBlbGVtZW50cyBmcm9tIHRoZSBzb3VyY2UsIHVudGlsIGEgdmFsdWUgZXZlbnRcbiAgICAgYXBwZWFycyBpbiB0aGUgZ2l2ZW4gYHN0YXJ0ZXJgIHN0cmVhbS9wcm9wZXJ0eS4gSW4gb3RoZXIgd29yZHMsIHN0YXJ0cyBkZWxpdmVyaW5nIHZhbHVlc1xuICAgICBmcm9tIHRoZSBzb3VyY2UgYWZ0ZXIgZmlyc3QgdmFsdWUgYXBwZWFycyBpbiBgc3RhcnRlcmAuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2tpcFVudGlsID0gZnVuY3Rpb24gKHN0YXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIHNraXBVbnRpbCh0aGlzLCBzdGFydGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBTa2lwcyBlbGVtZW50cyB1bnRpbCB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgZmFsc3kgb25jZSwgYW5kIHRoZW5cbiAgICAgbGV0cyBhbGwgZXZlbnRzIHBhc3MgdGhyb3VnaC4gSW5zdGVhZCBvZiBhIHByZWRpY2F0ZSB5b3UgY2FuIGFsc28gcGFzcyBpbiBhIGBQcm9wZXJ0eTxib29sZWFuPmAgdG8gc2tpcCBlbGVtZW50c1xuICAgICB3aGlsZSB0aGUgUHJvcGVydHkgaG9sZHMgYSB0cnV0aHkgdmFsdWUuXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2tpcFdoaWxlID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHNraXBXaGlsZSh0aGlzLCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICBSZXR1cm5zIGEgUHJvcGVydHkgdGhhdCByZXByZXNlbnRzIGFcbiAgXCJzbGlkaW5nIHdpbmRvd1wiIGludG8gdGhlIGhpc3Rvcnkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgT2JzZXJ2YWJsZS4gVGhlXG4gIHJlc3VsdCBQcm9wZXJ0eSB3aWxsIGhhdmUgYSB2YWx1ZSB0aGF0IGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gXG4gIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwgb2JzZXJ2YWJsZSwgd2hlcmUgYG5gIGlzIGF0IG1vc3QgdGhlIHZhbHVlIG9mIHRoZVxuICBgbWF4YCBhcmd1bWVudCwgYW5kIGF0IGxlYXN0IHRoZSB2YWx1ZSBvZiB0aGUgYG1pbmAgYXJndW1lbnQuIElmIHRoZVxuICBgbWluYCBhcmd1bWVudCBpcyBvbWl0dGVkLCB0aGVyZSdzIG5vIGxvd2VyIGxpbWl0IG9mIHZhbHVlcy5cbiAgXG4gIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSBhIHN0cmVhbSBgc2Agd2l0aCB2YWx1ZSBhIHNlcXVlbmNlIDEgLSAyIC0gMyAtIDQgLSA1LCB0aGVcbiAgcmVzcGVjdGl2ZSB2YWx1ZXMgaW4gYHMuc2xpZGluZ1dpbmRvdygyKWAgd291bGQgYmUgW10gLSBbMV0gLSBbMSwyXSAtXG4gIFsyLDNdIC0gWzMsNF0gLSBbNCw1XS4gVGhlIHZhbHVlcyBvZiBgcy5zbGlkaW5nV2luZG93KDIsMilgd291bGQgYmVcbiAgWzEsMl0gLSBbMiwzXSAtIFszLDRdIC0gWzQsNV0uXG4gIFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnNsaWRpbmdXaW5kb3cgPSBmdW5jdGlvbiAobWF4VmFsdWVzLCBtaW5WYWx1ZXMpIHtcbiAgICAgICAgaWYgKG1pblZhbHVlcyA9PT0gdm9pZCAwKSB7IG1pblZhbHVlcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHNsaWRpbmdXaW5kb3codGhpcywgbWF4VmFsdWVzLCBtaW5WYWx1ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogc3Vic2NyaWJlcyBnaXZlbiBoYW5kbGVyIGZ1bmN0aW9uIHRvIGV2ZW50IHN0cmVhbS4gRnVuY3Rpb24gd2lsbCByZWNlaXZlIFtldmVudF0oZXZlbnQuaHRtbCkgb2JqZWN0c1xuICAgICBmb3IgYWxsIG5ldyB2YWx1ZSwgZW5kIGFuZCBlcnJvciBldmVudHMgaW4gdGhlIHN0cmVhbS5cbiAgICAgVGhlIHN1YnNjcmliZSgpIGNhbGwgcmV0dXJucyBhIGB1bnN1YnNjcmliZWAgZnVuY3Rpb24gdGhhdCB5b3UgY2FuIGNhbGwgdG8gdW5zdWJzY3JpYmUuXG4gICAgIFlvdSBjYW4gYWxzbyB1bnN1YnNjcmliZSBieSByZXR1cm5pbmcgW2BCYWNvbi5ub01vcmVgXSguLi9nbG9iYWxzLmh0bWwjbm9tb3JlKSBmcm9tIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGFzIGEgcmVwbHlcbiAgICAgdG8gYW4gRXZlbnQuXG4gICAgIGBzdHJlYW0uc3Vic2NyaWJlYCBhbmQgYHByb3BlcnR5LnN1YnNjcmliZWAgYmVoYXZlIHNpbWlsYXJseSwgZXhjZXB0IHRoYXQgdGhlIGxhdHRlciBhbHNvXG4gICAgIHB1c2hlcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHksIGluIGNhc2UgdGhlcmUgaXMgb25lLlxuICBcbiAgICAgKiBAcGFyYW0ge0V2ZW50U2luazxWPn0gc2luayB0aGUgaGFuZGxlciBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtVbnN1Yn1cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc2luayA9PT0gdm9pZCAwKSB7IHNpbmsgPSBudWxsU2luazsgfVxuICAgICAgICByZXR1cm4gVXBkYXRlQmFycmllci53cmFwcGVkU3Vic2NyaWJlKHRoaXMsIGZ1bmN0aW9uIChzaW5rKSB7IHJldHVybiBfdGhpcy5zdWJzY3JpYmVJbnRlcm5hbChzaW5rKTsgfSwgc2luayk7XG4gICAgfTtcbiAgICAvKipcbiAgVGFrZXMgYXQgbW9zdCBuIHZhbHVlcyBmcm9tIHRoZSBzdHJlYW0gYW5kIHRoZW4gZW5kcyB0aGUgc3RyZWFtLiBJZiB0aGUgc3RyZWFtIGhhc1xuICBmZXdlciB0aGFuIG4gdmFsdWVzIHRoZW4gaXQgaXMgdW5hZmZlY3RlZC5cbiAgRXF1YWwgdG8gW2BCYWNvbi5uZXZlcigpYF0oLi4vZ2xvYmFscy5odG1sI25ldmVyKSBpZiBgbiA8PSAwYC5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS50YWtlID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIHJldHVybiB0YWtlKGNvdW50LCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICBUYWtlcyBlbGVtZW50cyBmcm9tIHNvdXJjZSB1bnRpbCBhIHZhbHVlIGV2ZW50IGFwcGVhcnMgaW4gdGhlIG90aGVyIHN0cmVhbS5cbiAgSWYgb3RoZXIgc3RyZWFtIGVuZHMgd2l0aG91dCB2YWx1ZSwgaXQgaXMgaWdub3JlZC5cbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS50YWtlVW50aWwgPSBmdW5jdGlvbiAoc3RvcHBlcikge1xuICAgICAgICByZXR1cm4gdGFrZVVudGlsKHRoaXMsIHN0b3BwZXIpO1xuICAgIH07XG4gICAgLyoqXG4gIFRha2VzIHdoaWxlIGdpdmVuIHByZWRpY2F0ZSBmdW5jdGlvbiBob2xkcyB0cnVlLCBhbmQgdGhlbiBlbmRzLiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHN1cHBseSBhIGJvb2xlYW4gUHJvcGVydHkgdG8gdGFrZSBlbGVtZW50cyB3aGlsZSB0aGUgUHJvcGVydHkgaG9sZHMgYHRydWVgLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRha2VXaGlsZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0YWtlV2hpbGUodGhpcywgZik7XG4gICAgfTtcbiAgICAvKipcbiAgVGhyb3R0bGVzIHN0cmVhbS9wcm9wZXJ0eSBieSBnaXZlbiBhbW91bnRcbiAgb2YgbWlsbGlzZWNvbmRzLiBFdmVudHMgYXJlIGVtaXR0ZWQgd2l0aCB0aGUgbWluaW11bSBpbnRlcnZhbCBvZlxuICBbYGRlbGF5YF0oI29ic2VydmFibGUtZGVsYXkpLiBUaGUgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gW2BzdHJlYW0uYnVmZmVyV2l0aFRpbWVgXSgjc3RyZWFtLWJ1ZmZlcndpdGh0aW1lKS5cbiAgRG9lcyBub3QgYWZmZWN0IGVtaXR0aW5nIHRoZSBpbml0aWFsIHZhbHVlIG9mIGEgW2BQcm9wZXJ0eWBdKCNwcm9wZXJ0eSkuXG4gIFxuICBFeGFtcGxlOlxuICBcbiAgYGBganNcbiAgdmFyIHRocm90dGxlZCA9IHNvdXJjZS50aHJvdHRsZSgyKVxuICBgYGBcbiAgXG4gIGBgYFxuICBzb3VyY2U6ICAgIGFzZGYtLS0tYXNkZi0tLS1cbiAgdGhyb3R0bGVkOiAtLXMtLWYtLS0tcy0tZi0tXG4gIGBgYFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRocm90dGxlID0gZnVuY3Rpb24gKG1pbmltdW1JbnRlcnZhbCkge1xuICAgICAgICByZXR1cm4gdGhyb3R0bGUodGhpcywgbWluaW11bUludGVydmFsKTtcbiAgICB9O1xuICAgIC8qKlxuICBSZXR1cm5zIGEgUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIGxhc3QgZXZlbnQgY29taW5nIGZyb20gYW4gT2JzZXJ2YWJsZS5cbiAgVGhlIGdsb2JhbCBFUzYgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgdW5sZXNzIGEgcHJvbWlzZSBjb25zdHJ1Y3RvciBpcyBnaXZlbi5cbiAgVXNlIGEgc2hpbSBpZiB5b3UgbmVlZCB0byBzdXBwb3J0IGxlZ2FjeSBicm93c2VycyBvciBwbGF0Zm9ybXMuXG4gIFtjYW5pdXNlIHByb21pc2VzXShodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9cHJvbWlzZXMpLlxuICBcbiAgU2VlIGFsc28gW2ZpcnN0VG9Qcm9taXNlXSgjZmlyc3R0b3Byb21pc2UpLlxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChQcm9taXNlQ3RyKSB7XG4gICAgICAgIHJldHVybiB0b1Byb21pc2UodGhpcywgUHJvbWlzZUN0cik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlJldHVybnMgYSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSBPYnNlcnZhYmxlLiBGb3IgaW5zdGFuY2UsIGBCYWNvbi5vbmNlKDEpLm1hcChmdW5jdGlvbigpIHt9KS50b1N0cmluZygpYCB3b3VsZCByZXR1cm4gXCJCYWNvbi5vbmNlKDEpLm1hcChmdW5jdGlvbilcIi5cbiAgICAgKiovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc2MudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUud2l0aERlc2MgPSBmdW5jdGlvbiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYylcbiAgICAgICAgICAgIHRoaXMuZGVzYyA9IGRlc2M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gIFNldHMgdGhlIHN0cnVjdHVyZWQgZGVzY3JpcHRpb24gb2YgdGhlIG9ic2VydmFibGUuIFRoZSBbYHRvU3RyaW5nYF0oI3Rvc3RyaW5nKSBhbmQgYGluc3BlY3RgIG1ldGhvZHNcbiAgdXNlIHRoaXMgZGF0YSByZWN1cnNpdmVseSB0byBjcmVhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBvYnNlcnZhYmxlLiBUaGlzIG1ldGhvZFxuICBpcyBwcm9iYWJseSB1c2VmdWwgZm9yIEJhY29uIGNvcmUgLyBsaWJyYXJ5IC8gcGx1Z2luIGRldmVsb3BtZW50IG9ubHkuXG4gIFxuICBGb3IgZXhhbXBsZTpcbiAgXG4gICAgICB2YXIgc3JjID0gQmFjb24ub25jZSgxKVxuICAgICAgdmFyIG9icyA9IHNyYy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gLXggfSlcbiAgICAgIGNvbnNvbGUubG9nKG9icy50b1N0cmluZygpKVxuICAgICAgLS0+IEJhY29uLm9uY2UoMSkubWFwKGZ1bmN0aW9uKVxuICAgICAgb2JzLndpdGhEZXNjcmlwdGlvbihzcmMsIFwidGltZXNcIiwgLTEpXG4gICAgICBjb25zb2xlLmxvZyhvYnMudG9TdHJpbmcoKSlcbiAgICAgIC0tPiBCYWNvbi5vbmNlKDEpLnRpbWVzKC0xKVxuICBcbiAgVGhlIG1ldGhvZCByZXR1cm5zIHRoZSBzYW1lIG9ic2VydmFibGUgd2l0aCBtdXRhdGVkIGRlc2NyaXB0aW9uLlxuICBcbiAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS53aXRoRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoY29udGV4dCwgbWV0aG9kKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzYyA9IGRlc2NyaWJlLmFwcGx5KHZvaWQgMCwgW2NvbnRleHQsIG1ldGhvZF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgUmV0dXJucyBhbiBFdmVudFN0cmVhbSB3aXRoIGVsZW1lbnRzXG4gIHBhaXItd2lzZSBsaW5lZCB1cCB3aXRoIGV2ZW50cyBmcm9tIHRoaXMgYW5kIHRoZSBvdGhlciBFdmVudFN0cmVhbSBvciBQcm9wZXJ0eS5cbiAgQSB6aXBwZWQgc3RyZWFtIHdpbGwgcHVibGlzaCBvbmx5IHdoZW4gaXQgaGFzIGEgdmFsdWUgZnJvbSBlYWNoXG4gIHNvdXJjZSBhbmQgd2lsbCBvbmx5IHByb2R1Y2UgdmFsdWVzIHVwIHRvIHdoZW4gYW55IHNpbmdsZSBzb3VyY2UgZW5kcy5cbiAgXG4gIFRoZSBnaXZlbiBmdW5jdGlvbiBgZmAgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHJlc3VsdCB2YWx1ZSBmcm9tIHZhbHVlIGluIHRoZSB0d29cbiAgc291cmNlcy4gSWYgbm8gZnVuY3Rpb24gaXMgZ2l2ZW4sIHRoZSB2YWx1ZXMgYXJlIHppcHBlZCBpbnRvIGFuIGFycmF5LlxuICBcbiAgQmUgY2FyZWZ1bCBub3QgdG8gaGF2ZSB0b28gbXVjaCBcImRyaWZ0XCIgYmV0d2VlbiBzdHJlYW1zLiBJZiBvbmUgc3RyZWFtXG4gIHByb2R1Y2VzIG1hbnkgbW9yZSB2YWx1ZXMgdGhhbiBzb21lIG90aGVyIGV4Y2Vzc2l2ZSBidWZmZXJpbmcgd2lsbFxuICBvY2N1ciBpbnNpZGUgdGhlIHppcHBlZCBvYnNlcnZhYmxlLlxuICBcbiAgRXhhbXBsZSAxOlxuICBcbiAgYGBganNcbiAgdmFyIHggPSBCYWNvbi5mcm9tQXJyYXkoWzEsIDJdKVxuICB2YXIgeSA9IEJhY29uLmZyb21BcnJheShbMywgNF0pXG4gIHguemlwKHksIGZ1bmN0aW9uKHgsIHkpIHsgcmV0dXJuIHggKyB5IH0pXG4gIFxuICAjIHByb2R1Y2VzIHZhbHVlcyA0LCA2XG4gIGBgYFxuICBcbiAgU2VlIGFsc28gW2B6aXBXaXRoYF0oLi4vZ2xvYmFscy5odG1sI3ppcHdpdGgpIGFuZCBbYHppcEFzQXJyYXlgXSguLi9nbG9iYWxzLmh0bWwvemlwYXNhcnJheSkgZm9yIHppcHBpbmcgbW9yZSB0aGFuIDIgc291cmNlcy5cbiAgXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuemlwID0gZnVuY3Rpb24gKG90aGVyLCBmKSB7XG4gICAgICAgIHJldHVybiB6aXAodGhpcywgb3RoZXIsIGYpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuLyoqXG4gQSByZWFjdGl2ZSBwcm9wZXJ0eS4gSGFzIHRoZSBjb25jZXB0IG9mIFwiY3VycmVudCB2YWx1ZVwiLlxuIFlvdSBjYW4gY3JlYXRlIGEgUHJvcGVydHkgZnJvbSBhbiBFdmVudFN0cmVhbSBieSB1c2luZyBlaXRoZXIgW2B0b1Byb3BlcnR5YF0oZXZlbnRzdHJlYW0uaHRtbCN0b3Byb3BlcnR5KVxuIG9yIFtgc2NhbmBdKGV2ZW50c3RyZWFtLmh0bWwjc2NhbikgbWV0aG9kLiBOb3RlOiBkZXBlbmRpbmcgb24gaG93IGEgUHJvcGVydHkgaXMgY3JlYXRlZCwgaXQgbWF5IG9yIG1heSBub3RcbiBoYXZlIGFuIGluaXRpYWwgdmFsdWUuIFRoZSBjdXJyZW50IHZhbHVlIHN0YXlzIGFzIGl0cyBsYXN0IHZhbHVlIGFmdGVyIHRoZSBzdHJlYW0gaGFzIGVuZGVkLlxuXG4gSGVyZSBhcmUgdGhlIG1vc3QgY29tbW9uIHdheXMgZm9yIGNyZWF0aW5nIFByb3BlcnRpZXM6XG5cbiAtIENyZWF0ZSBhIGNvbnN0YW50IHByb3BlcnR5IHdpdGggW2NvbnN0YW50XSguLi9nbG9iYWxzLmh0bWwjY29uc3RhbnQpXG4gLSBDcmVhdGUgYSBwcm9wZXJ0eSBiYXNlZCBvbiBhbiBFdmVudFN0cmVhbSB3aXRoIFt0b1Byb3BlcnR5XShldmVudHN0cmVhbS5odG1sI3RvcHJvcGVydHkpXG4gLSBTY2FuIGFuIEV2ZW50U3RyZWFtIHdpdGggYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gd2l0aCBbc2Nhbl0oZXZlbnRzdHJlYW0uaHRtbCNzY2FuKVxuIC0gQ3JlYXRlIGEgc3RhdGUgcHJvcGVydHkgYmFzZWQgb24gbXVsdGlwbGUgc291cmNlcyB1c2luZyBbdXBkYXRlXSguLi9nbG9iYWxzLmh0bWwjdXBkYXRlKVxuXG4gQHR5cGVwYXJhbSBWICAgVHlwZSBvZiB0aGUgZWxlbWVudHMvdmFsdWVzIGluIHRoZSBzdHJlYW0vcHJvcGVydHlcbiAqL1xudmFyIFByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQcm9wZXJ0eSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eShkZXNjLCBzdWJzY3JpYmUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzYykgfHwgdGhpcztcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBfdGhpcy5faXNQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKHN1YnNjcmliZSk7XG4gICAgICAgIF90aGlzLmRpc3BhdGNoZXIgPSBuZXcgUHJvcGVydHlEaXNwYXRjaGVyKF90aGlzLCBzdWJzY3JpYmUsIGhhbmRsZXIpO1xuICAgICAgICByZWdpc3Rlck9icyhfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgIENvbWJpbmVzIHByb3BlcnRpZXMgd2l0aCB0aGUgYCYmYCBvcGVyYXRvci4gSXQgcHJvZHVjZXMgYSBuZXcgdmFsdWUgd2hlbiBlaXRoZXIgb2YgdGhlIFByb3BlcnRpZXMgY2hhbmdlLFxuICAgICBjb21iaW5pbmcgdGhlIGxhdGVzdCB2YWx1ZXMgdXNpbmcgYCYmYC5cbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBhbmQodGhpcywgb3RoZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBhIHN0cmVhbSBvZiBjaGFuZ2VzIHRvIHRoZSBQcm9wZXJ0eS4gVGhlIHN0cmVhbSAqZG9lcyBub3QqIGluY2x1ZGVcbiAgICAgYW4gZXZlbnQgZm9yIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBQcm9wZXJ0eSBhdCB0aGUgdGltZSB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkLlxuICAgICAqL1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS5jaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50U3RyZWFtKG5ldyBEZXNjKHRoaXMsIFwiY2hhbmdlc1wiLCBbXSksIGZ1bmN0aW9uIChzaW5rKSB7IHJldHVybiBfdGhpcy5kaXNwYXRjaGVyLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuaXNJbml0aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtQ2hhbmdlcyhkZXNjcmliZSh0aGlzLCBcImNvbmNhdFwiLCBvdGhlciksIGZ1bmN0aW9uIChjaGFuZ2VzKSB7IHJldHVybiBjaGFuZ2VzLmNvbmNhdChvdGhlcik7IH0pO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUudHJhbnNmb3JtQ2hhbmdlcyA9IGZ1bmN0aW9uIChkZXNjLCBmKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9wZXJ0eUNoYW5nZXModGhpcywgZiwgZGVzYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc291cmNlIHN0cmVhbSwgc3Bhd24gYSBuZXdcbiAgICAgc3RyZWFtL3Byb3BlcnR5IHVzaW5nIHRoZSBmdW5jdGlvbiBgZmAuIENvbGxlY3QgZXZlbnRzIGZyb20gZWFjaCBvZiB0aGUgc3Bhd25lZFxuICAgICBzdHJlYW1zIGludG8gdGhlIHJlc3VsdCBwcm9wZXJ0eS4gTm90ZSB0aGF0IGluc3RlYWQgb2YgYSBmdW5jdGlvbiwgeW91IGNhbiBwcm92aWRlIGFcbiAgICAgc3RyZWFtL3Byb3BlcnR5IHRvby4gQWxzbywgdGhlIHJldHVybiB2YWx1ZSBvZiBmdW5jdGlvbiBgZmAgY2FuIGJlIGVpdGhlciBhblxuICAgICBgT2JzZXJ2YWJsZWAgKHN0cmVhbS9wcm9wZXJ0eSkgb3IgYSBjb25zdGFudCB2YWx1ZS5cbiAgXG4gICAgIGBzdHJlYW0uZmxhdE1hcCgpYCBjYW4gYmUgdXNlZCBjb252ZW5pZW50bHkgd2l0aCBbYEJhY29uLm9uY2UoKWBdKC4uL2dsb2JhbHMuaHRtbCNvbmNlKSBhbmQgW2BCYWNvbi5uZXZlcigpYF0oLi4vZ2xvYmFscy5odG1sI25ldmVyKVxuICAgICBmb3IgY29udmVydGluZyBhbmQgZmlsdGVyaW5nIGF0IHRoZSBzYW1lIHRpbWUsIGluY2x1ZGluZyBvbmx5IHNvbWUgb2YgdGhlIHJlc3VsdHMuXG4gIFxuICAgICBFeGFtcGxlIC0gY29udmVydGluZyBzdHJpbmdzIHRvIGludGVnZXJzLCBza2lwcGluZyBlbXB0eSB2YWx1ZXM6XG4gIFxuICAgICBgYGBqc1xuICAgICBzdHJlYW0uZmxhdE1hcChmdW5jdGlvbih0ZXh0KSB7XG4gICAgICByZXR1cm4gKHRleHQgIT0gXCJcIikgPyBwYXJzZUludCh0ZXh0KSA6IEJhY29uLm5ldmVyKClcbiAgfSlcbiAgICAgYGBgXG4gICAgICovXG4gICAgUHJvcGVydHkucHJvdG90eXBlLmZsYXRNYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZmxhdE1hcCQxKHRoaXMsIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgIEEgW2BmbGF0TWFwV2l0aENvbmN1cnJlbmN5TGltaXRgXSgjZmxhdG1hcHdpdGhjb25jdXJyZW5jeWxpbWl0KSB3aXRoIGxpbWl0IG9mIDEuXG4gICAgICovXG4gICAgUHJvcGVydHkucHJvdG90eXBlLmZsYXRNYXBDb25jYXQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZmxhdE1hcENvbmNhdCh0aGlzLCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBMaWtlIFtgZmxhdE1hcGBdKCNmbGF0bWFwKSwgYnV0IGlzIGFwcGxpZWQgb25seSBvbiBbYEVycm9yYF0oZXJyb3IuaHRtbCkgZXZlbnRzLiBSZXR1cm5lZCB2YWx1ZXMgZ28gaW50byB0aGVcbiAgICAgdmFsdWUgc3RyZWFtLCB1bmxlc3MgYW4gZXJyb3IgZXZlbnQgaXMgcmV0dXJuZWQuIEFzIGFuIGV4YW1wbGUsIG9uZSB0eXBlIG9mIGVycm9yIGNvdWxkIHJlc3VsdCBpbiBhIHJldHJ5IGFuZCBhbm90aGVyIGp1c3RcbiAgICAgcGFzc2VkIHRocm91Z2gsIHdoaWNoIGNhbiBiZSBpbXBsZW1lbnRlZCB1c2luZyBmbGF0TWFwRXJyb3IuXG4gICAgICovXG4gICAgUHJvcGVydHkucHJvdG90eXBlLmZsYXRNYXBFcnJvciA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmbGF0TWFwRXJyb3IodGhpcywgZik7XG4gICAgfTtcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuZmxhdE1hcEV2ZW50ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXBFdmVudCh0aGlzLCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBMaWtlIFtgZmxhdE1hcGBdKCNvYnNlcnZhYmxlLWZsYXRtYXApLCBidXQgb25seSBzcGF3bnMgYSBuZXdcbiAgICAgc3RyZWFtIGlmIHRoZSBwcmV2aW91c2x5IHNwYXduZWQgc3RyZWFtIGhhcyBlbmRlZC5cbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuZmxhdE1hcEZpcnN0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXBGaXJzdCh0aGlzLCBmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBMaWtlIFtgZmxhdE1hcGBdKCNmbGF0bWFwKSwgYnV0IGluc3RlYWQgb2YgaW5jbHVkaW5nIGV2ZW50cyBmcm9tXG4gICAgIGFsbCBzcGF3bmVkIHN0cmVhbXMsIG9ubHkgaW5jbHVkZXMgdGhlbSBmcm9tIHRoZSBsYXRlc3Qgc3Bhd25lZCBzdHJlYW0uXG4gICAgIFlvdSBjYW4gdGhpbmsgdGhpcyBhcyBzd2l0Y2hpbmcgZnJvbSBzdHJlYW0gdG8gc3RyZWFtLlxuICAgICBOb3RlIHRoYXQgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uLCB5b3UgY2FuIHByb3ZpZGUgYSBzdHJlYW0vcHJvcGVydHkgdG9vLlxuICAgICAqL1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS5mbGF0TWFwTGF0ZXN0ID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXBMYXRlc3QodGhpcywgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgQSBzdXBlciBtZXRob2Qgb2YgKmZsYXRNYXAqIGZhbWlseS4gSXQgbGltaXRzIHRoZSBudW1iZXIgb2Ygb3BlbiBzcGF3bmVkIHN0cmVhbXMgYW5kIGJ1ZmZlcnMgaW5jb21pbmcgZXZlbnRzLlxuICAgICBbYGZsYXRNYXBDb25jYXRgXSgjZmxhdG1hcGNvbmNhdCkgaXMgYGZsYXRNYXBXaXRoQ29uY3VycmVuY3lMaW1pdCgxKWAgKG9ubHkgb25lIGlucHV0IGFjdGl2ZSksXG4gICAgIGFuZCBbYGZsYXRNYXBgXSgjZmxhdG1hcCkgaXMgYGZsYXRNYXBXaXRoQ29uY3VycmVuY3lMaW1pdCDiiJ5gIChhbGwgaW5wdXRzIGFyZSBwaXBlZCB0byBvdXRwdXQpLlxuICAgICAqL1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS5mbGF0TWFwV2l0aENvbmN1cnJlbmN5TGltaXQgPSBmdW5jdGlvbiAobGltaXQsIGYpIHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXBXaXRoQ29uY3VycmVuY3lMaW1pdCh0aGlzLCBsaW1pdCwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgR3JvdXBzIHN0cmVhbSBldmVudHMgdG8gbmV3IHN0cmVhbXMgYnkgYGtleUZgLiBPcHRpb25hbCBgbGltaXRGYCBjYW4gYmUgcHJvdmlkZWQgdG8gbGltaXQgZ3JvdXBlZFxuICAgICBzdHJlYW0gbGlmZS4gU3RyZWFtIHRyYW5zZm9ybWVkIGJ5IGBsaW1pdEZgIGlzIHBhc3NlZCBvbiBpZiBwcm92aWRlZC4gYGxpbWl0RmAgZ2V0cyBncm91cGVkIHN0cmVhbVxuICAgICBhbmQgdGhlIG9yaWdpbmFsIGV2ZW50IGNhdXNpbmcgdGhlIHN0cmVhbSB0byBzdGFydCBhcyBwYXJhbWV0ZXJzLlxuICBcbiAgICAgQ2FsY3VsYXRvciBmb3IgZ3JvdXBlZCBjb25zZWN1dGl2ZSB2YWx1ZXMgdW50aWwgZ3JvdXAgaXMgY2FuY2VsbGVkOlxuICBcbiAgICAgYGBgXG4gICAgIHZhciBldmVudHMgPSBbXG4gICAgIHtpZDogMSwgdHlwZTogXCJhZGRcIiwgdmFsOiAzIH0sXG4gICAgIHtpZDogMiwgdHlwZTogXCJhZGRcIiwgdmFsOiAtMSB9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiYWRkXCIsIHZhbDogMiB9LFxuICAgICB7aWQ6IDIsIHR5cGU6IFwiY2FuY2VsXCJ9LFxuICAgICB7aWQ6IDMsIHR5cGU6IFwiYWRkXCIsIHZhbDogMiB9LFxuICAgICB7aWQ6IDMsIHR5cGU6IFwiY2FuY2VsXCJ9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiYWRkXCIsIHZhbDogMSB9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiYWRkXCIsIHZhbDogMiB9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiY2FuY2VsXCJ9XG4gICAgIF1cbiAgXG4gICAgIGZ1bmN0aW9uIGtleUYoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuaWRcbiAgfVxuICBcbiAgICAgZnVuY3Rpb24gbGltaXRGKGdyb3VwZWRTdHJlYW0sIGdyb3VwU3RhcnRpbmdFdmVudCkge1xuICAgIHZhciBjYW5jZWwgPSBncm91cGVkU3RyZWFtLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4LnR5cGUgPT09IFwiY2FuY2VsXCJ9KS50YWtlKDEpXG4gICAgdmFyIGFkZHMgPSBncm91cGVkU3RyZWFtLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4LnR5cGUgPT09IFwiYWRkXCIgfSlcbiAgICByZXR1cm4gYWRkcy50YWtlVW50aWwoY2FuY2VsKS5tYXAoXCIudmFsXCIpXG4gIH1cbiAgXG4gICAgIEJhY29uLnNlcXVlbnRpYWxseSgyLCBldmVudHMpXG4gICAgIC5ncm91cEJ5KGtleUYsIGxpbWl0RilcbiAgICAgLmZsYXRNYXAoZnVuY3Rpb24oZ3JvdXBlZFN0cmVhbSkge1xuICAgICAgcmV0dXJuIGdyb3VwZWRTdHJlYW0uZm9sZCgwLCBmdW5jdGlvbihhY2MsIHgpIHsgcmV0dXJuIGFjYyArIHggfSlcbiAgICB9KVxuICAgICAub25WYWx1ZShmdW5jdGlvbihzdW0pIHtcbiAgICAgIGNvbnNvbGUubG9nKHN1bSlcbiAgICAgIC8vIHJldHVybnMgWy0xLCAyLCA4XSBpbiBhbiBvcmRlclxuICAgIH0pXG4gICAgIGBgYFxuICBcbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuZ3JvdXBCeSA9IGZ1bmN0aW9uIChrZXlGLCBsaW1pdEYpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwQnkodGhpcywga2V5RiwgbGltaXRGKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBNYXBzIHZhbHVlcyB1c2luZyBnaXZlbiBmdW5jdGlvbiwgcmV0dXJuaW5nIGEgbmV3XG4gICAgIHN0cmVhbS9wcm9wZXJ0eS4gSW5zdGVhZCBvZiBhIGZ1bmN0aW9uLCB5b3UgY2FuIGFsc28gcHJvdmlkZSBhIFtQcm9wZXJ0eV0ocHJvcGVydHkuaHRtbCksXG4gICAgIGluIHdoaWNoIGNhc2UgZWFjaCBlbGVtZW50IGluIHRoZSBzb3VyY2Ugc3RyZWFtIHdpbGwgYmUgbWFwcGVkIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9mXG4gICAgIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIG1hcCQxKHRoaXMsIGYpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBQcm9wZXJ0eSB0aGF0IGludmVydHMgdGhlIHZhbHVlIG9mIHRoaXMgb25lICh1c2luZyB0aGUgYCFgIG9wZXJhdG9yKS4gKiovXG4gICAgUHJvcGVydHkucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5vdCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBDb21iaW5lcyBwcm9wZXJ0aWVzIHdpdGggdGhlIGB8fGAgb3BlcmF0b3IuIEl0IHByb2R1Y2VzIGEgbmV3IHZhbHVlIHdoZW4gZWl0aGVyIG9mIHRoZSBQcm9wZXJ0aWVzIGNoYW5nZSxcbiAgICAgY29tYmluaW5nIHRoZSBsYXRlc3QgdmFsdWVzIHVzaW5nIGB8fGAuXG4gICAgICovXG4gICAgUHJvcGVydHkucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvcih0aGlzLCBvdGhlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgQ3JlYXRlcyBhbiBFdmVudFN0cmVhbSBieSBzYW1wbGluZyB0aGVcbiAgICAgcHJvcGVydHkgdmFsdWUgYXQgZ2l2ZW4gaW50ZXJ2YWwgKGluIG1pbGxpc2Vjb25kcylcbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuc2FtcGxlID0gZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGVQKHRoaXMsIGludGVydmFsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgIEFkZHMgYW4gaW5pdGlhbCBcImRlZmF1bHRcIiB2YWx1ZSBmb3IgdGhlXG4gICAgUHJvcGVydHkuIElmIHRoZSBQcm9wZXJ0eSBkb2Vzbid0IGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSBvZiBpdCdzIG93biwgdGhlXG4gICAgZ2l2ZW4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlLiBJZiB0aGUgcHJvcGVydHkgaGFzIGFuXG4gICAgaW5pdGlhbCB2YWx1ZSBvZiBpdHMgb3duLCB0aGUgZ2l2ZW4gdmFsdWUgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIFByb3BlcnR5LnByb3RvdHlwZS5zdGFydFdpdGggPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICByZXR1cm4gc3RhcnRXaXRoUCh0aGlzLCBzZWVkKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgUHJvcGVydHkucHJvdG90eXBlLnN1YnNjcmliZUludGVybmFsID0gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgaWYgKHNpbmsgPT09IHZvaWQgMCkgeyBzaW5rID0gbnVsbFNpbms7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hlci5zdWJzY3JpYmUoc2luayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgQ3JlYXRlcyBhbiBFdmVudFN0cmVhbSBiYXNlZCBvbiB0aGlzIFByb3BlcnR5LiBUaGUgc3RyZWFtIGNvbnRhaW5zIGFsc28gYW4gZXZlbnQgZm9yIHRoZSBjdXJyZW50XG4gICAgIHZhbHVlIG9mIHRoaXMgUHJvcGVydHkgYXQgdGhlIHRpbWUgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUudG9FdmVudFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRTdHJlYW0obmV3IERlc2ModGhpcywgXCJ0b0V2ZW50U3RyZWFtXCIsIFtdKSwgZnVuY3Rpb24gKHNpbmspIHsgcmV0dXJuIF90aGlzLnN1YnNjcmliZUludGVybmFsKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQudG9OZXh0KCkpO1xuICAgICAgICB9KTsgfSwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBSZXR1cm5zIHRoZSBQcm9wZXJ0eSBpdHNlbGYuXG4gICAgICovXG4gICAgUHJvcGVydHkucHJvdG90eXBlLnRvUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFzc2VydE5vQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUHJvcGVydHkucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFuc2Zvcm1lciwgZGVzYykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUCh0aGlzLCB0cmFuc2Zvcm1lciwgZGVzYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgQ3JlYXRlcyBhbiBFdmVudFN0cmVhbS9Qcm9wZXJ0eSBieSBzYW1wbGluZyBhIGdpdmVuIGBzYW1wbGVlYFxuICAgICBzdHJlYW0vcHJvcGVydHkgdmFsdWUgYXQgZWFjaCBldmVudCBmcm9tIHRoZSB0aGlzIHN0cmVhbS9wcm9wZXJ0eS5cbiAgXG4gICAgIEBwYXJhbSB7T2JzZXJ2YWJsZTxWMj59IHNhbXBsZWVcbiAgICAgQHBhcmFtIGYgZnVuY3Rpb24gdG8gc2VsZWN0L2NhbGN1bGF0ZSB0aGUgcmVzdWx0IHZhbHVlIGJhc2VkIG9uIHRoZSB2YWx1ZSBpbiB0aGUgc291cmNlIHN0cmVhbSBhbmQgdGhlIHNhbXBsZWVcbiAgXG4gICAgIEB0eXBlcGFyYW0gVjIgIHR5cGUgb2YgdmFsdWVzIGluIHRoZSBzYW1wbGVlXG4gICAgIEB0eXBlcGFyYW0gUiAgIHR5cGUgb2YgdmFsdWVzIGluIHRoZSByZXN1bHRcbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUud2l0aExhdGVzdEZyb20gPSBmdW5jdGlvbiAoc2FtcGxlZSwgZikge1xuICAgICAgICByZXR1cm4gd2l0aExhdGVzdEZyb21QKHRoaXMsIHNhbXBsZWUsIGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgIExldHMgeW91IHJ1biBhIHN0YXRlIG1hY2hpbmVcbiAgICAgb24gYW4gb2JzZXJ2YWJsZS4gR2l2ZSBpdCBhbiBpbml0aWFsIHN0YXRlIG9iamVjdCBhbmQgYSBzdGF0ZVxuICAgICB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBlYWNoIGluY29taW5nIGV2ZW50IGFuZFxuICAgICByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG5leHQgc3RhdGUgYW5kIGFuIGFycmF5IG9mIG91dHB1dFxuICAgICBldmVudHMuIEhlcmUncyBhbiBleGFtcGxlIHdoZXJlIHdlIGNhbGN1bGF0ZSB0aGUgdG90YWwgc3VtIG9mIGFsbFxuICAgICBudW1iZXJzIGluIHRoZSBzdHJlYW0gYW5kIG91dHB1dCB0aGUgdmFsdWUgb24gc3RyZWFtIGVuZDpcbiAgXG4gICAgIGBgYGpzXG4gICAgIEJhY29uLmZyb21BcnJheShbMSwyLDNdKVxuICAgICAud2l0aFN0YXRlTWFjaGluZSgwLCBmdW5jdGlvbihzdW0sIGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuaGFzVmFsdWUpXG4gICAgICAgIHJldHVybiBbc3VtICsgZXZlbnQudmFsdWUsIFtdXVxuICAgICAgZWxzZSBpZiAoZXZlbnQuaXNFbmQpXG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCBbbmV3IEJhY29uLk5leHQoc3VtKSwgZXZlbnRdXVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gW3N1bSwgW2V2ZW50XV1cbiAgICB9KVxuICAgICBgYGBcbiAgICAgQHBhcmFtIGluaXRTdGF0ZSAgaW5pdGlhbCBzdGF0ZSBmb3IgdGhlIHN0YXRlIG1hY2hpbmVcbiAgICAgQHBhcmFtIGYgICAgICAgICAgdGhlIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyB0aGUgc3RhdGUgbWFjaGluZVxuICAgICBAdHlwZXBhcmFtICBTdGF0ZSAgIHR5cGUgb2YgbWFjaGluZSBzdGF0ZVxuICAgICBAdHlwZXBhcmFtICBPdXQgICAgIHR5cGUgb2YgdmFsdWVzIHRvIGJlIGVtaXR0ZWRcbiAgICAgKi9cbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUud2l0aFN0YXRlTWFjaGluZSA9IGZ1bmN0aW9uIChpbml0U3RhdGUsIGYpIHtcbiAgICAgICAgcmV0dXJuIHdpdGhTdGF0ZU1hY2hpbmUoaW5pdFN0YXRlLCBmLCB0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBQcm9wZXJ0eTtcbn0oT2JzZXJ2YWJsZSkpO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIGlzUHJvcGVydHkoeCkge1xuICAgIHJldHVybiAhIXguX2lzUHJvcGVydHk7XG59XG4vLyBhbGxvd1N5bmMgb3B0aW9uIGlzIHVzZWQgZm9yIG92ZXJyaWRpbmcgdGhlIFwiZm9yY2UgYXN5bmNcIiBiZWhhdmlvdXIgb3IgRXZlbnRTdHJlYW1zLlxuLy8gaWRlYWxseSwgdGhpcyBzaG91bGQgbm90IGV4aXN0LCBidXQgcmlnaHQgbm93IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBzb21lIG9wZXJhdGlvbnNcbi8vIHJlbGllcyBvbiB1c2luZyBpbnRlcm5hbCBFdmVudFN0cmVhbXMgdGhhdCBoYXZlIHN5bmNocm9ub3VzIGJlaGF2aW9yLiBUaGVzZSBhcmUgbm90IGV4cG9zZWRcbi8vIHRvIHRoZSBvdXRzaWRlIHdvcmxkLCB0aG91Z2guXG4vKiogQGhpZGRlbiAqL1xudmFyIGFsbG93U3luYyA9IHsgZm9yY2VBc3luYzogZmFsc2UgfTtcbi8qKlxuICogRXZlbnRTdHJlYW0gcmVwcmVzZW50cyBhIHN0cmVhbSBvZiBldmVudHMuIEl0IGlzIGFuIE9ic2VydmFibGUgb2JqZWN0LCBtZWFuaW5nXG4gdGhhdCB5b3UgY2FuIGxpc3RlbiB0byBldmVudHMgaW4gdGhlIHN0cmVhbSB1c2luZywgZm9yIGluc3RhbmNlLCB0aGUgW2BvblZhbHVlYF0oI29udmFsdWUpIG1ldGhvZFxuIHdpdGggYSBjYWxsYmFjay5cblxuIFRvIGNyZWF0ZSBhbiBFdmVudFN0cmVhbSwgeW91J2xsIHdhbnQgdG8gdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZhY3RvcnkgbWV0aG9kczpcblxuICAtIEZyb20gRE9NIEV2ZW50VGFyZ2V0IG9yIE5vZGUuSlMgRXZlbnRFbWl0dGVyIG9iamVjdHMgdXNpbmcgW2Zyb21FdmVudF0oLi4vZ2xvYmFscy5odG1sI2Zyb21ldmVudClcbiAgLSBGcm9tIGEgUHJvbWlzZSB1c2luZyBbZnJvbVByb21pc2VdKC4uL2dsb2JhbHMuaHRtbCNmcm9tcHJvbWlzZSlcbiAgLSBGcm9tIGFuIHVuYXJ5IGNhbGxiYWNrIHVzaW5nIFtmcm9tQ2FsbGJhY2tdKC4uL2dsb2JhbHMuaHRtbCNmcm9tY2FsbGJhY2spXG4gIC0gRnJvbSBhIE5vZGUuanMgc3R5bGUgY2FsbGJhY2sgdXNpbmcgW2Zyb21Ob2RlQ2FsbGJhY2tdKC4uL2dsb2JhbHMuaHRtbCNmcm9tbm9kZWNhbGxiYWNrKVxuICAtIEZyb20gUnhKcyBvciBLZWZpciBvYnNlcnZhYmxlcyB1c2luZyBbZnJvbUVTT2JzZXJ2YWJsZV0oLi4vZ2xvYmFscy5odG1sI2Zyb21lc29ic2VydmFibGUpXG4gIC0gQnkgcG9sbGluZyBhIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHVzaW5nIFtmcm9tUG9sbF0oLi4vZ2xvYmFscy5odG1sI2Zyb21Qb2xsKVxuICAtIEVtaXQgYSBzaW5nbGUgZXZlbnQgaW5zdGFudGx5IHVzaW5nIFtvbmNlXSguLi9nbG9iYWxzLmh0bWwjb25jZSlcbiAgLSBFbWl0IGEgc2luZ2xlIGV2ZW50IHdpdGggYSBkZWxheSBbbGF0ZXJdKC4uL2dsb2JhbHMuaHRtbCNsYXRlcilcbiAgLSBFbWl0IHRoZSBzYW1lIGV2ZW50IGluZGVmaW5pdGVseSB1c2luZyBbaW50ZXJ2YWxdKC4uL2dsb2JhbHMuaHRtbCNpbnRlcnZhbClcbiAgLSBFbWl0IGFuIGFycmF5IG9mIGV2ZW50cyBpbnN0YW50bHkgW2Zyb21BcnJheV0oLi4vZ2xvYmFscy5odG1sI2Zyb21hcnJheSlcbiAgLSBFbWl0IGFuIGFycmF5IG9mIGV2ZW50cyB3aXRoIGEgZGVsYXkgW3NlcXVlbnRpYWxseV0oLi4vZ2xvYmFscy5odG1sI3NlcXVlbnRpYWxseSlcbiAgLSBFbWl0IGFuIGFycmF5IG9mIGV2ZW50cyByZXBlYXRlZGx5IHdpdGggYSBkZWxheSBbcmVwZWF0ZWRseV0oLi4vZ2xvYmFscy5odG1sI3JlcGVhdGVkbHkpXG4gIC0gVXNlIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCByZXBlYXRlZGx5IFtyZXBlYXRdKC4uL2dsb2JhbHMuaHRtbCNyZXBlYXQpXG4gIC0gQ3JlYXRlIGEgc3RyZWFtIHRoYXQgbmV2ZXIgZW1pdHMgYW4gZXZlbnQsIGVuZGluZyBpbW1lZGlhdGVseSBbbmV2ZXJdKC4uL2dsb2JhbHMuaHRtbCNuZXZlcilcbiAgLSBDcmVhdGUgYSBzdHJlYW0gdGhhdCBuZXZlciBlbWl0cyBhbiBldmVudCwgZW5kaW5nIHdpdGggYSBkZWxheSBbc2lsZW5jZV0oLi4vZ2xvYmFscy5odG1sI3NpbGVuY2UpXG4gIC0gQ3JlYXRlIHN0cmVhbSB1c2luZyBhIGN1c3RvbSBiaW5kZXIgZnVuY3Rpb24gW2Zyb21CaW5kZXJdKC4uL2dsb2JhbHMuaHRtbCNmcm9tYmluZGVyKVxuICAtIFdyYXAgalF1ZXJ5IGV2ZW50cyB1c2luZyBbYXNFdmVudFN0cmVhbV0oLi4vZ2xvYmFscy5odG1sI18pXG5cblxuIEB0eXBlcGFyYW0gViAgIFR5cGUgb2YgdGhlIGVsZW1lbnRzL3ZhbHVlcyBpbiB0aGUgc3RyZWFtL3Byb3BlcnR5XG5cbiAqL1xudmFyIEV2ZW50U3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFdmVudFN0cmVhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudFN0cmVhbShkZXNjLCBzdWJzY3JpYmUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzYykgfHwgdGhpcztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgX3RoaXMuX2lzRXZlbnRTdHJlYW0gPSB0cnVlO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gYWxsb3dTeW5jKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUgPSBhc3luY1dyYXBTdWJzY3JpYmUoX3RoaXMsIHN1YnNjcmliZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZGlzcGF0Y2hlciA9IG5ldyBEaXNwYXRjaGVyKF90aGlzLCBzdWJzY3JpYmUsIGhhbmRsZXIpO1xuICAgICAgICByZWdpc3Rlck9icyhfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgIEJ1ZmZlcnMgc3RyZWFtIGV2ZW50cyB3aXRoIGdpdmVuIGRlbGF5LlxuICAgICBUaGUgYnVmZmVyIGlzIGZsdXNoZWQgYXQgbW9zdCBvbmNlIGluIHRoZSBnaXZlbiBpbnRlcnZhbC4gU28sIGlmIHlvdXIgaW5wdXRcbiAgICAgY29udGFpbnMgWzEsMiwzLDQsNSw2LDddLCB0aGVuIHlvdSBtaWdodCBnZXQgdHdvIGV2ZW50cyBjb250YWluaW5nIFsxLDIsMyw0XVxuICAgICBhbmQgWzUsNiw3XSByZXNwZWN0aXZlbHksIGdpdmVuIHRoYXQgdGhlIGZsdXNoIG9jY3VycyBiZXR3ZWVuIG51bWJlcnMgNCBhbmQgNS5cbiAgXG4gICAgIEFsc28gd29ya3Mgd2l0aCBhIGdpdmVuIFwiZGVmZXItZnVuY3Rpb25cIiBpbnN0ZWFkXG4gICAgIG9mIGEgZGVsYXkuIEhlcmUncyBhIHNpbXBsZSBleGFtcGxlLCB3aGljaCBpcyBlcXVpdmFsZW50IHRvXG4gICAgIHN0cmVhbS5idWZmZXJXaXRoVGltZSgxMCk6XG4gIFxuICAgICBgYGBqc1xuICAgICBzdHJlYW0uYnVmZmVyV2l0aFRpbWUoZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDEwKSB9KVxuICAgICBgYGBcbiAgXG4gICAgICogQHBhcmFtIGRlbGF5IGJ1ZmZlciBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUuYnVmZmVyV2l0aFRpbWUgPSBmdW5jdGlvbiAoZGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcldpdGhUaW1lKHRoaXMsIGRlbGF5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBCdWZmZXJzIHN0cmVhbSBldmVudHMgd2l0aCBnaXZlbiBjb3VudC5cbiAgICAgVGhlIGJ1ZmZlciBpcyBmbHVzaGVkIHdoZW4gaXQgY29udGFpbnMgdGhlIGdpdmVuIG51bWJlciBvZiBlbGVtZW50cyBvciB0aGUgc291cmNlIHN0cmVhbSBlbmRzLlxuICBcbiAgICAgU28sIGlmIHlvdSBidWZmZXIgYSBzdHJlYW0gb2YgYFsxLCAyLCAzLCA0LCA1XWAgd2l0aCBjb3VudCBgMmAsIHlvdSdsbCBnZXQgb3V0cHV0XG4gICAgIGV2ZW50cyB3aXRoIHZhbHVlcyBgWzEsIDJdYCwgYFszLCA0XWAgYW5kIGBbNV1gLlxuICBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRcbiAgICAgKi9cbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUuYnVmZmVyV2l0aENvdW50ID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIHJldHVybiBidWZmZXJXaXRoQ291bnQodGhpcywgY291bnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgIEJ1ZmZlcnMgc3RyZWFtIGV2ZW50cyBhbmRcbiAgICAgZmx1c2hlcyB3aGVuIGVpdGhlciB0aGUgYnVmZmVyIGNvbnRhaW5zIHRoZSBnaXZlbiBudW1iZXIgZWxlbWVudHMgb3IgdGhlXG4gICAgIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgaGFzIHBhc3NlZCBzaW5jZSBsYXN0IGJ1ZmZlcmVkIGV2ZW50LlxuICBcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IERlbGF5RnVuY3Rpb259IGRlbGF5IGluIG1pbGxpc2Vjb25kcyBvciBhcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50ICBtYXhpbXVtIGJ1ZmZlciBzaXplXG4gICAgICovXG4gICAgRXZlbnRTdHJlYW0ucHJvdG90eXBlLmJ1ZmZlcldpdGhUaW1lT3JDb3VudCA9IGZ1bmN0aW9uIChkZWxheSwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcldpdGhUaW1lT3JDb3VudCh0aGlzLCBkZWxheSwgY291bnQpO1xuICAgIH07XG4gICAgRXZlbnRTdHJlYW0ucHJvdG90eXBlLmNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRXZlbnRTdHJlYW0ucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChvdGhlciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29uY2F0RSh0aGlzLCBvdGhlciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS50cmFuc2Zvcm1DaGFuZ2VzID0gZnVuY3Rpb24gKGRlc2MsIGYpIHtcbiAgICAgICAgcmV0dXJuIGYodGhpcykud2l0aERlc2MoZGVzYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc291cmNlIHN0cmVhbSwgc3Bhd24gYSBuZXdcbiAgICAgc3RyZWFtL3Byb3BlcnR5IHVzaW5nIHRoZSBmdW5jdGlvbiBgZmAuIENvbGxlY3QgZXZlbnRzIGZyb20gZWFjaCBvZiB0aGUgc3Bhd25lZFxuICAgICBzdHJlYW1zIGludG8gdGhlIHJlc3VsdCBzdHJlYW0vcHJvcGVydHkuIE5vdGUgdGhhdCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24sIHlvdSBjYW4gcHJvdmlkZSBhXG4gICAgIHN0cmVhbS9wcm9wZXJ0eSB0b28uIEFsc28sIHRoZSByZXR1cm4gdmFsdWUgb2YgZnVuY3Rpb24gYGZgIGNhbiBiZSBlaXRoZXIgYW5cbiAgICAgYE9ic2VydmFibGVgIChzdHJlYW0vcHJvcGVydHkpIG9yIGEgY29uc3RhbnQgdmFsdWUuXG4gIFxuICAgICBgc3RyZWFtLmZsYXRNYXAoKWAgY2FuIGJlIHVzZWQgY29udmVuaWVudGx5IHdpdGggW2BCYWNvbi5vbmNlKClgXSguLi9nbG9iYWxzLmh0bWwjb25jZSkgYW5kIFtgQmFjb24ubmV2ZXIoKWBdKC4uL2dsb2JhbHMuaHRtbCNuZXZlcilcbiAgICAgZm9yIGNvbnZlcnRpbmcgYW5kIGZpbHRlcmluZyBhdCB0aGUgc2FtZSB0aW1lLCBpbmNsdWRpbmcgb25seSBzb21lIG9mIHRoZSByZXN1bHRzLlxuICBcbiAgICAgRXhhbXBsZSAtIGNvbnZlcnRpbmcgc3RyaW5ncyB0byBpbnRlZ2Vycywgc2tpcHBpbmcgZW1wdHkgdmFsdWVzOlxuICBcbiAgICAgYGBganNcbiAgICAgc3RyZWFtLmZsYXRNYXAoZnVuY3Rpb24odGV4dCkge1xuICAgICAgcmV0dXJuICh0ZXh0ICE9IFwiXCIpID8gcGFyc2VJbnQodGV4dCkgOiBCYWNvbi5uZXZlcigpXG4gIH0pXG4gICAgIGBgYFxuICAgICAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS5mbGF0TWFwID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZsYXRNYXAkMSh0aGlzLCBmKTsgfTtcbiAgICAvKipcbiAgICAgQSBbYGZsYXRNYXBXaXRoQ29uY3VycmVuY3lMaW1pdGBdKCNmbGF0bWFwd2l0aGNvbmN1cnJlbmN5bGltaXQpIHdpdGggbGltaXQgb2YgMS5cbiAgICAgKi9cbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUuZmxhdE1hcENvbmNhdCA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmbGF0TWFwQ29uY2F0KHRoaXMsIGYpOyB9O1xuICAgIC8qKlxuICAgICBMaWtlIFtgZmxhdE1hcGBdKCNmbGF0bWFwKSwgYnV0IGlzIGFwcGxpZWQgb25seSBvbiBbYEVycm9yYF0oZXJyb3IuaHRtbCkgZXZlbnRzLiBSZXR1cm5lZCB2YWx1ZXMgZ28gaW50byB0aGVcbiAgICAgdmFsdWUgc3RyZWFtLCB1bmxlc3MgYW4gZXJyb3IgZXZlbnQgaXMgcmV0dXJuZWQuIEFzIGFuIGV4YW1wbGUsIG9uZSB0eXBlIG9mIGVycm9yIGNvdWxkIHJlc3VsdCBpbiBhIHJldHJ5IGFuZCBhbm90aGVyIGp1c3RcbiAgICAgcGFzc2VkIHRocm91Z2gsIHdoaWNoIGNhbiBiZSBpbXBsZW1lbnRlZCB1c2luZyBmbGF0TWFwRXJyb3IuXG4gICAgICovXG4gICAgRXZlbnRTdHJlYW0ucHJvdG90eXBlLmZsYXRNYXBFcnJvciA9IGZ1bmN0aW9uIChmKSB7IHJldHVybiBmbGF0TWFwRXJyb3IodGhpcywgZik7IH07XG4gICAgLyoqXG4gICAgIExpa2UgW2BmbGF0TWFwYF0oI29ic2VydmFibGUtZmxhdG1hcCksIGJ1dCBvbmx5IHNwYXducyBhIG5ld1xuICAgICBzdHJlYW0gaWYgdGhlIHByZXZpb3VzbHkgc3Bhd25lZCBzdHJlYW0gaGFzIGVuZGVkLlxuICAgICAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS5mbGF0TWFwRmlyc3QgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZmxhdE1hcEZpcnN0KHRoaXMsIGYpOyB9O1xuICAgIC8qKlxuICAgICBMaWtlIFtgZmxhdE1hcGBdKCNmbGF0bWFwKSwgYnV0IGluc3RlYWQgb2YgaW5jbHVkaW5nIGV2ZW50cyBmcm9tXG4gICAgIGFsbCBzcGF3bmVkIHN0cmVhbXMsIG9ubHkgaW5jbHVkZXMgdGhlbSBmcm9tIHRoZSBsYXRlc3Qgc3Bhd25lZCBzdHJlYW0uXG4gICAgIFlvdSBjYW4gdGhpbmsgdGhpcyBhcyBzd2l0Y2hpbmcgZnJvbSBzdHJlYW0gdG8gc3RyZWFtLlxuICAgICBOb3RlIHRoYXQgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uLCB5b3UgY2FuIHByb3ZpZGUgYSBzdHJlYW0vcHJvcGVydHkgdG9vLlxuICAgICAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS5mbGF0TWFwTGF0ZXN0ID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGZsYXRNYXBMYXRlc3QodGhpcywgZik7IH07XG4gICAgLyoqXG4gICAgIEEgc3VwZXIgbWV0aG9kIG9mICpmbGF0TWFwKiBmYW1pbHkuIEl0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG9wZW4gc3Bhd25lZCBzdHJlYW1zIGFuZCBidWZmZXJzIGluY29taW5nIGV2ZW50cy5cbiAgICAgW2BmbGF0TWFwQ29uY2F0YF0oI2ZsYXRtYXBjb25jYXQpIGlzIGBmbGF0TWFwV2l0aENvbmN1cnJlbmN5TGltaXQoMSlgIChvbmx5IG9uZSBpbnB1dCBhY3RpdmUpLFxuICAgICBhbmQgW2BmbGF0TWFwYF0oI2ZsYXRtYXApIGlzIGBmbGF0TWFwV2l0aENvbmN1cnJlbmN5TGltaXQg4oieYCAoYWxsIGlucHV0cyBhcmUgcGlwZWQgdG8gb3V0cHV0KS5cbiAgICAgKi9cbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUuZmxhdE1hcFdpdGhDb25jdXJyZW5jeUxpbWl0ID0gZnVuY3Rpb24gKGxpbWl0LCBmKSB7IHJldHVybiBmbGF0TWFwV2l0aENvbmN1cnJlbmN5TGltaXQodGhpcywgbGltaXQsIGYpOyB9O1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS5mbGF0TWFwRXZlbnQgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gZmxhdE1hcEV2ZW50KHRoaXMsIGYpOyB9O1xuICAgIC8qKlxuICAgICBTY2FucyBzdHJlYW0gd2l0aCBnaXZlbiBzZWVkIHZhbHVlIGFuZCBhY2N1bXVsYXRvciBmdW5jdGlvbiwgcmVzdWx0aW5nIHRvIGEgUHJvcGVydHkuXG4gICAgIERpZmZlcmVuY2UgdG8gW2BzY2FuYF0oI3NjYW4pIGlzIHRoYXQgdGhlIGZ1bmN0aW9uIGBmYCBjYW4gcmV0dXJuIGFuIFtgRXZlbnRTdHJlYW1gXShldmVudHN0cmVhbS5odG1sKSBvciBhIFtgUHJvcGVydHlgXShwcm9wZXJ0eS5odG1sKSBpbnN0ZWFkXG4gICAgIG9mIGEgcHVyZSB2YWx1ZSwgbWVhbmluZyB0aGF0IHlvdSBjYW4gdXNlIFtgZmxhdFNjYW5gXSgjZmxhdHNjYW4pIGZvciBhc3luY2hyb25vdXMgdXBkYXRlcyBvZiBzdGF0ZS4gSXQgc2VyaWFsaXplc1xuICAgICB1cGRhdGVzIHNvIHRoYXQgdGhhdCB0aGUgbmV4dCB1cGRhdGUgd2lsbCBiZSBxdWV1ZWQgdW50aWwgdGhlIHByZXZpb3VzIG9uZSBoYXMgY29tcGxldGVkLlxuICBcbiAgICAgKiBAcGFyYW0gc2VlZCBpbml0aWFsIHZhbHVlIHRvIHN0YXJ0IHdpdGhcbiAgICAgKiBAcGFyYW0gZiB0cmFuc2l0aW9uIGZ1bmN0aW9uIGZyb20gcHJldmlvdXMgc3RhdGUgYW5kIG5ldyB2YWx1ZSB0byBuZXh0IHN0YXRlXG4gICAgICogQHR5cGVwYXJhbSBWMiBzdGF0ZSBhbmQgcmVzdWx0IHR5cGVcbiAgICAgKi9cbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUuZmxhdFNjYW4gPSBmdW5jdGlvbiAoc2VlZCwgZikge1xuICAgICAgICByZXR1cm4gZmxhdFNjYW4odGhpcywgc2VlZCwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgR3JvdXBzIHN0cmVhbSBldmVudHMgdG8gbmV3IHN0cmVhbXMgYnkgYGtleUZgLiBPcHRpb25hbCBgbGltaXRGYCBjYW4gYmUgcHJvdmlkZWQgdG8gbGltaXQgZ3JvdXBlZFxuICAgICBzdHJlYW0gbGlmZS4gU3RyZWFtIHRyYW5zZm9ybWVkIGJ5IGBsaW1pdEZgIGlzIHBhc3NlZCBvbiBpZiBwcm92aWRlZC4gYGxpbWl0RmAgZ2V0cyBncm91cGVkIHN0cmVhbVxuICAgICBhbmQgdGhlIG9yaWdpbmFsIGV2ZW50IGNhdXNpbmcgdGhlIHN0cmVhbSB0byBzdGFydCBhcyBwYXJhbWV0ZXJzLlxuICBcbiAgICAgQ2FsY3VsYXRvciBmb3IgZ3JvdXBlZCBjb25zZWN1dGl2ZSB2YWx1ZXMgdW50aWwgZ3JvdXAgaXMgY2FuY2VsbGVkOlxuICBcbiAgICAgYGBgXG4gICAgIHZhciBldmVudHMgPSBbXG4gICAgIHtpZDogMSwgdHlwZTogXCJhZGRcIiwgdmFsOiAzIH0sXG4gICAgIHtpZDogMiwgdHlwZTogXCJhZGRcIiwgdmFsOiAtMSB9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiYWRkXCIsIHZhbDogMiB9LFxuICAgICB7aWQ6IDIsIHR5cGU6IFwiY2FuY2VsXCJ9LFxuICAgICB7aWQ6IDMsIHR5cGU6IFwiYWRkXCIsIHZhbDogMiB9LFxuICAgICB7aWQ6IDMsIHR5cGU6IFwiY2FuY2VsXCJ9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiYWRkXCIsIHZhbDogMSB9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiYWRkXCIsIHZhbDogMiB9LFxuICAgICB7aWQ6IDEsIHR5cGU6IFwiY2FuY2VsXCJ9XG4gICAgIF1cbiAgXG4gICAgIGZ1bmN0aW9uIGtleUYoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuaWRcbiAgfVxuICBcbiAgICAgZnVuY3Rpb24gbGltaXRGKGdyb3VwZWRTdHJlYW0sIGdyb3VwU3RhcnRpbmdFdmVudCkge1xuICAgIHZhciBjYW5jZWwgPSBncm91cGVkU3RyZWFtLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4LnR5cGUgPT09IFwiY2FuY2VsXCJ9KS50YWtlKDEpXG4gICAgdmFyIGFkZHMgPSBncm91cGVkU3RyZWFtLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4LnR5cGUgPT09IFwiYWRkXCIgfSlcbiAgICByZXR1cm4gYWRkcy50YWtlVW50aWwoY2FuY2VsKS5tYXAoXCIudmFsXCIpXG4gIH1cbiAgXG4gICAgIEJhY29uLnNlcXVlbnRpYWxseSgyLCBldmVudHMpXG4gICAgIC5ncm91cEJ5KGtleUYsIGxpbWl0RilcbiAgICAgLmZsYXRNYXAoZnVuY3Rpb24oZ3JvdXBlZFN0cmVhbSkge1xuICAgICAgcmV0dXJuIGdyb3VwZWRTdHJlYW0uZm9sZCgwLCBmdW5jdGlvbihhY2MsIHgpIHsgcmV0dXJuIGFjYyArIHggfSlcbiAgICB9KVxuICAgICAub25WYWx1ZShmdW5jdGlvbihzdW0pIHtcbiAgICAgIGNvbnNvbGUubG9nKHN1bSlcbiAgICAgIC8vIHJldHVybnMgWy0xLCAyLCA4XSBpbiBhbiBvcmRlclxuICAgIH0pXG4gICAgIGBgYFxuICBcbiAgICAgKi9cbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUuZ3JvdXBCeSA9IGZ1bmN0aW9uIChrZXlGLCBsaW1pdEYpIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwQnkodGhpcywga2V5RiwgbGltaXRGKTtcbiAgICB9O1xuICAgIC8qKlxuICAgTWFwcyB2YWx1ZXMgdXNpbmcgZ2l2ZW4gZnVuY3Rpb24sIHJldHVybmluZyBhIG5ld1xuICAgc3RyZWFtL3Byb3BlcnR5LiBJbnN0ZWFkIG9mIGEgZnVuY3Rpb24sIHlvdSBjYW4gYWxzbyBwcm92aWRlIGEgW1Byb3BlcnR5XShwcm9wZXJ0eS5odG1sKSxcbiAgIGluIHdoaWNoIGNhc2UgZWFjaCBlbGVtZW50IGluIHRoZSBzb3VyY2Ugc3RyZWFtIHdpbGwgYmUgbWFwcGVkIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9mXG4gICB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gbWFwJDEodGhpcywgZik7XG4gICAgfTtcbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0RXZlbnRTdHJlYW0ob3RoZXIpO1xuICAgICAgICByZXR1cm4gbWVyZ2VBbGwodGhpcywgb3RoZXIpLndpdGhEZXNjKG5ldyBEZXNjKHRoaXMsIFwibWVyZ2VcIiwgW290aGVyXSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgIFJldHVybnMgYSBzdHJlYW0vcHJvcGVydHkgdGhhdCBpbnZlcnRzIGJvb2xlYW4gdmFsdWVzICh1c2luZyBgIWApXG4gICAgICovXG4gICAgRXZlbnRTdHJlYW0ucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5vdCh0aGlzKTsgfTtcbiAgICAvKipcbiAgICAgQWRkcyBhIHN0YXJ0aW5nIHZhbHVlIHRvIHRoZSBzdHJlYW0vcHJvcGVydHksIGkuZS4gY29uY2F0cyBhXG4gICAgIHNpbmdsZS1lbGVtZW50IHN0cmVhbSBjb250YWluaW5nIHRoZSBzaW5nbGUgc2VlZCB2YWx1ZSAgd2l0aCB0aGlzIHN0cmVhbS5cbiAgICAgKi9cbiAgICAvLyBUT0RPOiBzaG91bGQgYWxsb3cgVnxWMiBzaWduYXR1cmVcbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUuc3RhcnRXaXRoID0gZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0V2l0aEUodGhpcywgc2VlZCk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS5zdWJzY3JpYmVJbnRlcm5hbCA9IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgIGlmIChzaW5rID09PSB2b2lkIDApIHsgc2luayA9IG51bGxTaW5rOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoZXIuc3Vic2NyaWJlKHNpbmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIHN0cmVhbS5cbiAgICAgKi9cbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUudG9FdmVudFN0cmVhbSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqXG4gICAgIENyZWF0ZXMgYSBQcm9wZXJ0eSBiYXNlZCBvbiB0aGVcbiAgICAgRXZlbnRTdHJlYW0uXG4gIFxuICAgICBXaXRob3V0IGFyZ3VtZW50cywgeW91J2xsIGdldCBhIFByb3BlcnR5IHdpdGhvdXQgYW4gaW5pdGlhbCB2YWx1ZS5cbiAgICAgVGhlIFByb3BlcnR5IHdpbGwgZ2V0IGl0cyBmaXJzdCBhY3R1YWwgdmFsdWUgZnJvbSB0aGUgc3RyZWFtLCBhbmQgYWZ0ZXIgdGhhdCBpdCdsbFxuICAgICBhbHdheXMgaGF2ZSBhIGN1cnJlbnQgdmFsdWUuXG4gIFxuICAgICBZb3UgY2FuIGFsc28gZ2l2ZSBhbiBpbml0aWFsIHZhbHVlIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBjdXJyZW50IHZhbHVlIHVudGlsXG4gICAgIHRoZSBmaXJzdCB2YWx1ZSBjb21lcyBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgRXZlbnRTdHJlYW0ucHJvdG90eXBlLnRvUHJvcGVydHkgPSBmdW5jdGlvbiAoaW5pdFZhbHVlKSB7XG4gICAgICAgIHZhciB1c2VkSW5pdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgPyB0b09wdGlvbihpbml0VmFsdWUpXG4gICAgICAgICAgICA6IG5vbmUoKTtcbiAgICAgICAgdmFyIGRpc3AgPSB0aGlzLmRpc3BhdGNoZXI7XG4gICAgICAgIHZhciBkZXNjID0gbmV3IERlc2ModGhpcywgXCJ0b1Byb3BlcnR5XCIsIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIHN0cmVhbVN1YnNjcmliZSA9IGRpc3Auc3Vic2NyaWJlO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5KGRlc2MsIHN0cmVhbVN1YnNjcmliZVRvUHJvcGVydHlTdWJzY3JpYmUodXNlZEluaXRWYWx1ZSwgc3RyZWFtU3Vic2NyaWJlKSk7XG4gICAgfTtcbiAgICBFdmVudFN0cmVhbS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zZm9ybWVyLCBkZXNjKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1FKHRoaXMsIHRyYW5zZm9ybWVyLCBkZXNjKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICBDcmVhdGVzIGFuIEV2ZW50U3RyZWFtL1Byb3BlcnR5IGJ5IHNhbXBsaW5nIGEgZ2l2ZW4gYHNhbXBsZWVgXG4gICAgIHN0cmVhbS9wcm9wZXJ0eSB2YWx1ZSBhdCBlYWNoIGV2ZW50IGZyb20gdGhlIHRoaXMgc3RyZWFtL3Byb3BlcnR5LlxuICBcbiAgICAgQHBhcmFtIHtPYnNlcnZhYmxlPFYyPn0gc2FtcGxlZVxuICAgICBAcGFyYW0gZiBmdW5jdGlvbiB0byBzZWxlY3QvY2FsY3VsYXRlIHRoZSByZXN1bHQgdmFsdWUgYmFzZWQgb24gdGhlIHZhbHVlIGluIHRoZSBzb3VyY2Ugc3RyZWFtIGFuZCB0aGUgc2FtcGxlZVxuICBcbiAgICAgQHR5cGVwYXJhbSBWMiAgdHlwZSBvZiB2YWx1ZXMgaW4gdGhlIHNhbXBsZWVcbiAgICAgQHR5cGVwYXJhbSBSICAgdHlwZSBvZiB2YWx1ZXMgaW4gdGhlIHJlc3VsdFxuICAgICAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS53aXRoTGF0ZXN0RnJvbSA9IGZ1bmN0aW9uIChzYW1wbGVlLCBmKSB7XG4gICAgICAgIHJldHVybiB3aXRoTGF0ZXN0RnJvbUUodGhpcywgc2FtcGxlZSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgTGV0cyB5b3UgcnVuIGEgc3RhdGUgbWFjaGluZVxuICAgICBvbiBhbiBvYnNlcnZhYmxlLiBHaXZlIGl0IGFuIGluaXRpYWwgc3RhdGUgb2JqZWN0IGFuZCBhIHN0YXRlXG4gICAgIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGVhY2ggaW5jb21pbmcgZXZlbnQgYW5kXG4gICAgIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbmV4dCBzdGF0ZSBhbmQgYW4gYXJyYXkgb2Ygb3V0cHV0XG4gICAgIGV2ZW50cy4gSGVyZSdzIGFuIGV4YW1wbGUgd2hlcmUgd2UgY2FsY3VsYXRlIHRoZSB0b3RhbCBzdW0gb2YgYWxsXG4gICAgIG51bWJlcnMgaW4gdGhlIHN0cmVhbSBhbmQgb3V0cHV0IHRoZSB2YWx1ZSBvbiBzdHJlYW0gZW5kOlxuICBcbiAgICAgYGBganNcbiAgICAgQmFjb24uZnJvbUFycmF5KFsxLDIsM10pXG4gICAgIC53aXRoU3RhdGVNYWNoaW5lKDAsIGZ1bmN0aW9uKHN1bSwgZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5oYXNWYWx1ZSlcbiAgICAgICAgcmV0dXJuIFtzdW0gKyBldmVudC52YWx1ZSwgW11dXG4gICAgICBlbHNlIGlmIChldmVudC5pc0VuZClcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIFtuZXcgQmFjb24uTmV4dChzdW0pLCBldmVudF1dXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBbc3VtLCBbZXZlbnRdXVxuICAgIH0pXG4gICAgIGBgYFxuICAgICBAcGFyYW0gaW5pdFN0YXRlICBpbml0aWFsIHN0YXRlIGZvciB0aGUgc3RhdGUgbWFjaGluZVxuICAgICBAcGFyYW0gZiAgICAgICAgICB0aGUgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIHRoZSBzdGF0ZSBtYWNoaW5lXG4gICAgIEB0eXBlcGFyYW0gIFN0YXRlICAgdHlwZSBvZiBtYWNoaW5lIHN0YXRlXG4gICAgIEB0eXBlcGFyYW0gIE91dCAgICAgdHlwZSBvZiB2YWx1ZXMgdG8gYmUgZW1pdHRlZFxuICAgICAqL1xuICAgIEV2ZW50U3RyZWFtLnByb3RvdHlwZS53aXRoU3RhdGVNYWNoaW5lID0gZnVuY3Rpb24gKGluaXRTdGF0ZSwgZikge1xuICAgICAgICByZXR1cm4gd2l0aFN0YXRlTWFjaGluZShpbml0U3RhdGUsIGYsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50U3RyZWFtO1xufShPYnNlcnZhYmxlKSk7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbmV3RXZlbnRTdHJlYW0oZGVzY3JpcHRpb24sIHN1YnNjcmliZSkge1xuICAgIHJldHVybiBuZXcgRXZlbnRTdHJlYW0oZGVzY3JpcHRpb24sIHN1YnNjcmliZSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gbmV3RXZlbnRTdHJlYW1BbGxvd1N5bmMoZGVzY3JpcHRpb24sIHN1YnNjcmliZSkge1xuICAgIHJldHVybiBuZXcgRXZlbnRTdHJlYW0oZGVzY3JpcHRpb24sIHN1YnNjcmliZSwgdW5kZWZpbmVkLCBhbGxvd1N5bmMpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2woa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIFN5bWJvbFtrZXldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFN5bWJvbFtrZXldID0gU3ltYm9sLmZvcihrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiQEBcIiArIGtleTtcbiAgICB9XG59XG5cbnZhciBFU09ic2VydmFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRVNPYnNlcnZhYmxlKG9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICB9XG4gICAgRVNPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck9uTmV4dCwgb25FcnJvciwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSB0eXBlb2Ygb2JzZXJ2ZXJPck9uTmV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyB7IG5leHQ6IG9ic2VydmVyT3JPbk5leHQsIGVycm9yOiBvbkVycm9yLCBjb21wbGV0ZTogb25Db21wbGV0ZSB9XG4gICAgICAgICAgICA6IG9ic2VydmVyT3JPbk5leHQ7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICBjbG9zZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNhbmNlbCA9IHRoaXMub2JzZXJ2YWJsZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaGFzVmFsdWUoZXZlbnQpICYmIG9ic2VydmVyLm5leHQpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGV2ZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRXJyb3IoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yKVxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihldmVudC5lcnJvcik7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5pc0VuZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gRVNPYnNlcnZhYmxlO1xufSgpKTtcbkVTT2JzZXJ2YWJsZS5wcm90b3R5cGVbc3ltYm9sKCdvYnNlcnZhYmxlJyldID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xufTtcbk9ic2VydmFibGUucHJvdG90eXBlLnRvRVNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRVNPYnNlcnZhYmxlKHRoaXMpO1xufTtcbk9ic2VydmFibGUucHJvdG90eXBlW3N5bWJvbCgnb2JzZXJ2YWJsZScpXSA9IE9ic2VydmFibGUucHJvdG90eXBlLnRvRVNPYnNlcnZhYmxlO1xuXG4vKipcbiBDcmVhdGVzIGEgUHJvcGVydHkgZnJvbSBhbiBpbml0aWFsIHZhbHVlIGFuZCB1cGRhdGVzIHRoZSB2YWx1ZSBiYXNlZCBvbiBtdWx0aXBsZSBpbnB1dHMuXG4gVGhlIGlucHV0cyBhcmUgZGVmaW5lZCBzaW1pbGFybHkgdG8gW2BCYWNvbi53aGVuYF0oI2JhY29uLXdoZW4pLCBsaWtlIHRoaXM6XG5cbiBgYGBqc1xuIHZhciByZXN1bHQgPSBCYWNvbi51cGRhdGUoXG4gaW5pdGlhbCxcbiBbeCx5LHosIChwcmV2aW91cyx4LHkseikgPT4geyAuLi4gfV0sXG4gW3gseSwgICAocHJldmlvdXMseCx5KSA9PiB7IC4uLiB9XSlcbiBgYGBcblxuIEFzIGlucHV0LCBlYWNoIGZ1bmN0aW9uIGFib3ZlIHdpbGwgZ2V0IHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYHJlc3VsdGAgUHJvcGVydHksIGFsb25nIHdpdGggdmFsdWVzIGZyb20gdGhlIGxpc3RlZCBPYnNlcnZhYmxlcy5cbiBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCBhcyB0aGUgbmV4dCB2YWx1ZSBvZiBgcmVzdWx0YC5cblxuIEp1c3QgbGlrZSBpbiBbYEJhY29uLndoZW5gXSgjd2hlbiksIG9ubHkgRXZlbnRTdHJlYW1zIHdpbGwgdHJpZ2dlciBhbiB1cGRhdGUsIHdoaWxlIFByb3BlcnRpZXMgd2lsbCBiZSBqdXN0IHNhbXBsZWQuXG4gU28sIGlmIHlvdSBsaXN0IGEgc2luZ2xlIEV2ZW50U3RyZWFtIGFuZCBzZXZlcmFsIFByb3BlcnRpZXMsIHRoZSB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQgb25seSB3aGVuIGFuIGV2ZW50IG9jY3VycyBpbiB0aGUgRXZlbnRTdHJlYW0uXG5cbiBIZXJlJ3MgYSBzaW1wbGUgZ2FtaW5nIGV4YW1wbGU6XG5cbiBgYGBqc1xuIGxldCBzY29yZU11bHRpcGxpZXIgPSBCYWNvbi5jb25zdGFudCgxKVxuIGxldCBoaXRVZm8gPSBCYWNvbi5pbnRlcnZhbCgxMDAwKVxuIGxldCBoaXRNb3RoZXJTaGlwID0gQmFjb24ubGF0ZXIoMTAwMDApXG4gbGV0IHNjb3JlID0gQmFjb24udXBkYXRlKFxuIDAsXG4gW2hpdFVmbywgc2NvcmVNdWx0aXBsaWVyLCAoc2NvcmUsIF8sIG11bHRpcGxpZXIpID0+IHNjb3JlICsgMTAwICogbXVsdGlwbGllciBdLFxuIFtoaXRNb3RoZXJTaGlwLCAoc2NvcmUsIF8pID0+IHNjb3JlICsgMjAwMCBdXG4gKVxuIGBgYFxuXG4gSW4gdGhlIGV4YW1wbGUsIHRoZSBgc2NvcmVgIHByb3BlcnR5IGlzIHVwZGF0ZWQgd2hlbiBlaXRoZXIgYGhpdFVmb2Agb3IgYGhpdE1vdGhlclNoaXBgIG9jY3VyLiBUaGUgYHNjb3JlTXVsdGlwbGllcmAgUHJvcGVydHkgaXMgc2FtcGxlZCB0byB0YWtlIG11bHRpcGxpZXIgaW50byBhY2NvdW50IHdoZW4gYGhpdFVmb2Agb2NjdXJzLlxuXG4gKiBAcGFyYW0gaW5pdGlhbFxuICogQHBhcmFtIHtVcGRhdGVQYXR0ZXJuPE91dD59IHBhdHRlcm5zXG4gKiBAcmV0dXJucyB7UHJvcGVydHk8T3V0Pn1cbiAqL1xuZnVuY3Rpb24gdXBkYXRlKGluaXRpYWwpIHtcbiAgICB2YXIgcGF0dGVybnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwYXR0ZXJuc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHJhd1BhdHRlcm5zID0gZXh0cmFjdFJhd1BhdHRlcm5zKHBhdHRlcm5zKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd1BhdHRlcm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gcmF3UGF0dGVybnNbaV07XG4gICAgICAgIHBhdHRlcm5bMV0gPSBsYXRlQmluZEZpcnN0KHBhdHRlcm5bMV0pO1xuICAgIH1cbiAgICByZXR1cm4gd2hlbi5hcHBseSh2b2lkIDAsIHJhd1BhdHRlcm5zKS5zY2FuKGluaXRpYWwsIChmdW5jdGlvbiAoeCwgZikge1xuICAgICAgICByZXR1cm4gZih4KTtcbiAgICB9KSkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcInVwZGF0ZVwiLCBbaW5pdGlhbF0uY29uY2F0KHBhdHRlcm5zKSkpO1xufVxuZnVuY3Rpb24gbGF0ZUJpbmRGaXJzdChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmLmFwcGx5KHZvaWQgMCwgW2ldLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLyoqXG4gQ3JlYXRlcyBhbiBFdmVudFN0cmVhbSB0aGF0IGRlbGl2ZXJzIHRoZSBnaXZlblxuIHNlcmllcyBvZiB2YWx1ZXMgKGdpdmVuIGFzIGFycmF5KSB0byB0aGUgZmlyc3Qgc3Vic2NyaWJlci4gVGhlIHN0cmVhbSBlbmRzIGFmdGVyIHRoZXNlXG4gdmFsdWVzIGhhdmUgYmVlbiBkZWxpdmVyZWQuIFlvdSBjYW4gYWxzbyBzZW5kIFtgQmFjb24uRXJyb3JgXShjbGFzc2VzL2Vycm9yLmh0bWwpIGV2ZW50cywgb3JcbiBhbnkgY29tYmluYXRpb24gb2YgcHVyZSB2YWx1ZXMgYW5kIGVycm9yIGV2ZW50cyBsaWtlIHRoaXM6XG4gYEJhY29uLmZyb21BcnJheShbMSwgbmV3IEJhY29uLkVycm9yKCldKVxuXG4gQHBhcmFtICAgdmFsdWVzICAgIEFycmF5IG9mIHZhbHVlcyBvciBldmVudHMgdG8gcmVwZWF0XG4gQHR5cGVwYXJhbSBWIFR5cGUgb2Ygc3RyZWFtIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICBhc3NlcnRBcnJheSh2YWx1ZXMpO1xuICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV2ZXIoKS53aXRoRGVzYyhuZXcgRGVzYyhcIkJhY29uXCIsIFwiZnJvbUFycmF5XCIsIHZhbHVlcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IEV2ZW50U3RyZWFtKG5ldyBEZXNjKFwiQmFjb25cIiwgXCJmcm9tQXJyYXlcIiwgW3ZhbHVlc10pLCBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICAgICAgdmFyIHVuc3ViZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHJlcGx5ID0gbW9yZTtcbiAgICAgICAgICAgIHZhciBwdXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcHVzaE5lZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZnVuY3Rpb24gcHVzaCgpIHtcbiAgICAgICAgICAgICAgICBwdXNoTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHVzaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHB1c2hOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaE5lZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHJlcGx5ICE9PSBub01vcmUpICYmICF1bnN1YmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHkgPSBzaW5rKHRvRXZlbnQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBseSAhPT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0ZUJhcnJpZXIuYWZ0ZXJUcmFuc2FjdGlvbihzdHJlYW0sIHB1c2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1c2hpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBVcGRhdGVCYXJyaWVyLnNvb25CdXROb3RZZXQoc3RyZWFtLCBwdXNoKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdW5zdWJkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5zdWJkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0V2ZW50U291cmNlRm4oeCkge1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24oeCk7XG59XG4vLyBXcmFwIERPTSBFdmVudFRhcmdldCwgTm9kZSBFdmVudEVtaXR0ZXIsIG9yXG4vLyBbdW5dYmluZDogKEFueSwgKEFueSkgLT4gTm9uZSkgLT4gTm9uZSBpbnRlcmZhY2VzXG4vLyBjb21tb24gaW4gTVZDcyBhcyBFdmVudFN0cmVhbVxuLy9cbi8vIHRhcmdldCAtIEV2ZW50VGFyZ2V0IG9yIEV2ZW50RW1pdHRlciwgc291cmNlIG9mIGV2ZW50c1xuLy8gZXZlbnRTb3VyY2UgLSBldmVudCBuYW1lIHRvIGJpbmQgb3IgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGN1c3RvbSBiaW5kaW5nXG4vLyBldmVudFRyYW5zZm9ybWVyIC0gZGVmYXVsdHMgdG8gcmV0dXJuaW5nIHRoZSBmaXJzdCBhcmd1bWVudCB0byBoYW5kbGVyXG4vL1xuLy8gRXhhbXBsZSAxOlxuLy9cbi8vICAgQmFjb24uZnJvbUV2ZW50VGFyZ2V0KGRvY3VtZW50LmJvZHksIFwiY2xpY2tcIilcbi8vICAgIyA9PiBFdmVudFN0cmVhbVxuLy9cbi8vICAgQmFjb24uZnJvbUV2ZW50VGFyZ2V0KGRvY3VtZW50LmJvZHksIFwic2Nyb2xsXCIsIHtwYXNzaXZlOiB0cnVlfSlcbi8vICAgIyA9PiBFdmVudFN0cmVhbVxuLy9cbi8vICAgQmFjb24uZnJvbUV2ZW50VGFyZ2V0IChuZXcgRXZlbnRFbWl0dGVyKCksIFwiZGF0YVwiKVxuLy8gICAjID0+IEV2ZW50U3RyZWFtXG4vL1xuLy8gUmV0dXJucyBFdmVudFN0cmVhbVxuLyoqIEBoaWRkZW4gKi9cbnZhciBldmVudE1ldGhvZHMgPSBbXG4gICAgW1wiYWRkRXZlbnRMaXN0ZW5lclwiLCBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIl0sXG4gICAgW1wiYWRkTGlzdGVuZXJcIiwgXCJyZW1vdmVMaXN0ZW5lclwiXSxcbiAgICBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICBbXCJiaW5kXCIsIFwidW5iaW5kXCJdXG5dO1xudmFyIGZpbmRIYW5kbGVyTWV0aG9kcyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB2YXIgcGFpcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYWlyID0gZXZlbnRNZXRob2RzW2ldO1xuICAgICAgICB2YXIgbWV0aG9kUGFpciA9IFt0YXJnZXRbcGFpclswXV0sIHRhcmdldFtwYWlyWzFdXV07XG4gICAgICAgIGlmIChtZXRob2RQYWlyWzBdICYmIG1ldGhvZFBhaXJbMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RQYWlyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXZlbnRNZXRob2RzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhaXIgPSBldmVudE1ldGhvZHNbal07XG4gICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IHRhcmdldFtwYWlyWzBdXTtcbiAgICAgICAgaWYgKGFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gW2FkZExpc3RlbmVyLCBmdW5jdGlvbiAoKSB7IH1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1aXRhYmxlIGV2ZW50IG1ldGhvZHMgaW4gXCIgKyB0YXJnZXQpO1xufTtcbi8qKlxuIGNyZWF0ZXMgYW4gRXZlbnRTdHJlYW0gZnJvbSBldmVudHNcbiBvbiBhIERPTSBFdmVudFRhcmdldCBvciBOb2RlLkpTIEV2ZW50RW1pdHRlciBvYmplY3QsIG9yIGFuIG9iamVjdCB0aGF0IHN1cHBvcnRzIGV2ZW50IGxpc3RlbmVycyB1c2luZyBgb25gL2BvZmZgIG1ldGhvZHMuXG4gWW91IGNhbiBhbHNvIHBhc3MgYW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSBlbWl0dGVkXG4gZXZlbnRzJyBwYXJhbWV0ZXJzLlxuXG4gVGhlIHNpbXBsZSBmb3JtOlxuXG4gYGBganNcbiBCYWNvbi5mcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgXCJjbGlja1wiKS5vblZhbHVlKGZ1bmN0aW9uKCkgeyBhbGVydChcIkJhY29uIVwiKSB9KVxuIGBgYFxuXG4gVXNpbmcgYSBiaW5kZXIgZnVuY3Rpb246XG5cbiBgYGBqc1xuIEJhY29uLmZyb21FdmVudChcbiB3aW5kb3csXG4gZnVuY3Rpb24oYmluZGVyLCBsaXN0ZW5lcikge1xuICAgIGJpbmRlcihcInNjcm9sbFwiLCBsaXN0ZW5lciwge3Bhc3NpdmU6IHRydWV9KVxuICB9XG4gKS5vblZhbHVlKGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZyh3aW5kb3cuc2Nyb2xsWSlcbn0pXG4gYGBgXG5cbiBAcGFyYW0gdGFyZ2V0XG4gQHBhcmFtIGV2ZW50U291cmNlXG4gQHBhcmFtIGV2ZW50VHJhbnNmb3JtZXJcbiBAdHlwZXBhcmFtIFYgVHlwZSBvZiBzdHJlYW0gZWxlbWVudHNcblxuICovXG5mdW5jdGlvbiBmcm9tRXZlbnQodGFyZ2V0LCBldmVudFNvdXJjZSwgZXZlbnRUcmFuc2Zvcm1lcikge1xuICAgIHZhciBfYSA9IGZpbmRIYW5kbGVyTWV0aG9kcyh0YXJnZXQpLCBzdWIgPSBfYVswXSwgdW5zdWIgPSBfYVsxXTtcbiAgICB2YXIgZGVzYyA9IG5ldyBEZXNjKFwiQmFjb25cIiwgXCJmcm9tRXZlbnRcIiwgW3RhcmdldCwgZXZlbnRTb3VyY2VdKTtcbiAgICByZXR1cm4gZnJvbUJpbmRlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICBpZiAoaXNFdmVudFNvdXJjZUZuKGV2ZW50U291cmNlKSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2Uoc3ViLmJpbmQodGFyZ2V0KSwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZSh1bnN1Yi5iaW5kKHRhcmdldCksIGhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1Yi5jYWxsKHRhcmdldCwgZXZlbnRTb3VyY2UsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5zdWIuY2FsbCh0YXJnZXQsIGV2ZW50U291cmNlLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBldmVudFRyYW5zZm9ybWVyKS53aXRoRGVzYyhkZXNjKTtcbn1cblxuLyoqXG4gQSBzaG9ydGhhbmQgZm9yIGNvbWJpbmluZyBtdWx0aXBsZVxuIHNvdXJjZXMgKHN0cmVhbXMsIHByb3BlcnRpZXMsIGNvbnN0YW50cykgYXMgYXJyYXkgYW5kIGFzc2lnbmluZyB0aGVcbiBzaWRlLWVmZmVjdCBmdW5jdGlvbiBmIGZvciB0aGUgdmFsdWVzLiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgd291bGQgbG9nXG4gdGhlIG51bWJlciAzLlxuXG4gYGBganNcbiBmdW5jdGlvbiBmKGEsIGIpIHsgY29uc29sZS5sb2coYSArIGIpIH1cbiBCYWNvbi5vblZhbHVlcyhCYWNvbi5jb25zdGFudCgxKSwgQmFjb24uY29uc3RhbnQoMiksIGYpXG4gYGBgXG4gKi9cbmZ1bmN0aW9uIG9uVmFsdWVzKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gY29tYmluZUFzQXJyYXkoYXJncy5zbGljZSgwLCBhcmdzLmxlbmd0aCAtIDEpKS5vblZhbHVlcyhhcmdzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSk7XG59XG5cbi8qKlxuIENhbGxzIGdlbmVyYXRvciBmdW5jdGlvbiB3aGljaCBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JzZXJ2YWJsZS4gVGhlIHJldHVybmVkIEV2ZW50U3RyZWFtIGNvbnRhaW5zXG4gdmFsdWVzIGFuZCBlcnJvcnMgZnJvbSB0aGUgc3Bhd25lZCBvYnNlcnZhYmxlLiBXaGVuIHRoZSBzcGF3bmVkIG9ic2VydmFibGUgZW5kcywgdGhlIGdlbmVyYXRvciBpcyBjYWxsZWRcbiBhZ2FpbiB0byBzcGF3biBhIG5ldyBvYnNlcnZhYmxlLlxuXG4gVGhpcyBpcyByZXBlYXRlZCB1bnRpbCB0aGUgZ2VuZXJhdG9yIHJldHVybnMgYSBmYWxzeSB2YWx1ZVxuIChzdWNoIGFzIGB1bmRlZmluZWRgIG9yIGBmYWxzZWApLlxuXG4gVGhlIGdlbmVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQg4oCUIGl0ZXJhdGlvbiBudW1iZXIgc3RhcnRpbmcgZnJvbSBgMGAuXG5cbiBIZXJlJ3MgYW4gZXhhbXBsZTpcblxuYGBganNcbkJhY29uLnJlcGVhdChmdW5jdGlvbihpKSB7XG5pZiAoaSA8IDMpIHtcbiAgcmV0dXJuIEJhY29uLm9uY2UoaSk7XG59IGVsc2Uge1xuICByZXR1cm4gZmFsc2U7XG59XG59KS5sb2coKVxuYGBgXG5cbiBUaGUgZXhhbXBsZSB3aWxsIHByb2R1Y2UgdmFsdWVzIDAsIDEgYW5kIDIuXG5cbiBAcGFyYW0geyhudW1iZXIpID0+IChPYnNlcnZhYmxlPFY+IHwgbnVsbCl9IGdlbmVyYXRvclxuIEByZXR1cm5zIHtFdmVudFN0cmVhbTxWPn1cbiBAdHlwZXBhcmFtIFYgVHlwZSBvZiBzdHJlYW0gZWxlbWVudHNcblxuICovXG5mdW5jdGlvbiByZXBlYXQoZ2VuZXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICByZXR1cm4gZnJvbUJpbmRlcihmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVwbHkgPSBtb3JlO1xuICAgICAgICB2YXIgdW5zdWIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuaXNFbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVOZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGx5ID0gc2luayhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlTmV4dCgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0O1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoZmxhZyAmJiByZXBseSAhPT0gbm9Nb3JlKSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGdlbmVyYXRvcihpbmRleCsrKTtcbiAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zdWIgPSBuZXh0LnN1YnNjcmliZUludGVybmFsKGhhbmRsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmsoZW5kRXZlbnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlTmV4dCgpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5zdWIoKTsgfTtcbiAgICB9KS53aXRoRGVzYyhuZXcgRGVzYyhcIkJhY29uXCIsIFwicmVwZWF0XCIsIFtnZW5lcmF0b3JdKSk7XG59XG5cbi8qKlxuIFJlcGVhdHMgZ2l2ZW4gZWxlbWVudHMgaW5kZWZpbml0ZWx5XG4gd2l0aCBnaXZlbiBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMuIEZvciBleGFtcGxlLCBgcmVwZWF0ZWRseSgxMCwgWzEsMiwzXSlgXG4gd291bGQgbGVhZCB0byBgMSwyLDMsMSwyLDMuLi5gIHRvIGJlIHJlcGVhdGVkIGluZGVmaW5pdGVseS5cblxuIEBwYXJhbSBkZWxheSBiZXR3ZWVuIHZhbHVlcywgaW4gbWlsbGlzZWNvbmRzXG4gQHBhcmFtIHZhbHVlcyBhcnJheSBvZiB2YWx1ZXMgdG8gcmVwZWF0XG4gQHR5cGVwYXJhbSBWIFR5cGUgb2Ygc3RyZWFtIGVsZW1lbnRzXG5cbiAqL1xuZnVuY3Rpb24gcmVwZWF0ZWRseShkZWxheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICByZXR1cm4gZnJvbVBvbGwoZGVsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tpbmRleCsrICUgdmFsdWVzLmxlbmd0aF07XG4gICAgfSkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcInJlcGVhdGVkbHlcIiwgW2RlbGF5LCB2YWx1ZXNdKSk7XG59XG5cbi8qKlxuIENyZWF0ZXMgYSBzdHJlYW0gdGhhdCBlbmRzIGFmdGVyIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMsIHdpdGhvdXQgZW1pdHRpbmcgYW55IHZhbHVlcy5cblxuIEBwYXJhbSBkdXJhdGlvbiBkdXJhdGlvbiBvZiBzaWxlbmNlIGluIG1pbGxpc2Vjb25kc1xuIEB0eXBlcGFyYW0gViBUeXBlIG9mIHN0cmVhbSBlbGVtZW50c1xuICovXG5mdW5jdGlvbiBzaWxlbmNlKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGxhdGVyKGR1cmF0aW9uLCBcIlwiKVxuICAgICAgICAuZmlsdGVyKGZhbHNlKVxuICAgICAgICAud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcInNpbGVuY2VcIiwgW2R1cmF0aW9uXSkpO1xufVxuXG4vKipcbiBVc2VkIHRvIHJldHJ5IHRoZSBjYWxsIHdoZW4gdGhlcmUgaXMgYW4gW2BFcnJvcmBdKGNsYXNzZXMvZXJyb3IuaHRtbCkgZXZlbnQgaW4gdGhlIHN0cmVhbSBwcm9kdWNlZCBieSB0aGUgYHNvdXJjZWAgZnVuY3Rpb24uXG5cbiBgYGBqc1xuIHZhciB0cmlnZ2VyaW5nU3RyZWFtLCBhamF4Q2FsbCAvLyA8LSBhamF4Q2FsbCBnaXZlcyBFcnJvcnMgb24gbmV0d29yayBvciBzZXJ2ZXIgZXJyb3JzXG4gYWpheFJlc3VsdCA9IHRyaWdnZXJpbmdTdHJlYW0uZmxhdE1hcChmdW5jdGlvbih1cmwpIHtcbiAgICByZXR1cm4gQmFjb24ucmV0cnkoe1xuICAgICAgICBzb3VyY2U6IGZ1bmN0aW9uKGF0dGVtcHROdW1iZXIpIHsgcmV0dXJuIGFqYXhDYWxsKHVybCkgfSxcbiAgICAgICAgcmV0cmllczogNSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gZXJyb3IuaHR0cFN0YXR1c0NvZGUgIT09IDQwNDsgfSxcbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uKGNvbnRleHQpIHsgcmV0dXJuIDEwMDsgfSAvLyBKdXN0IHVzZSB0aGUgc2FtZSBkZWxheSBhbHdheXNcbiAgICB9KVxufSlcbiBgYGBcbiAqIEBwYXJhbSBvcHRpb25zIChjbGljayBmb3IgZGV0YWlscylcbiAqL1xuZnVuY3Rpb24gcmV0cnkob3B0aW9ucykge1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKG9wdGlvbnMuc291cmNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInc291cmNlJyBvcHRpb24gaGFzIHRvIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcbiAgICB2YXIgcmV0cmllcyA9IG9wdGlvbnMucmV0cmllcyB8fCAwO1xuICAgIHZhciByZXRyaWVzRG9uZSA9IDA7XG4gICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgdmFyIGlzUmV0cnlhYmxlID0gb3B0aW9ucy5pc1JldHJ5YWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdmFyIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yRXZlbnQgPSBudWxsO1xuICAgIHJldHVybiByZXBlYXQoZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU3RyZWFtKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb3VudCkuZW5kT25FcnJvcigpLnRyYW5zZm9ybShmdW5jdGlvbiAoZXZlbnQsIHNpbmspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNFcnJvcihldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc1JldHJ5YWJsZShlcnJvckV2ZW50LmVycm9yKSAmJiAocmV0cmllcyA9PT0gMCB8fCByZXRyaWVzRG9uZSA8IHJldHJpZXMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbmsoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNWYWx1ZShldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW5rKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3JFdmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRXZlbnQuZXJyb3IsXG4gICAgICAgICAgICAgICAgcmV0cmllc0RvbmU6IHJldHJpZXNEb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHBhdXNlID0gc2lsZW5jZShkZWxheShjb250ZXh0KSk7XG4gICAgICAgICAgICByZXRyaWVzRG9uZSsrO1xuICAgICAgICAgICAgcmV0dXJuIHBhdXNlLmNvbmNhdChvbmNlKG51bGwpLmZsYXRNYXAodmFsdWVTdHJlYW0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVN0cmVhbSgpO1xuICAgICAgICB9XG4gICAgfSkud2l0aERlc2MobmV3IERlc2MoXCJCYWNvblwiLCBcInJldHJ5XCIsIFtvcHRpb25zXSkpO1xufVxuXG4vKipcbiBDcmVhdGVzIGEgc3RyZWFtIGNvbnRhaW5pbmcgZ2l2ZW5cbiB2YWx1ZXMgKGdpdmVuIGFzIGFycmF5KS4gRGVsaXZlcmVkIHdpdGggZ2l2ZW4gaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxuXG4gQHBhcmFtIGRlbGF5IGJldHdlZW4gZWxlbWVudHMsIGluIG1pbGxpc2Vjb25kc1xuIEBwYXJhbSBhcnJheSBvZiB2YWx1ZXMgb3IgZXZlbnRzXG4gQHR5cGVwYXJhbSBWIFR5cGUgb2Ygc3RyZWFtIGVsZW1lbnRzXG5cbiAqL1xuZnVuY3Rpb24gc2VxdWVudGlhbGx5KGRlbGF5LCB2YWx1ZXMpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHJldHVybiBmcm9tUG9sbChkZWxheSwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaW5kZXgrK107XG4gICAgICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0b0V2ZW50KHZhbHVlKSwgZW5kRXZlbnQoKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH0pLndpdGhEZXNjKG5ldyBEZXNjKFwiQmFjb25cIiwgXCJzZXF1ZW50aWFsbHlcIiwgW2RlbGF5LCB2YWx1ZXNdKSk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlQW5kRW5kKHZhbHVlKSB7XG4gICAgcmV0dXJuIFt0b0V2ZW50KHZhbHVlKSwgZW5kRXZlbnQoKV07XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gRXZlbnRTdHJlYW0gZnJvbSBhIFByb21pc2Ugb2JqZWN0IHN1Y2ggYXMgSlF1ZXJ5IEFqYXguXG4gVGhpcyBzdHJlYW0gd2lsbCBjb250YWluIGEgc2luZ2xlIHZhbHVlIG9yIGFuIGVycm9yLCBmb2xsb3dlZCBpbW1lZGlhdGVseSBieSBzdHJlYW0gZW5kLlxuIFlvdSBjYW4gdXNlIHRoZSBvcHRpb25hbCBhYm9ydCBmbGFnIChpLmUuIMK0ZnJvbVByb21pc2UocCwgdHJ1ZSnCtCB0byBoYXZlIHRoZSBgYWJvcnRgIG1ldGhvZCBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBiZSBjYWxsZWQgd2hlbiBhbGwgc3Vic2NyaWJlcnMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgY3JlYXRlZCBzdHJlYW0uXG4gWW91IGNhbiBhbHNvIHBhc3MgYW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSBwcm9taXNlIHZhbHVlIGludG8gRXZlbnRzLiBUaGUgZGVmYXVsdCBpcyB0byB0cmFuc2Zvcm0gdGhlIHZhbHVlIGludG8gYFtuZXcgQmFjb24uTmV4dCh2YWx1ZSksIG5ldyBCYWNvbi5FbmQoKV1gLlxuIENoZWNrIG91dCB0aGlzIFtleGFtcGxlXShodHRwczovL2dpdGh1Yi5jb20vcmFpbW9oYW5za2EvYmFjb25qcy1leGFtcGxlcy9ibG9iL21hc3Rlci9yZXNvdXJjZXMvcHVibGljL2luZGV4Lmh0bWwpLlxuXG4gKlxuICogQHBhcmFtIHtQcm9taXNlPFY+fSBzb3VyY2UgcHJvbWlzZSBvYmplY3RcbiAqIEBwYXJhbSBhYm9ydCBzaG91bGQgd2UgY2FsbCB0aGUgYGFib3J0YCBtZXRob2Qgb2YgdGhlIFByb21pc2Ugb24gdW5zdWJzY3JpYmUuIFRoaXMgaXMgYSBub25zdGFuZGFyZCBmZWF0dXJlIHlvdSBzaG91bGQgcHJvYmFibHkgaWdub3JlLlxuICogQHBhcmFtIHtFdmVudFRyYW5zZm9ybWVyPFY+fSBldmVudFRyYW5zZm9ybWVyXG4gKiBAcmV0dXJucyB7RXZlbnRTdHJlYW08Vj59XG4gKi9cbmZ1bmN0aW9uIGZyb21Qcm9taXNlKHByb21pc2UsIGFib3J0LCBldmVudFRyYW5zZm9ybWVyKSB7XG4gICAgaWYgKGV2ZW50VHJhbnNmb3JtZXIgPT09IHZvaWQgMCkgeyBldmVudFRyYW5zZm9ybWVyID0gdmFsdWVBbmRFbmQ7IH1cbiAgICByZXR1cm4gZnJvbUJpbmRlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgYm91bmQgPSBwcm9taXNlLnRoZW4oaGFuZGxlciwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGhhbmRsZXIobmV3IEVycm9yJDEoZSkpOyB9KTtcbiAgICAgICAgaWYgKGJvdW5kICYmIHR5cGVvZiBib3VuZC5kb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGJvdW5kLmRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9taXNlLmFib3J0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBldmVudFRyYW5zZm9ybWVyKS53aXRoRGVzYyhuZXcgRGVzYyhcIkJhY29uXCIsIFwiZnJvbVByb21pc2VcIiwgW3Byb21pc2VdKSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhNZXRob2RDYWxsU3VwcG9ydCh3cmFwcGVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZiA9PT0gXCJvYmplY3RcIiAmJiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBmO1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhcmdzWzBdO1xuICAgICAgICAgICAgZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbbWV0aG9kTmFtZV0uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZWQuYXBwbHkodm9pZCAwLCBbZl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFydGlhbGx5QXBwbGllZChmLCBhcHBsaWVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZi5hcHBseSh2b2lkIDAsIChhcHBsaWVkLmNvbmNhdChhcmdzKSkpO1xuICAgIH07XG59XG52YXIgbWFrZUZ1bmN0aW9uXyA9IHdpdGhNZXRob2RDYWxsU3VwcG9ydChmdW5jdGlvbiAoZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKF8uaXNGdW5jdGlvbihmKSkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsbHlBcHBsaWVkKGYsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBfLmFsd2F5cyhmKTtcbiAgICB9XG59KTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24oZiwgYXJncykge1xuICAgIHJldHVybiBtYWtlRnVuY3Rpb25fLmFwcGx5KHZvaWQgMCwgW2ZdLmNvbmNhdChhcmdzKSk7XG59XG5cbi8vIFRPRE86IHR5cGVzL2RvYyBmb3IgdGhlIG9iamVjdCwgZm5uYW1lIHZhcmlhbnRcbi8qKlxuIENyZWF0ZXMgYW4gRXZlbnRTdHJlYW0gZnJvbSBhIGZ1bmN0aW9uIHRoYXRcbiBhY2NlcHRzIGEgY2FsbGJhY2suIFRoZSBmdW5jdGlvbiBpcyBzdXBwb3NlZCB0byBjYWxsIGl0cyBjYWxsYmFjayBqdXN0XG4gb25jZS4gRm9yIGV4YW1wbGU6XG5cbiBgYGBqc1xuIEJhY29uLmZyb21DYWxsYmFjayhjYWxsYmFjayA9PiBjYWxsYmFjayhcImJhY29uXCIpKVxuIGBgYFxuXG4gVGhpcyB3b3VsZCBjcmVhdGUgYSBzdHJlYW0gdGhhdCBvdXRwdXRzIGEgc2luZ2xlIHZhbHVlIFwiQmFjb24hXCIgYW5kIGVuZHNcbiBhZnRlciB0aGF0LiBUaGUgdXNlIG9mIHNldFRpbWVvdXQgY2F1c2VzIHRoZSB2YWx1ZSB0byBiZSBkZWxheWVkIGJ5IDFcbiBzZWNvbmQuXG5cbiBZb3UgY2FuIGFsc28gZ2l2ZSBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBbYGZyb21DYWxsYmFja2BdKCNiYWNvbi1mcm9tY2FsbGJhY2spLCB3aGljaCB3aWxsIGJlXG4gcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gVGhlc2UgYXJndW1lbnRzIGNhbiBiZSBzaW1wbGUgdmFyaWFibGVzLCBCYWNvblxuIEV2ZW50U3RyZWFtcyBvciBQcm9wZXJ0aWVzLiBGb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIHdpbGwgb3V0cHV0IFwiQmFjb24gcnVsZXNcIjpcblxuIGBgYGpzXG4gYmFjb24gPSBCYWNvbi5jb25zdGFudCgnYmFjb24nKVxuIEJhY29uLmZyb21DYWxsYmFjayhmdW5jdGlvbihhLCBiLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhhICsgJyAnICsgYik7XG59LCBiYWNvbiwgJ3J1bGVzJykubG9nKCk7XG4gYGBgXG5cbiAqIEBwYXJhbSBmXG4gKiBAcGFyYW0gYXJnc1xuICogQHJldHVybnMge0V2ZW50U3RyZWFtPFY+fVxuICovXG5mdW5jdGlvbiBmcm9tQ2FsbGJhY2soZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21CaW5kZXIoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgbWFrZUZ1bmN0aW9uKGYsIGFyZ3MpKGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gbm9wO1xuICAgIH0sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCBlbmRFdmVudCgpXTtcbiAgICB9KS53aXRoRGVzYyhuZXcgRGVzYyhcIkJhY29uXCIsIFwiZnJvbUNhbGxiYWNrXCIsIFtmXS5jb25jYXQoYXJncykpKTtcbn1cbi8qKlxuQmVoYXZlcyB0aGUgc2FtZSB3YXkgYXMgYEJhY29uLmZyb21DYWxsYmFja2AsXG5leGNlcHQgdGhhdCBpdCBleHBlY3RzIHRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgaW4gdGhlIE5vZGUuanMgY29udmVudGlvbjpcbmBjYWxsYmFjayhlcnJvciwgZGF0YSlgLCB3aGVyZSBlcnJvciBpcyBudWxsIGlmIGV2ZXJ5dGhpbmcgaXMgZmluZS4gRm9yIGV4YW1wbGU6XG5cbmBgYGpzXG52YXIgQmFjb24gPSByZXF1aXJlKCdiYWNvbmpzJykuQmFjb24sXG5mcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcmVhZCA9IEJhY29uLmZyb21Ob2RlQ2FsbGJhY2soZnMucmVhZEZpbGUsICdpbnB1dC50eHQnKTtcbnJlYWQub25FcnJvcihmdW5jdGlvbihlcnJvcikgeyBjb25zb2xlLmxvZyhcIlJlYWRpbmcgZmFpbGVkOiBcIiArIGVycm9yKTsgfSk7XG5yZWFkLm9uVmFsdWUoZnVuY3Rpb24odmFsdWUpIHsgY29uc29sZS5sb2coXCJSZWFkIGNvbnRlbnRzOiBcIiArIHZhbHVlKTsgfSk7XG5gYGBcblxuICovXG5mdW5jdGlvbiBmcm9tTm9kZUNhbGxiYWNrKGYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmcm9tQmluZGVyKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIG1ha2VGdW5jdGlvbihmLCBhcmdzKShoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIG5vcDtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgRXJyb3IkMShlcnJvciksIGVuZEV2ZW50KCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdmFsdWUsIGVuZEV2ZW50KCldO1xuICAgIH0pLndpdGhEZXNjKG5ldyBEZXNjKFwiQmFjb25cIiwgXCJmcm9tTm9kZUNhbGxiYWNrXCIsIFtmXS5jb25jYXQoYXJncykpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEV2ZW50U3RyZWFtIGZyb20gYW5cbiBbRVMgT2JzZXJ2YWJsZV0oaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZSkuIElucHV0IGNhbiBiZSBhbnlcbiBFUyBPYnNlcnZhYmxlIGltcGxlbWVudGF0aW9uIGluY2x1ZGluZyBSeEpTIGFuZCBLZWZpci5cbiAqL1xuZnVuY3Rpb24gZnJvbUVTT2JzZXJ2YWJsZShfb2JzZXJ2YWJsZSkge1xuICAgIHZhciBvYnNlcnZhYmxlO1xuICAgIGlmIChfb2JzZXJ2YWJsZVtzeW1ib2woXCJvYnNlcnZhYmxlXCIpXSkge1xuICAgICAgICBvYnNlcnZhYmxlID0gX29ic2VydmFibGVbc3ltYm9sKFwib2JzZXJ2YWJsZVwiKV0oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9ic2VydmFibGUgPSBfb2JzZXJ2YWJsZTtcbiAgICB9XG4gICAgdmFyIGRlc2MgPSBuZXcgRGVzYyhcIkJhY29uXCIsIFwiZnJvbUVTT2JzZXJ2YWJsZVwiLCBbb2JzZXJ2YWJsZV0pO1xuICAgIHJldHVybiBuZXcgRXZlbnRTdHJlYW0oZGVzYywgZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgdmFyIGNhbmNlbCA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHNpbmsobmV3IEVycm9yJDEoeCkpO1xuICAgICAgICAgICAgICAgIHNpbmsobmV3IEVuZCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgc2luayhuZXcgTmV4dCh2YWx1ZSkpOyB9LFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzaW5rKG5ldyBFbmQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTdXBwb3J0IFJ4SlMgT2JzZXJ2YWJsZXNcbiAgICAgICAgaWYgKGNhbmNlbC51bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgY2FuY2VsLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuIEFuIFtgRXZlbnRTdHJlYW1gXShldmVudHN0cmVhbS5odG1sKSB0aGF0IGFsbG93cyB5b3UgdG8gW2BwdXNoYF0oI3B1c2gpIHZhbHVlcyBpbnRvIHRoZSBzdHJlYW0uXG5cbiBJdCBhbHNvIGFsbG93cyBwbHVnZ2luZyBvdGhlciBzdHJlYW1zIGludG8gdGhlIEJ1cywgYXMgaW5wdXRzLiBUaGUgQnVzIHByYWN0aWNhbGx5XG4gbWVyZ2VzIGFsbCBwbHVnZ2VkLWluIHN0cmVhbXMgYW5kIHRoZSB2YWx1ZXMgcHVzaGVkIHVzaW5nIHRoZSBbYHB1c2hgXSgjcHVzaClcbiBtZXRob2QuXG4gKi9cbnZhciBCdXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ1cywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCdXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldyBEZXNjKFwiQmFjb25cIiwgXCJCdXNcIiwgW10pLCBmdW5jdGlvbiAoc2luaykgeyByZXR1cm4gX3RoaXMuc3Vic2NyaWJlQWxsKHNpbmspOyB9KSB8fCB0aGlzO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICBfdGhpcy5wdXNoaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIF90aGlzLnB1c2hRdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgX3RoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgICAgICBfdGhpcy51bnN1YkFsbCA9IF8uYmluZChfdGhpcy51bnN1YkFsbCwgX3RoaXMpO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0gW107IC8vIG5ldyBhcnJheSBmb3IgZWFjaCBCdXMgaW5zdGFuY2VcbiAgICAgICAgX3RoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgUGx1Z3MgdGhlIGdpdmVuIHN0cmVhbSBhcyBhbiBpbnB1dCB0byB0aGUgQnVzLiBBbGwgZXZlbnRzIGZyb21cbiAgICAgdGhlIGdpdmVuIHN0cmVhbSB3aWxsIGJlIGRlbGl2ZXJlZCB0byB0aGUgc3Vic2NyaWJlcnMgb2YgdGhlIEJ1cy5cbiAgICAgUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gdW5wbHVnIHRoZSBzYW1lIHN0cmVhbS5cbiAgXG4gICAgIFRoZSBwbHVnIG1ldGhvZCBwcmFjdGljYWxseSBhbGxvd3MgeW91IHRvIG1lcmdlIGluIG90aGVyIHN0cmVhbXMgYWZ0ZXJcbiAgICAgdGhlIGNyZWF0aW9uIG9mIHRoZSBCdXMuXG4gIFxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHRvIFwidW5wbHVnXCIgdGhlIHNvdXJjZSBmcm9tIEJ1cy5cbiAgICAgKi9cbiAgICBCdXMucHJvdG90eXBlLnBsdWcgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgYXNzZXJ0T2JzZXJ2YWJsZShpbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YiA9IHsgaW5wdXQ6IGlucHV0LCB1bnN1YjogdW5kZWZpbmVkIH07XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHN1Yik7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaW5rICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZUlucHV0KHN1Yik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51bnN1YnNjcmliZUlucHV0KGlucHV0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgRW5kcyB0aGUgc3RyZWFtLiBTZW5kcyBhbiBbRW5kXShlbmQuaHRtbCkgZXZlbnQgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgICBBZnRlciB0aGlzIGNhbGwsIHRoZXJlJ2xsIGJlIG5vIG1vcmUgZXZlbnRzIHRvIHRoZSBzdWJzY3JpYmVycy5cbiAgICAgQWxzbywgdGhlIFtgcHVzaGBdKCNwdXNoKSwgW2BlcnJvcmBdKCNlcnJvcikgYW5kIFtgcGx1Z2BdKCNwbHVnKSBtZXRob2RzIGhhdmUgbm8gZWZmZWN0LlxuICAgICAqL1xuICAgIEJ1cy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bnN1YkFsbCgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2luayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaW5rKGVuZEV2ZW50KCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBuZXcgdmFsdWUgdG8gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBCdXMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuZGVkICYmIHR5cGVvZiB0aGlzLnNpbmsgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIHJvb3RQdXNoID0gIXRoaXMucHVzaGluZztcbiAgICAgICAgICAgIGlmICghcm9vdFB1c2gpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVjdXJzaXZlIHB1c2hcIilcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHVzaFF1ZXVlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaFF1ZXVlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3F1ZXVlZCcsIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbmsobmV4dEV2ZW50KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAocm9vdFB1c2ggJiYgdGhpcy5wdXNoUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInN0YXJ0IHByb2Nlc3NpbmcgcXVldWVcIiwgdGhpcy5wdXNoUXVldWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5wdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiaW4gbG9vcFwiLCBpLCB0aGlzLnB1c2hRdWV1ZVtpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5wdXNoUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpbmsobmV4dEV2ZW50KHYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hRdWV1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlcnJvciB0byB0aGlzIHN0cmVhbS5cbiAgICAgKi9cbiAgICBCdXMucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zaW5rID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbmsobmV3IEVycm9yJDEoZXJyb3IpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBCdXMucHJvdG90eXBlLnVuc3ViQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBzdWI7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3ViID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1Yi51bnN1YiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgc3ViLnVuc3ViKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQnVzLnByb3RvdHlwZS5zdWJzY3JpYmVBbGwgPSBmdW5jdGlvbiAobmV3U2luaykge1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgbmV3U2luayhlbmRFdmVudCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2luayA9IG5ld1Npbms7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGUgPSB0aGlzLnN1YnNjcmlwdGlvbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBzdWJzY3JpcHRpb247IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlSW5wdXQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bnN1YkFsbDtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQnVzLnByb3RvdHlwZS5ndWFyZGVkU2luayA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuaXNFbmQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51bnN1YnNjcmliZUlucHV0KGlucHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9Nb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuc2luaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaW5rKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBCdXMucHJvdG90eXBlLnN1YnNjcmliZUlucHV0ID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWIgPSBzdWJzY3JpcHRpb24uaW5wdXQuc3Vic2NyaWJlSW50ZXJuYWwodGhpcy5ndWFyZGVkU2luayhzdWJzY3JpcHRpb24uaW5wdXQpKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbi51bnN1YjtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQnVzLnByb3RvdHlwZS51bnN1YnNjcmliZUlucHV0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IHRoaXMuc3Vic2NyaXB0aW9ucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHN1YjsgaSA8IGl0ZXJhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdWIgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgIGlmIChzdWIuaW5wdXQgPT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWIudW5zdWIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBCdXM7XG59KEV2ZW50U3RyZWFtKSk7XG5cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiB0cnlGKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gb25jZShmKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvbmNlKG5ldyBFcnJvciQxKGUpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogSlF1ZXJ5L1plcHRvIGludGVncmF0aW9uIHN1cHBvcnRcbiAqL1xudmFyICQgPSB7XG4gICAgLyoqXG4gICAgIENyZWF0ZXMgYW4gRXZlbnRTdHJlYW0gZnJvbSBldmVudHMgb24gYVxuICAgICBqUXVlcnkgb3IgWmVwdG8uanMgb2JqZWN0LiBZb3UgY2FuIHBhc3Mgb3B0aW9uYWwgYXJndW1lbnRzIHRvIGFkZCBhXG4gICAgIGpRdWVyeSBsaXZlIHNlbGVjdG9yIGFuZC9vciBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIHRoZSBqUXVlcnlcbiAgICAgZXZlbnQgYW5kIGl0cyBwYXJhbWV0ZXJzLCBpZiBnaXZlbiwgbGlrZSB0aGlzOlxuICBcbiAgICAgYGBganNcbiAgICAgJChcIiNteS1kaXZcIikuYXNFdmVudFN0cmVhbShcImNsaWNrXCIsIFwiLm1vcmUtc3BlY2lmaWMtc2VsZWN0b3JcIilcbiAgICAgJChcIiNteS1kaXZcIikuYXNFdmVudFN0cmVhbShcImNsaWNrXCIsIFwiLm1vcmUtc3BlY2lmaWMtc2VsZWN0b3JcIiwgZnVuY3Rpb24oZXZlbnQsIGFyZ3MpIHsgcmV0dXJuIGFyZ3NbMF0gfSlcbiAgICAgJChcIiNteS1kaXZcIikuYXNFdmVudFN0cmVhbShcImNsaWNrXCIsIGZ1bmN0aW9uKGV2ZW50LCBhcmdzKSB7IHJldHVybiBhcmdzWzBdIH0pXG4gICAgIGBgYFxuICBcbiAgICAgTm90ZTogeW91IG5lZWQgdG8gaW5zdGFsbCB0aGUgYGFzRXZlbnRTdHJlYW1gIG1ldGhvZCBvbiBKUXVlcnkgYnkgY2FsbGluZ1xuICAgICBbaW5pdCgpXSgjXy5hc2V2ZW50c3RyZWFtKSBhcyBpbiBgQmFjb24uJC5pbml0KCQpYC5cbiAgICAgKi9cbiAgICBhc0V2ZW50U3RyZWFtOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBzZWxlY3RvciwgZXZlbnRUcmFuc2Zvcm1lcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgZXZlbnRUcmFuc2Zvcm1lciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb21CaW5kZXIoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIF90aGlzLm9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vZmYoZXZlbnROYW1lLCBzZWxlY3RvciwgaGFuZGxlcik7IH0pO1xuICAgICAgICB9LCBldmVudFRyYW5zZm9ybWVyKS53aXRoRGVzYyhuZXcgRGVzYyh0aGlzLnNlbGVjdG9yIHx8IHRoaXMsIFwiYXNFdmVudFN0cmVhbVwiLCBbZXZlbnROYW1lXSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW5zdGFsbHMgdGhlIFthc0V2ZW50U3RyZWFtXSgjXy5hc2V2ZW50c3RyZWFtKSB0byB0aGUgZ2l2ZW4galF1ZXJ5L1plcHRvIG9iamVjdCAodGhlIGAkYCBvYmplY3QpLlxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIChqUXVlcnkpIHtcbiAgICAgICAgalF1ZXJ5LmZuLmFzRXZlbnRTdHJlYW0gPSAkLmFzRXZlbnRTdHJlYW07XG4gICAgfVxufTtcblxuLyoqXG4gKiAgQmFjb24uanMgdmVyc2lvbiBhcyBzdHJpbmdcbiAqL1xudmFyIHZlcnNpb24gPSAnMy4wLjEyJztcblxuZXhwb3J0cy4kID0gJDtcbmV4cG9ydHMuQnVzID0gQnVzO1xuZXhwb3J0cy5Db21wb3NpdGVVbnN1YnNjcmliZSA9IENvbXBvc2l0ZVVuc3Vic2NyaWJlO1xuZXhwb3J0cy5EZXNjID0gRGVzYztcbmV4cG9ydHMuRW5kID0gRW5kO1xuZXhwb3J0cy5FcnJvciA9IEVycm9yJDE7XG5leHBvcnRzLkV2ZW50ID0gRXZlbnQ7XG5leHBvcnRzLkV2ZW50U3RyZWFtID0gRXZlbnRTdHJlYW07XG5leHBvcnRzLkluaXRpYWwgPSBJbml0aWFsO1xuZXhwb3J0cy5OZXh0ID0gTmV4dDtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG5leHBvcnRzLlByb3BlcnR5ID0gUHJvcGVydHk7XG5leHBvcnRzLlZhbHVlID0gVmFsdWU7XG5leHBvcnRzLl8gPSBfO1xuZXhwb3J0cy5jb21iaW5lID0gY29tYmluZTtcbmV4cG9ydHMuY29tYmluZUFzQXJyYXkgPSBjb21iaW5lQXNBcnJheTtcbmV4cG9ydHMuY29tYmluZVRlbXBsYXRlID0gY29tYmluZVRlbXBsYXRlO1xuZXhwb3J0cy5jb21iaW5lV2l0aCA9IGNvbWJpbmVXaXRoO1xuZXhwb3J0cy5jb25jYXRBbGwgPSBjb25jYXRBbGw7XG5leHBvcnRzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5leHBvcnRzLmZyb21BcnJheSA9IGZyb21BcnJheTtcbmV4cG9ydHMuZnJvbUJpbmRlciA9IGZyb21CaW5kZXI7XG5leHBvcnRzLmZyb21DYWxsYmFjayA9IGZyb21DYWxsYmFjaztcbmV4cG9ydHMuZnJvbUVTT2JzZXJ2YWJsZSA9IGZyb21FU09ic2VydmFibGU7XG5leHBvcnRzLmZyb21FdmVudCA9IGZyb21FdmVudDtcbmV4cG9ydHMuZnJvbUV2ZW50VGFyZ2V0ID0gZnJvbUV2ZW50O1xuZXhwb3J0cy5mcm9tTm9kZUNhbGxiYWNrID0gZnJvbU5vZGVDYWxsYmFjaztcbmV4cG9ydHMuZnJvbVBvbGwgPSBmcm9tUG9sbDtcbmV4cG9ydHMuZnJvbVByb21pc2UgPSBmcm9tUHJvbWlzZTtcbmV4cG9ydHMuZ2V0U2NoZWR1bGVyID0gZ2V0U2NoZWR1bGVyO1xuZXhwb3J0cy5ncm91cFNpbXVsdGFuZW91cyA9IGdyb3VwU2ltdWx0YW5lb3VzO1xuZXhwb3J0cy5oYXNWYWx1ZSA9IGhhc1ZhbHVlO1xuZXhwb3J0cy5pbnRlcnZhbCA9IGludGVydmFsO1xuZXhwb3J0cy5pc0VuZCA9IGlzRW5kO1xuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMuaXNFdmVudCA9IGlzRXZlbnQ7XG5leHBvcnRzLmlzSW5pdGlhbCA9IGlzSW5pdGlhbDtcbmV4cG9ydHMuaXNOZXh0ID0gaXNOZXh0O1xuZXhwb3J0cy5sYXRlciA9IGxhdGVyO1xuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuZXhwb3J0cy5tb3JlID0gbW9yZTtcbmV4cG9ydHMubmV2ZXIgPSBuZXZlcjtcbmV4cG9ydHMubm9Nb3JlID0gbm9Nb3JlO1xuZXhwb3J0cy5udWxsU2luayA9IG51bGxTaW5rO1xuZXhwb3J0cy5udWxsVm9pZFNpbmsgPSBudWxsVm9pZFNpbms7XG5leHBvcnRzLm9uVmFsdWVzID0gb25WYWx1ZXM7XG5leHBvcnRzLm9uY2UgPSBvbmNlO1xuZXhwb3J0cy5yZXBlYXQgPSByZXBlYXQ7XG5leHBvcnRzLnJlcGVhdGVkbHkgPSByZXBlYXRlZGx5O1xuZXhwb3J0cy5yZXRyeSA9IHJldHJ5O1xuZXhwb3J0cy5zZXF1ZW50aWFsbHkgPSBzZXF1ZW50aWFsbHk7XG5leHBvcnRzLnNldFNjaGVkdWxlciA9IHNldFNjaGVkdWxlcjtcbmV4cG9ydHMuc2lsZW5jZSA9IHNpbGVuY2U7XG5leHBvcnRzLnNweSA9IHNweTtcbmV4cG9ydHMudHJ5ID0gdHJ5RjtcbmV4cG9ydHMudXBkYXRlID0gdXBkYXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMud2hlbiA9IHdoZW47XG5leHBvcnRzLnppcEFzQXJyYXkgPSB6aXBBc0FycmF5O1xuZXhwb3J0cy56aXBXaXRoID0gemlwV2l0aDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vLyBVc2VkIGZvciBzZXR0aW5nIHByb3RvdHlwZSBtZXRob2RzIHRoYXQgSUU4IGNob2tlcyBvbi5cbnZhciBERUxFVEUgPSAnZGVsZXRlJztcblxuLy8gQ29uc3RhbnRzIGRlc2NyaWJpbmcgdGhlIHNpemUgb2YgdHJpZSBub2Rlcy5cbnZhciBTSElGVCA9IDU7IC8vIFJlc3VsdGVkIGluIGJlc3QgcGVyZm9ybWFuY2UgYWZ0ZXIgX19fX19fP1xudmFyIFNJWkUgPSAxIDw8IFNISUZUO1xudmFyIE1BU0sgPSBTSVpFIC0gMTtcblxuLy8gQSBjb25zaXN0ZW50IHNoYXJlZCB2YWx1ZSByZXByZXNlbnRpbmcgXCJub3Qgc2V0XCIgd2hpY2ggZXF1YWxzIG5vdGhpbmcgb3RoZXJcbi8vIHRoYW4gaXRzZWxmLCBhbmQgbm90aGluZyB0aGF0IGNvdWxkIGJlIHByb3ZpZGVkIGV4dGVybmFsbHkuXG52YXIgTk9UX1NFVCA9IHt9O1xuXG4vLyBCb29sZWFuIHJlZmVyZW5jZXMsIFJvdWdoIGVxdWl2YWxlbnQgb2YgYGJvb2wgJmAuXG5mdW5jdGlvbiBNYWtlUmVmKCkge1xuICByZXR1cm4geyB2YWx1ZTogZmFsc2UgfTtcbn1cblxuZnVuY3Rpb24gU2V0UmVmKHJlZikge1xuICBpZiAocmVmKSB7XG4gICAgcmVmLnZhbHVlID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSB2YWx1ZSByZXByZXNlbnRpbmcgYW4gXCJvd25lclwiIGZvciB0cmFuc2llbnQgd3JpdGVzXG4vLyB0byB0cmllcy4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIG9ubHkgZXZlciBlcXVhbCBpdHNlbGYsIGFuZCB3aWxsIG5vdCBlcXVhbFxuLy8gdGhlIHJldHVybiBvZiBhbnkgc3Vic2VxdWVudCBjYWxsIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBPd25lcklEKCkge31cblxuZnVuY3Rpb24gZW5zdXJlU2l6ZShpdGVyKSB7XG4gIGlmIChpdGVyLnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIGl0ZXIuc2l6ZSA9IGl0ZXIuX19pdGVyYXRlKHJldHVyblRydWUpO1xuICB9XG4gIHJldHVybiBpdGVyLnNpemU7XG59XG5cbmZ1bmN0aW9uIHdyYXBJbmRleChpdGVyLCBpbmRleCkge1xuICAvLyBUaGlzIGltcGxlbWVudHMgXCJpcyBhcnJheSBpbmRleFwiIHdoaWNoIHRoZSBFQ01BU3RyaW5nIHNwZWMgZGVmaW5lcyBhczpcbiAgLy9cbiAgLy8gICAgIEEgU3RyaW5nIHByb3BlcnR5IG5hbWUgUCBpcyBhbiBhcnJheSBpbmRleCBpZiBhbmQgb25seSBpZlxuICAvLyAgICAgVG9TdHJpbmcoVG9VaW50MzIoUCkpIGlzIGVxdWFsIHRvIFAgYW5kIFRvVWludDMyKFApIGlzIG5vdCBlcXVhbFxuICAvLyAgICAgdG8gMl4zMuKIkjEuXG4gIC8vXG4gIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1hcnJheS1leG90aWMtb2JqZWN0c1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgIHZhciB1aW50MzJJbmRleCA9IGluZGV4ID4+PiAwOyAvLyBOID4+PiAwIGlzIHNob3J0aGFuZCBmb3IgVG9VaW50MzJcbiAgICBpZiAoJycgKyB1aW50MzJJbmRleCAhPT0gaW5kZXggfHwgdWludDMySW5kZXggPT09IDQyOTQ5NjcyOTUpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGluZGV4ID0gdWludDMySW5kZXg7XG4gIH1cbiAgcmV0dXJuIGluZGV4IDwgMCA/IGVuc3VyZVNpemUoaXRlcikgKyBpbmRleCA6IGluZGV4O1xufVxuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSB7XG4gIHJldHVybiAoXG4gICAgKChiZWdpbiA9PT0gMCAmJiAhaXNOZWcoYmVnaW4pKSB8fFxuICAgICAgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBiZWdpbiA8PSAtc2l6ZSkpICYmXG4gICAgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IChzaXplICE9PSB1bmRlZmluZWQgJiYgZW5kID49IHNpemUpKVxuICApO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQmVnaW4oYmVnaW4sIHNpemUpIHtcbiAgcmV0dXJuIHJlc29sdmVJbmRleChiZWdpbiwgc2l6ZSwgMCk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBzaXplKSB7XG4gIHJldHVybiByZXNvbHZlSW5kZXgoZW5kLCBzaXplLCBzaXplKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluZGV4KGluZGV4LCBzaXplLCBkZWZhdWx0SW5kZXgpIHtcbiAgLy8gU2FuaXRpemUgaW5kaWNlcyB1c2luZyB0aGlzIHNob3J0aGFuZCBmb3IgVG9JbnQzMihhcmd1bWVudClcbiAgLy8gaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXRvaW50MzJcbiAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWRcbiAgICA/IGRlZmF1bHRJbmRleFxuICAgIDogaXNOZWcoaW5kZXgpXG4gICAgICA/IHNpemUgPT09IEluZmluaXR5XG4gICAgICAgID8gc2l6ZVxuICAgICAgICA6IE1hdGgubWF4KDAsIHNpemUgKyBpbmRleCkgfCAwXG4gICAgICA6IHNpemUgPT09IHVuZGVmaW5lZCB8fCBzaXplID09PSBpbmRleFxuICAgICAgICA/IGluZGV4XG4gICAgICAgIDogTWF0aC5taW4oc2l6ZSwgaW5kZXgpIHwgMDtcbn1cblxuZnVuY3Rpb24gaXNOZWcodmFsdWUpIHtcbiAgLy8gQWNjb3VudCBmb3IgLTAgd2hpY2ggaXMgbmVnYXRpdmUsIGJ1dCBub3QgbGVzcyB0aGFuIDAuXG4gIHJldHVybiB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gLUluZmluaXR5KTtcbn1cblxuLy8gTm90ZTogdmFsdWUgaXMgdW5jaGFuZ2VkIHRvIG5vdCBicmVhayBpbW11dGFibGUtZGV2dG9vbHMuXG52YXIgSVNfQ09MTEVDVElPTl9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9JVEVSQUJMRV9fQEAnO1xuXG5mdW5jdGlvbiBpc0NvbGxlY3Rpb24obWF5YmVDb2xsZWN0aW9uKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlQ29sbGVjdGlvbiAmJiBtYXliZUNvbGxlY3Rpb25bSVNfQ09MTEVDVElPTl9TWU1CT0xdKTtcbn1cblxudmFyIElTX0tFWUVEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0tFWUVEX19AQCc7XG5cbmZ1bmN0aW9uIGlzS2V5ZWQobWF5YmVLZXllZCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZUtleWVkICYmIG1heWJlS2V5ZWRbSVNfS0VZRURfU1lNQk9MXSk7XG59XG5cbnZhciBJU19JTkRFWEVEX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJztcblxuZnVuY3Rpb24gaXNJbmRleGVkKG1heWJlSW5kZXhlZCkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZUluZGV4ZWQgJiYgbWF5YmVJbmRleGVkW0lTX0lOREVYRURfU1lNQk9MXSk7XG59XG5cbmZ1bmN0aW9uIGlzQXNzb2NpYXRpdmUobWF5YmVBc3NvY2lhdGl2ZSkge1xuICByZXR1cm4gaXNLZXllZChtYXliZUFzc29jaWF0aXZlKSB8fCBpc0luZGV4ZWQobWF5YmVBc3NvY2lhdGl2ZSk7XG59XG5cbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNDb2xsZWN0aW9uKHZhbHVlKSA/IHZhbHVlIDogU2VxKHZhbHVlKTtcbn07XG5cbnZhciBLZXllZENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEtleWVkQ29sbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBpc0tleWVkKHZhbHVlKSA/IHZhbHVlIDogS2V5ZWRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgS2V5ZWRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlICk7XG4gIEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXllZENvbGxlY3Rpb247XG5cbiAgcmV0dXJuIEtleWVkQ29sbGVjdGlvbjtcbn0oQ29sbGVjdGlvbikpO1xuXG52YXIgSW5kZXhlZENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIEluZGV4ZWRDb2xsZWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzSW5kZXhlZCh2YWx1ZSkgPyB2YWx1ZSA6IEluZGV4ZWRTZXEodmFsdWUpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uICkgSW5kZXhlZENvbGxlY3Rpb24uX19wcm90b19fID0gQ29sbGVjdGlvbjtcbiAgSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleGVkQ29sbGVjdGlvbjtcblxuICByZXR1cm4gSW5kZXhlZENvbGxlY3Rpb247XG59KENvbGxlY3Rpb24pKTtcblxudmFyIFNldENvbGxlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDb2xsZWN0aW9uKSB7XG4gIGZ1bmN0aW9uIFNldENvbGxlY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHZhbHVlKSAmJiAhaXNBc3NvY2lhdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IFNldFNlcSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIENvbGxlY3Rpb24gKSBTZXRDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IENvbGxlY3Rpb247XG4gIFNldENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZSApO1xuICBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldENvbGxlY3Rpb247XG5cbiAgcmV0dXJuIFNldENvbGxlY3Rpb247XG59KENvbGxlY3Rpb24pKTtcblxuQ29sbGVjdGlvbi5LZXllZCA9IEtleWVkQ29sbGVjdGlvbjtcbkNvbGxlY3Rpb24uSW5kZXhlZCA9IEluZGV4ZWRDb2xsZWN0aW9uO1xuQ29sbGVjdGlvbi5TZXQgPSBTZXRDb2xsZWN0aW9uO1xuXG52YXIgSVNfU0VRX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NFUV9fQEAnO1xuXG5mdW5jdGlvbiBpc1NlcShtYXliZVNlcSkge1xuICByZXR1cm4gQm9vbGVhbihtYXliZVNlcSAmJiBtYXliZVNlcVtJU19TRVFfU1lNQk9MXSk7XG59XG5cbnZhciBJU19SRUNPUkRfU1lNQk9MID0gJ0BAX19JTU1VVEFCTEVfUkVDT1JEX19AQCc7XG5cbmZ1bmN0aW9uIGlzUmVjb3JkKG1heWJlUmVjb3JkKSB7XG4gIHJldHVybiBCb29sZWFuKG1heWJlUmVjb3JkICYmIG1heWJlUmVjb3JkW0lTX1JFQ09SRF9TWU1CT0xdKTtcbn1cblxuZnVuY3Rpb24gaXNJbW11dGFibGUobWF5YmVJbW11dGFibGUpIHtcbiAgcmV0dXJuIGlzQ29sbGVjdGlvbihtYXliZUltbXV0YWJsZSkgfHwgaXNSZWNvcmQobWF5YmVJbW11dGFibGUpO1xufVxuXG52YXIgSVNfT1JERVJFRF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCc7XG5cbmZ1bmN0aW9uIGlzT3JkZXJlZChtYXliZU9yZGVyZWQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVPcmRlcmVkICYmIG1heWJlT3JkZXJlZFtJU19PUkRFUkVEX1NZTUJPTF0pO1xufVxuXG52YXIgSVRFUkFURV9LRVlTID0gMDtcbnZhciBJVEVSQVRFX1ZBTFVFUyA9IDE7XG52YXIgSVRFUkFURV9FTlRSSUVTID0gMjtcblxudmFyIFJFQUxfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSBSRUFMX0lURVJBVE9SX1NZTUJPTCB8fCBGQVVYX0lURVJBVE9SX1NZTUJPTDtcblxudmFyIEl0ZXJhdG9yID0gZnVuY3Rpb24gSXRlcmF0b3IobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuSXRlcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gJ1tJdGVyYXRvcl0nO1xufTtcblxuSXRlcmF0b3IuS0VZUyA9IElURVJBVEVfS0VZUztcbkl0ZXJhdG9yLlZBTFVFUyA9IElURVJBVEVfVkFMVUVTO1xuSXRlcmF0b3IuRU5UUklFUyA9IElURVJBVEVfRU5UUklFUztcblxuSXRlcmF0b3IucHJvdG90eXBlLmluc3BlY3QgPSBJdGVyYXRvci5wcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5JdGVyYXRvci5wcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGl0ZXJhdG9yVmFsdWUodHlwZSwgaywgdiwgaXRlcmF0b3JSZXN1bHQpIHtcbiAgdmFyIHZhbHVlID0gdHlwZSA9PT0gMCA/IGsgOiB0eXBlID09PSAxID8gdiA6IFtrLCB2XTtcbiAgaXRlcmF0b3JSZXN1bHRcbiAgICA/IChpdGVyYXRvclJlc3VsdC52YWx1ZSA9IHZhbHVlKVxuICAgIDogKGl0ZXJhdG9yUmVzdWx0ID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgfSk7XG4gIHJldHVybiBpdGVyYXRvclJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXRlcmF0b3JEb25lKCkge1xuICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG59XG5cbmZ1bmN0aW9uIGhhc0l0ZXJhdG9yKG1heWJlSXRlcmFibGUpIHtcbiAgcmV0dXJuICEhZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKTtcbn1cblxuZnVuY3Rpb24gaXNJdGVyYXRvcihtYXliZUl0ZXJhdG9yKSB7XG4gIHJldHVybiBtYXliZUl0ZXJhdG9yICYmIHR5cGVvZiBtYXliZUl0ZXJhdG9yLm5leHQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihpdGVyYWJsZSk7XG4gIHJldHVybiBpdGVyYXRvckZuICYmIGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZSk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4oaXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPVxuICAgIGl0ZXJhYmxlICYmXG4gICAgKChSRUFMX0lURVJBVE9SX1NZTUJPTCAmJiBpdGVyYWJsZVtSRUFMX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgICBpdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgfVxufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlLmxlbmd0aCkgJiZcbiAgICB2YWx1ZS5sZW5ndGggPj0gMCAmJlxuICAgICh2YWx1ZS5sZW5ndGggPT09IDBcbiAgICAgID8gLy8gT25seSB7bGVuZ3RoOiAwfSBpcyBjb25zaWRlcmVkIEFycmF5LWxpa2UuXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDFcbiAgICAgIDogLy8gQW4gb2JqZWN0IGlzIG9ubHkgQXJyYXktbGlrZSBpZiBpdCBoYXMgYSBwcm9wZXJ0eSB3aGVyZSB0aGUgbGFzdCB2YWx1ZVxuICAgICAgICAvLyBpbiB0aGUgYXJyYXktbGlrZSBtYXkgYmUgZm91bmQgKHdoaWNoIGNvdWxkIGJlIHVuZGVmaW5lZCkuXG4gICAgICAgIHZhbHVlLmhhc093blByb3BlcnR5KHZhbHVlLmxlbmd0aCAtIDEpKVxuICApO1xufVxuXG52YXIgU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQ29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBTZXEodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBlbXB0eVNlcXVlbmNlKClcbiAgICAgIDogaXNJbW11dGFibGUodmFsdWUpXG4gICAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgICA6IHNlcUZyb21WYWx1ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIENvbGxlY3Rpb24kJDEgKSBTZXEuX19wcm90b19fID0gQ29sbGVjdGlvbiQkMTtcbiAgU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24kJDEgJiYgQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgU2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlcTtcblxuICBTZXEucHJvdG90eXBlLnRvU2VxID0gZnVuY3Rpb24gdG9TZXEgKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFNlcS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIHsnLCAnfScpO1xuICB9O1xuXG4gIFNlcS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBmdW5jdGlvbiBjYWNoZVJlc3VsdCAoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZSAmJiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHRoaXMuZW50cnlTZXEoKS50b0FycmF5KCk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9jYWNoZS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIGFic3RyYWN0IF9faXRlcmF0ZVVuY2FjaGVkKGZuLCByZXZlcnNlKVxuXG4gIFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgdmFyIHNpemUgPSBjYWNoZS5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSAhPT0gc2l6ZSkge1xuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICAgIGlmIChmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UpO1xuICB9O1xuXG4gIC8vIGFic3RyYWN0IF9faXRlcmF0b3JVbmNhY2hlZCh0eXBlLCByZXZlcnNlKVxuXG4gIFNlcS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciBzaXplID0gY2FjaGUubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IGNhY2hlW3JldmVyc2UgPyBzaXplIC0gKytpIDogaSsrXTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yVW5jYWNoZWQodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgcmV0dXJuIFNlcTtcbn0oQ29sbGVjdGlvbikpO1xuXG52YXIgS2V5ZWRTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChTZXEpIHtcbiAgZnVuY3Rpb24gS2V5ZWRTZXEodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBlbXB0eVNlcXVlbmNlKCkudG9LZXllZFNlcSgpXG4gICAgICA6IGlzQ29sbGVjdGlvbih2YWx1ZSlcbiAgICAgICAgPyBpc0tleWVkKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUudG9TZXEoKVxuICAgICAgICAgIDogdmFsdWUuZnJvbUVudHJ5U2VxKClcbiAgICAgICAgOiBpc1JlY29yZCh2YWx1ZSlcbiAgICAgICAgICA/IHZhbHVlLnRvU2VxKClcbiAgICAgICAgICA6IGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggU2VxICkgS2V5ZWRTZXEuX19wcm90b19fID0gU2VxO1xuICBLZXllZFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXEgJiYgU2VxLnByb3RvdHlwZSApO1xuICBLZXllZFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXllZFNlcTtcblxuICBLZXllZFNlcS5wcm90b3R5cGUudG9LZXllZFNlcSA9IGZ1bmN0aW9uIHRvS2V5ZWRTZXEgKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBLZXllZFNlcTtcbn0oU2VxKSk7XG5cbnZhciBJbmRleGVkU2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gIGZ1bmN0aW9uIEluZGV4ZWRTZXEodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBlbXB0eVNlcXVlbmNlKClcbiAgICAgIDogaXNDb2xsZWN0aW9uKHZhbHVlKVxuICAgICAgICA/IGlzS2V5ZWQodmFsdWUpXG4gICAgICAgICAgPyB2YWx1ZS5lbnRyeVNlcSgpXG4gICAgICAgICAgOiB2YWx1ZS50b0luZGV4ZWRTZXEoKVxuICAgICAgICA6IGlzUmVjb3JkKHZhbHVlKVxuICAgICAgICAgID8gdmFsdWUudG9TZXEoKS5lbnRyeVNlcSgpXG4gICAgICAgICAgOiBpbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICggU2VxICkgSW5kZXhlZFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gIEluZGV4ZWRTZXEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2VxICYmIFNlcS5wcm90b3R5cGUgKTtcbiAgSW5kZXhlZFNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbmRleGVkU2VxO1xuXG4gIEluZGV4ZWRTZXEub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiBJbmRleGVkU2VxKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgSW5kZXhlZFNlcS5wcm90b3R5cGUudG9JbmRleGVkU2VxID0gZnVuY3Rpb24gdG9JbmRleGVkU2VxICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBJbmRleGVkU2VxLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXEgWycsICddJyk7XG4gIH07XG5cbiAgcmV0dXJuIEluZGV4ZWRTZXE7XG59KFNlcSkpO1xuXG52YXIgU2V0U2VxID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2VxKSB7XG4gIGZ1bmN0aW9uIFNldFNlcSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNDb2xsZWN0aW9uKHZhbHVlKSAmJiAhaXNBc3NvY2lhdGl2ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogSW5kZXhlZFNlcSh2YWx1ZSlcbiAgICApLnRvU2V0U2VxKCk7XG4gIH1cblxuICBpZiAoIFNlcSApIFNldFNlcS5fX3Byb3RvX18gPSBTZXE7XG4gIFNldFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXEgJiYgU2VxLnByb3RvdHlwZSApO1xuICBTZXRTZXEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2V0U2VxO1xuXG4gIFNldFNlcS5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgcmV0dXJuIFNldFNlcShhcmd1bWVudHMpO1xuICB9O1xuXG4gIFNldFNlcS5wcm90b3R5cGUudG9TZXRTZXEgPSBmdW5jdGlvbiB0b1NldFNlcSAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIFNldFNlcTtcbn0oU2VxKSk7XG5cblNlcS5pc1NlcSA9IGlzU2VxO1xuU2VxLktleWVkID0gS2V5ZWRTZXE7XG5TZXEuU2V0ID0gU2V0U2VxO1xuU2VxLkluZGV4ZWQgPSBJbmRleGVkU2VxO1xuXG5TZXEucHJvdG90eXBlW0lTX1NFUV9TWU1CT0xdID0gdHJ1ZTtcblxuLy8gI3ByYWdtYSBSb290IFNlcXVlbmNlc1xuXG52YXIgQXJyYXlTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxKSB7XG4gIGZ1bmN0aW9uIEFycmF5U2VxKGFycmF5KSB7XG4gICAgdGhpcy5fYXJyYXkgPSBhcnJheTtcbiAgICB0aGlzLnNpemUgPSBhcnJheS5sZW5ndGg7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEgKSBBcnJheVNlcS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICBBcnJheVNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxICYmIEluZGV4ZWRTZXEucHJvdG90eXBlICk7XG4gIEFycmF5U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5U2VxO1xuXG4gIEFycmF5U2VxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl9hcnJheVt3cmFwSW5kZXgodGhpcywgaW5kZXgpXSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5fYXJyYXk7XG4gICAgdmFyIHNpemUgPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICB2YXIgaWkgPSByZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrKztcbiAgICAgIGlmIChmbihhcnJheVtpaV0sIGlpLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIEFycmF5U2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuX2FycmF5O1xuICAgIHZhciBzaXplID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBpaSA9IHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaWksIGFycmF5W2lpXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEFycmF5U2VxO1xufShJbmRleGVkU2VxKSk7XG5cbnZhciBPYmplY3RTZXEgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSkge1xuICBmdW5jdGlvbiBPYmplY3RTZXEob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIHRoaXMuX29iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB0aGlzLnNpemUgPSBrZXlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICggS2V5ZWRTZXEgKSBPYmplY3RTZXEuX19wcm90b19fID0gS2V5ZWRTZXE7XG4gIE9iamVjdFNlcS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSAmJiBLZXllZFNlcS5wcm90b3R5cGUgKTtcbiAgT2JqZWN0U2VxLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9iamVjdFNlcTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIGlmIChub3RTZXRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vYmplY3Rba2V5XTtcbiAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwodGhpcy5fb2JqZWN0LCBrZXkpO1xuICB9O1xuXG4gIE9iamVjdFNlcS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgdmFyIGtleXMgPSB0aGlzLl9rZXlzO1xuICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICBpZiAoZm4ob2JqZWN0W2tleV0sIGtleSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICBPYmplY3RTZXEucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIG9iamVjdCA9IHRoaXMuX29iamVjdDtcbiAgICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gICAgdmFyIHNpemUgPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaSA9PT0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0ga2V5c1tyZXZlcnNlID8gc2l6ZSAtICsraSA6IGkrK107XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBrZXksIG9iamVjdFtrZXldKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gT2JqZWN0U2VxO1xufShLZXllZFNlcSkpO1xuT2JqZWN0U2VxLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG52YXIgQ29sbGVjdGlvblNlcSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEpIHtcbiAgZnVuY3Rpb24gQ29sbGVjdGlvblNlcShjb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgdGhpcy5zaXplID0gY29sbGVjdGlvbi5sZW5ndGggfHwgY29sbGVjdGlvbi5zaXplO1xuICB9XG5cbiAgaWYgKCBJbmRleGVkU2VxICkgQ29sbGVjdGlvblNlcS5fX3Byb3RvX18gPSBJbmRleGVkU2VxO1xuICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEgJiYgSW5kZXhlZFNlcS5wcm90b3R5cGUgKTtcbiAgQ29sbGVjdGlvblNlcS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2xsZWN0aW9uU2VxO1xuXG4gIENvbGxlY3Rpb25TZXEucHJvdG90eXBlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24gX19pdGVyYXRlVW5jYWNoZWQgKGZuLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIHZhciBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGNvbGxlY3Rpb24pO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICBpZiAoaXNJdGVyYXRvcihpdGVyYXRvcikpIHtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcblxuICBDb2xsZWN0aW9uU2VxLnByb3RvdHlwZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yVW5jYWNoZWQgKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbGVjdGlvbik7XG4gICAgaWYgKCFpc0l0ZXJhdG9yKGl0ZXJhdG9yKSkge1xuICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvcihpdGVyYXRvckRvbmUpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHJldHVybiBzdGVwLmRvbmUgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBDb2xsZWN0aW9uU2VxO1xufShJbmRleGVkU2VxKSk7XG5cbi8vICMgcHJhZ21hIEhlbHBlciBmdW5jdGlvbnNcblxudmFyIEVNUFRZX1NFUTtcblxuZnVuY3Rpb24gZW1wdHlTZXF1ZW5jZSgpIHtcbiAgcmV0dXJuIEVNUFRZX1NFUSB8fCAoRU1QVFlfU0VRID0gbmV3IEFycmF5U2VxKFtdKSk7XG59XG5cbmZ1bmN0aW9uIGtleWVkU2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gIHZhciBzZXEgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgID8gbmV3IEFycmF5U2VxKHZhbHVlKVxuICAgIDogaGFzSXRlcmF0b3IodmFsdWUpXG4gICAgICA/IG5ldyBDb2xsZWN0aW9uU2VxKHZhbHVlKVxuICAgICAgOiB1bmRlZmluZWQ7XG4gIGlmIChzZXEpIHtcbiAgICByZXR1cm4gc2VxLmZyb21FbnRyeVNlcSgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RTZXEodmFsdWUpO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ0V4cGVjdGVkIEFycmF5IG9yIGNvbGxlY3Rpb24gb2JqZWN0IG9mIFtrLCB2XSBlbnRyaWVzLCBvciBrZXllZCBvYmplY3Q6ICcgK1xuICAgICAgdmFsdWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gaW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICB2YXIgc2VxID0gbWF5YmVJbmRleGVkU2VxRnJvbVZhbHVlKHZhbHVlKTtcbiAgaWYgKHNlcSkge1xuICAgIHJldHVybiBzZXE7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnRXhwZWN0ZWQgQXJyYXkgb3IgY29sbGVjdGlvbiBvYmplY3Qgb2YgdmFsdWVzOiAnICsgdmFsdWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gc2VxRnJvbVZhbHVlKHZhbHVlKSB7XG4gIHZhciBzZXEgPSBtYXliZUluZGV4ZWRTZXFGcm9tVmFsdWUodmFsdWUpO1xuICBpZiAoc2VxKSB7XG4gICAgcmV0dXJuIHNlcTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBuZXcgT2JqZWN0U2VxKHZhbHVlKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdFeHBlY3RlZCBBcnJheSBvciBjb2xsZWN0aW9uIG9iamVjdCBvZiB2YWx1ZXMsIG9yIGtleWVkIG9iamVjdDogJyArIHZhbHVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIG1heWJlSW5kZXhlZFNlcUZyb21WYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheUxpa2UodmFsdWUpXG4gICAgPyBuZXcgQXJyYXlTZXEodmFsdWUpXG4gICAgOiBoYXNJdGVyYXRvcih2YWx1ZSlcbiAgICAgID8gbmV3IENvbGxlY3Rpb25TZXEodmFsdWUpXG4gICAgICA6IHVuZGVmaW5lZDtcbn1cblxudmFyIElTX01BUF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9NQVBfX0BAJztcblxuZnVuY3Rpb24gaXNNYXAobWF5YmVNYXApIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVNYXAgJiYgbWF5YmVNYXBbSVNfTUFQX1NZTUJPTF0pO1xufVxuXG5mdW5jdGlvbiBpc09yZGVyZWRNYXAobWF5YmVPcmRlcmVkTWFwKSB7XG4gIHJldHVybiBpc01hcChtYXliZU9yZGVyZWRNYXApICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRNYXApO1xufVxuXG5mdW5jdGlvbiBpc1ZhbHVlT2JqZWN0KG1heWJlVmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oXG4gICAgbWF5YmVWYWx1ZSAmJlxuICAgICAgdHlwZW9mIG1heWJlVmFsdWUuZXF1YWxzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgbWF5YmVWYWx1ZS5oYXNoQ29kZSA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgXCJzYW1lLXZhbHVlXCIgYWxnb3JpdGhtIGFzIFtkZXNjcmliZWQgZm9yIHVzZSBieSBFUzYgTWFwXG4gKiBhbmQgU2V0XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXAjS2V5X2VxdWFsaXR5KVxuICpcbiAqIE5hTiBpcyBjb25zaWRlcmVkIHRoZSBzYW1lIGFzIE5hTiwgaG93ZXZlciAtMCBhbmQgMCBhcmUgY29uc2lkZXJlZCB0aGUgc2FtZVxuICogdmFsdWUsIHdoaWNoIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGJ5XG4gKiBbYE9iamVjdC5pc2BdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pcykuXG4gKlxuICogVGhpcyBpcyBleHRlbmRlZCBmdXJ0aGVyIHRvIGFsbG93IE9iamVjdHMgdG8gZGVzY3JpYmUgdGhlIHZhbHVlcyB0aGV5XG4gKiByZXByZXNlbnQsIGJ5IHdheSBvZiBgdmFsdWVPZmAgb3IgYGVxdWFsc2AgKGFuZCBgaGFzaENvZGVgKS5cbiAqXG4gKiBOb3RlOiBiZWNhdXNlIG9mIHRoaXMgZXh0ZW5zaW9uLCB0aGUga2V5IGVxdWFsaXR5IG9mIEltbXV0YWJsZS5NYXAgYW5kIHRoZVxuICogdmFsdWUgZXF1YWxpdHkgb2YgSW1tdXRhYmxlLlNldCB3aWxsIGRpZmZlciBmcm9tIEVTNiBNYXAgYW5kIFNldC5cbiAqXG4gKiAjIyMgRGVmaW5pbmcgY3VzdG9tIHZhbHVlc1xuICpcbiAqIFRoZSBlYXNpZXN0IHdheSB0byBkZXNjcmliZSB0aGUgdmFsdWUgYW4gb2JqZWN0IHJlcHJlc2VudHMgaXMgYnkgaW1wbGVtZW50aW5nXG4gKiBgdmFsdWVPZmAuIEZvciBleGFtcGxlLCBgRGF0ZWAgcmVwcmVzZW50cyBhIHZhbHVlIGJ5IHJldHVybmluZyBhIHVuaXhcbiAqIHRpbWVzdGFtcCBmb3IgYHZhbHVlT2ZgOlxuICpcbiAqICAgICB2YXIgZGF0ZTEgPSBuZXcgRGF0ZSgxMjM0NTY3ODkwMDAwKTsgLy8gRnJpIEZlYiAxMyAyMDA5IC4uLlxuICogICAgIHZhciBkYXRlMiA9IG5ldyBEYXRlKDEyMzQ1Njc4OTAwMDApO1xuICogICAgIGRhdGUxLnZhbHVlT2YoKTsgLy8gMTIzNDU2Nzg5MDAwMFxuICogICAgIGFzc2VydCggZGF0ZTEgIT09IGRhdGUyICk7XG4gKiAgICAgYXNzZXJ0KCBJbW11dGFibGUuaXMoIGRhdGUxLCBkYXRlMiApICk7XG4gKlxuICogTm90ZTogb3ZlcnJpZGluZyBgdmFsdWVPZmAgbWF5IGhhdmUgb3RoZXIgaW1wbGljYXRpb25zIGlmIHlvdSB1c2UgdGhpcyBvYmplY3RcbiAqIHdoZXJlIEphdmFTY3JpcHQgZXhwZWN0cyBhIHByaW1pdGl2ZSwgc3VjaCBhcyBpbXBsaWNpdCBzdHJpbmcgY29lcmNpb24uXG4gKlxuICogRm9yIG1vcmUgY29tcGxleCB0eXBlcywgZXNwZWNpYWxseSBjb2xsZWN0aW9ucywgaW1wbGVtZW50aW5nIGB2YWx1ZU9mYCBtYXlcbiAqIG5vdCBiZSBwZXJmb3JtYW50LiBBbiBhbHRlcm5hdGl2ZSBpcyB0byBpbXBsZW1lbnQgYGVxdWFsc2AgYW5kIGBoYXNoQ29kZWAuXG4gKlxuICogYGVxdWFsc2AgdGFrZXMgYW5vdGhlciBvYmplY3QsIHByZXN1bWFibHkgb2Ygc2ltaWxhciB0eXBlLCBhbmQgcmV0dXJucyB0cnVlXG4gKiBpZiBpdCBpcyBlcXVhbC4gRXF1YWxpdHkgaXMgc3ltbWV0cmljYWwsIHNvIHRoZSBzYW1lIHJlc3VsdCBzaG91bGQgYmVcbiAqIHJldHVybmVkIGlmIHRoaXMgYW5kIHRoZSBhcmd1bWVudCBhcmUgZmxpcHBlZC5cbiAqXG4gKiAgICAgYXNzZXJ0KCBhLmVxdWFscyhiKSA9PT0gYi5lcXVhbHMoYSkgKTtcbiAqXG4gKiBgaGFzaENvZGVgIHJldHVybnMgYSAzMmJpdCBpbnRlZ2VyIG51bWJlciByZXByZXNlbnRpbmcgdGhlIG9iamVjdCB3aGljaCB3aWxsXG4gKiBiZSB1c2VkIHRvIGRldGVybWluZSBob3cgdG8gc3RvcmUgdGhlIHZhbHVlIG9iamVjdCBpbiBhIE1hcCBvciBTZXQuIFlvdSBtdXN0XG4gKiBwcm92aWRlIGJvdGggb3IgbmVpdGhlciBtZXRob2RzLCBvbmUgbXVzdCBub3QgZXhpc3Qgd2l0aG91dCB0aGUgb3RoZXIuXG4gKlxuICogQWxzbywgYW4gaW1wb3J0YW50IHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHRoZXNlIG1ldGhvZHMgbXVzdCBiZSB1cGhlbGQ6IGlmIHR3b1xuICogdmFsdWVzIGFyZSBlcXVhbCwgdGhleSAqbXVzdCogcmV0dXJuIHRoZSBzYW1lIGhhc2hDb2RlLiBJZiB0aGUgdmFsdWVzIGFyZSBub3RcbiAqIGVxdWFsLCB0aGV5IG1pZ2h0IGhhdmUgdGhlIHNhbWUgaGFzaENvZGU7IHRoaXMgaXMgY2FsbGVkIGEgaGFzaCBjb2xsaXNpb24sXG4gKiBhbmQgd2hpbGUgdW5kZXNpcmFibGUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0IGlzIGFjY2VwdGFibGUuXG4gKlxuICogICAgIGlmIChhLmVxdWFscyhiKSkge1xuICogICAgICAgYXNzZXJ0KCBhLmhhc2hDb2RlKCkgPT09IGIuaGFzaENvZGUoKSApO1xuICogICAgIH1cbiAqXG4gKiBBbGwgSW1tdXRhYmxlIGNvbGxlY3Rpb25zIGFyZSBWYWx1ZSBPYmplY3RzOiB0aGV5IGltcGxlbWVudCBgZXF1YWxzKClgXG4gKiBhbmQgYGhhc2hDb2RlKClgLlxuICovXG5mdW5jdGlvbiBpcyh2YWx1ZUEsIHZhbHVlQikge1xuICBpZiAodmFsdWVBID09PSB2YWx1ZUIgfHwgKHZhbHVlQSAhPT0gdmFsdWVBICYmIHZhbHVlQiAhPT0gdmFsdWVCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghdmFsdWVBIHx8ICF2YWx1ZUIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZUEudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZUIudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICB2YWx1ZUEgPSB2YWx1ZUEudmFsdWVPZigpO1xuICAgIHZhbHVlQiA9IHZhbHVlQi52YWx1ZU9mKCk7XG4gICAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCIHx8ICh2YWx1ZUEgIT09IHZhbHVlQSAmJiB2YWx1ZUIgIT09IHZhbHVlQikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlQSB8fCAhdmFsdWVCKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiAhIShcbiAgICBpc1ZhbHVlT2JqZWN0KHZhbHVlQSkgJiZcbiAgICBpc1ZhbHVlT2JqZWN0KHZhbHVlQikgJiZcbiAgICB2YWx1ZUEuZXF1YWxzKHZhbHVlQilcbiAgKTtcbn1cblxudmFyIGltdWwgPVxuICB0eXBlb2YgTWF0aC5pbXVsID09PSAnZnVuY3Rpb24nICYmIE1hdGguaW11bCgweGZmZmZmZmZmLCAyKSA9PT0gLTJcbiAgICA/IE1hdGguaW11bFxuICAgIDogZnVuY3Rpb24gaW11bChhLCBiKSB7XG4gICAgICAgIGEgfD0gMDsgLy8gaW50XG4gICAgICAgIGIgfD0gMDsgLy8gaW50XG4gICAgICAgIHZhciBjID0gYSAmIDB4ZmZmZjtcbiAgICAgICAgdmFyIGQgPSBiICYgMHhmZmZmO1xuICAgICAgICAvLyBTaGlmdCBieSAwIGZpeGVzIHRoZSBzaWduIG9uIHRoZSBoaWdoIHBhcnQuXG4gICAgICAgIHJldHVybiAoYyAqIGQgKyAoKCgoYSA+Pj4gMTYpICogZCArIGMgKiAoYiA+Pj4gMTYpKSA8PCAxNikgPj4+IDApKSB8IDA7IC8vIGludFxuICAgICAgfTtcblxuLy8gdjggaGFzIGFuIG9wdGltaXphdGlvbiBmb3Igc3RvcmluZyAzMS1iaXQgc2lnbmVkIG51bWJlcnMuXG4vLyBWYWx1ZXMgd2hpY2ggaGF2ZSBlaXRoZXIgMDAgb3IgMTEgYXMgdGhlIGhpZ2ggb3JkZXIgYml0cyBxdWFsaWZ5LlxuLy8gVGhpcyBmdW5jdGlvbiBkcm9wcyB0aGUgaGlnaGVzdCBvcmRlciBiaXQgaW4gYSBzaWduZWQgbnVtYmVyLCBtYWludGFpbmluZ1xuLy8gdGhlIHNpZ24gYml0LlxuZnVuY3Rpb24gc21pKGkzMikge1xuICByZXR1cm4gKChpMzIgPj4+IDEpICYgMHg0MDAwMDAwMCkgfCAoaTMyICYgMHhiZmZmZmZmZik7XG59XG5cbnZhciBkZWZhdWx0VmFsdWVPZiA9IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZjtcblxuZnVuY3Rpb24gaGFzaChvKSB7XG4gIHN3aXRjaCAodHlwZW9mIG8pIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIC8vIFRoZSBoYXNoIHZhbHVlcyBmb3IgYnVpbHQtaW4gY29uc3RhbnRzIGFyZSBhIDEgdmFsdWUgZm9yIGVhY2ggNS1ieXRlXG4gICAgICAvLyBzaGlmdCByZWdpb24gZXhwZWN0IGZvciB0aGUgZmlyc3QsIHdoaWNoIGVuY29kZXMgdGhlIHZhbHVlLiBUaGlzXG4gICAgICAvLyByZWR1Y2VzIHRoZSBvZGRzIG9mIGEgaGFzaCBjb2xsaXNpb24gZm9yIHRoZXNlIGNvbW1vbiB2YWx1ZXMuXG4gICAgICByZXR1cm4gbyA/IDB4NDIxMDg0MjEgOiAweDQyMTA4NDIwO1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaGFzaE51bWJlcihvKTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIG8ubGVuZ3RoID4gU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTlxuICAgICAgICA/IGNhY2hlZEhhc2hTdHJpbmcobylcbiAgICAgICAgOiBoYXNoU3RyaW5nKG8pO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgaWYgKG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDB4NDIxMDg0MjI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG8uaGFzaENvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRHJvcCBhbnkgaGlnaCBiaXRzIGZyb20gYWNjaWRlbnRhbGx5IGxvbmcgaGFzaCBjb2Rlcy5cbiAgICAgICAgcmV0dXJuIHNtaShvLmhhc2hDb2RlKG8pKTtcbiAgICAgIH1cbiAgICAgIGlmIChvLnZhbHVlT2YgIT09IGRlZmF1bHRWYWx1ZU9mICYmIHR5cGVvZiBvLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbyA9IG8udmFsdWVPZihvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNoSlNPYmoobyk7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiAweDQyMTA4NDIzO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIG8udG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hTdHJpbmcoby50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgdHlwZSAnICsgdHlwZW9mIG8gKyAnIGNhbm5vdCBiZSBoYXNoZWQuJyk7XG4gIH1cbn1cblxuLy8gQ29tcHJlc3MgYXJiaXRyYXJpbHkgbGFyZ2UgbnVtYmVycyBpbnRvIHNtaSBoYXNoZXMuXG5mdW5jdGlvbiBoYXNoTnVtYmVyKG4pIHtcbiAgaWYgKG4gIT09IG4gfHwgbiA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgaGFzaCA9IG4gfCAwO1xuICBpZiAoaGFzaCAhPT0gbikge1xuICAgIGhhc2ggXj0gbiAqIDB4ZmZmZmZmZmY7XG4gIH1cbiAgd2hpbGUgKG4gPiAweGZmZmZmZmZmKSB7XG4gICAgbiAvPSAweGZmZmZmZmZmO1xuICAgIGhhc2ggXj0gbjtcbiAgfVxuICByZXR1cm4gc21pKGhhc2gpO1xufVxuXG5mdW5jdGlvbiBjYWNoZWRIYXNoU3RyaW5nKHN0cmluZykge1xuICB2YXIgaGFzaGVkID0gc3RyaW5nSGFzaENhY2hlW3N0cmluZ107XG4gIGlmIChoYXNoZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIGhhc2hlZCA9IGhhc2hTdHJpbmcoc3RyaW5nKTtcbiAgICBpZiAoU1RSSU5HX0hBU0hfQ0FDSEVfU0laRSA9PT0gU1RSSU5HX0hBU0hfQ0FDSEVfTUFYX1NJWkUpIHtcbiAgICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xuICAgICAgc3RyaW5nSGFzaENhY2hlID0ge307XG4gICAgfVxuICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUrKztcbiAgICBzdHJpbmdIYXNoQ2FjaGVbc3RyaW5nXSA9IGhhc2hlZDtcbiAgfVxuICByZXR1cm4gaGFzaGVkO1xufVxuXG4vLyBodHRwOi8vanNwZXJmLmNvbS9oYXNoaW5nLXN0cmluZ3NcbmZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gIC8vIFRoaXMgaXMgdGhlIGhhc2ggZnJvbSBKVk1cbiAgLy8gVGhlIGhhc2ggY29kZSBmb3IgYSBzdHJpbmcgaXMgY29tcHV0ZWQgYXNcbiAgLy8gc1swXSAqIDMxIF4gKG4gLSAxKSArIHNbMV0gKiAzMSBeIChuIC0gMikgKyAuLi4gKyBzW24gLSAxXSxcbiAgLy8gd2hlcmUgc1tpXSBpcyB0aGUgaXRoIGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nIGFuZCBuIGlzIHRoZSBsZW5ndGggb2ZcbiAgLy8gdGhlIHN0cmluZy4gV2UgXCJtb2RcIiB0aGUgcmVzdWx0IHRvIG1ha2UgaXQgYmV0d2VlbiAwIChpbmNsdXNpdmUpIGFuZCAyXjMxXG4gIC8vIChleGNsdXNpdmUpIGJ5IGRyb3BwaW5nIGhpZ2ggYml0cy5cbiAgdmFyIGhhc2hlZCA9IDA7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBzdHJpbmcubGVuZ3RoOyBpaSsrKSB7XG4gICAgaGFzaGVkID0gKDMxICogaGFzaGVkICsgc3RyaW5nLmNoYXJDb2RlQXQoaWkpKSB8IDA7XG4gIH1cbiAgcmV0dXJuIHNtaShoYXNoZWQpO1xufVxuXG5mdW5jdGlvbiBoYXNoSlNPYmoob2JqKSB7XG4gIHZhciBoYXNoZWQ7XG4gIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICBoYXNoZWQgPSB3ZWFrTWFwLmdldChvYmopO1xuICAgIGlmIChoYXNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGhhc2hlZDtcbiAgICB9XG4gIH1cblxuICBoYXNoZWQgPSBvYmpbVUlEX0hBU0hfS0VZXTtcbiAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhhc2hlZDtcbiAgfVxuXG4gIGlmICghY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICBoYXNoZWQgPSBvYmoucHJvcGVydHlJc0VudW1lcmFibGUgJiYgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlW1VJRF9IQVNIX0tFWV07XG4gICAgaWYgKGhhc2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gaGFzaGVkO1xuICAgIH1cblxuICAgIGhhc2hlZCA9IGdldElFTm9kZUhhc2gob2JqKTtcbiAgICBpZiAoaGFzaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBoYXNoZWQ7XG4gICAgfVxuICB9XG5cbiAgaGFzaGVkID0gKytvYmpIYXNoVUlEO1xuICBpZiAob2JqSGFzaFVJRCAmIDB4NDAwMDAwMDApIHtcbiAgICBvYmpIYXNoVUlEID0gMDtcbiAgfVxuXG4gIGlmICh1c2luZ1dlYWtNYXApIHtcbiAgICB3ZWFrTWFwLnNldChvYmosIGhhc2hlZCk7XG4gIH0gZWxzZSBpZiAoaXNFeHRlbnNpYmxlICE9PSB1bmRlZmluZWQgJiYgaXNFeHRlbnNpYmxlKG9iaikgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tZXh0ZW5zaWJsZSBvYmplY3RzIGFyZSBub3QgYWxsb3dlZCBhcyBrZXlzLicpO1xuICB9IGVsc2UgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgVUlEX0hBU0hfS0VZLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogaGFzaGVkLFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKFxuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID09PSBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICkge1xuICAgIC8vIFNpbmNlIHdlIGNhbid0IGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICAvLyB3ZSdsbCBoaWphY2sgb25lIG9mIHRoZSBsZXNzLXVzZWQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0b1xuICAgIC8vIHNhdmUgb3VyIGhhc2ggb24gaXQuIFNpbmNlIHRoaXMgaXMgYSBmdW5jdGlvbiBpdCB3aWxsIG5vdCBzaG93IHVwIGluXG4gICAgLy8gYEpTT04uc3RyaW5naWZ5YCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuXG4gICAgb2JqLnByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuYXBwbHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGFyZ3VtZW50c1xuICAgICAgKTtcbiAgICB9O1xuICAgIG9iai5wcm9wZXJ0eUlzRW51bWVyYWJsZVtVSURfSEFTSF9LRVldID0gaGFzaGVkO1xuICB9IGVsc2UgaWYgKG9iai5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjb3VsZG4ndCBnZXQgdGhlIElFIGB1bmlxdWVJRGAgdG8gdXNlIGFzIGEgaGFzaFxuICAgIC8vIGFuZCB3ZSBjb3VsZG4ndCB1c2UgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSB0byBleHBsb2l0IHRoZVxuICAgIC8vIGRvbnRFbnVtIGJ1ZyBzbyB3ZSBzaW1wbHkgYWRkIHRoZSBgVUlEX0hBU0hfS0VZYCBvbiB0aGUgbm9kZVxuICAgIC8vIGl0c2VsZi5cbiAgICBvYmpbVUlEX0hBU0hfS0VZXSA9IGhhc2hlZDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBzZXQgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiBvYmplY3QuJyk7XG4gIH1cblxuICByZXR1cm4gaGFzaGVkO1xufVxuXG4vLyBHZXQgcmVmZXJlbmNlcyB0byBFUzUgb2JqZWN0IG1ldGhvZHMuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuLy8gVHJ1ZSBpZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgd29ya3MgYXMgZXhwZWN0ZWQuIElFOCBmYWlscyB0aGlzIHRlc3QuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnQCcsIHt9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLy8gSUUgaGFzIGEgYHVuaXF1ZUlEYCBwcm9wZXJ0eSBvbiBET00gbm9kZXMuIFdlIGNhbiBjb25zdHJ1Y3QgdGhlIGhhc2ggZnJvbSBpdFxuLy8gYW5kIGF2b2lkIG1lbW9yeSBsZWFrcyBmcm9tIHRoZSBJRSBjbG9uZU5vZGUgYnVnLlxuZnVuY3Rpb24gZ2V0SUVOb2RlSGFzaChub2RlKSB7XG4gIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPiAwKSB7XG4gICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICBjYXNlIDE6IC8vIEVsZW1lbnRcbiAgICAgICAgcmV0dXJuIG5vZGUudW5pcXVlSUQ7XG4gICAgICBjYXNlIDk6IC8vIERvY3VtZW50XG4gICAgICAgIHJldHVybiBub2RlLmRvY3VtZW50RWxlbWVudCAmJiBub2RlLmRvY3VtZW50RWxlbWVudC51bmlxdWVJRDtcbiAgICB9XG4gIH1cbn1cblxuLy8gSWYgcG9zc2libGUsIHVzZSBhIFdlYWtNYXAuXG52YXIgdXNpbmdXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbic7XG52YXIgd2Vha01hcDtcbmlmICh1c2luZ1dlYWtNYXApIHtcbiAgd2Vha01hcCA9IG5ldyBXZWFrTWFwKCk7XG59XG5cbnZhciBvYmpIYXNoVUlEID0gMDtcblxudmFyIFVJRF9IQVNIX0tFWSA9ICdfX2ltbXV0YWJsZWhhc2hfXyc7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBVSURfSEFTSF9LRVkgPSBTeW1ib2woVUlEX0hBU0hfS0VZKTtcbn1cblxudmFyIFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPSAxNjtcbnZhciBTVFJJTkdfSEFTSF9DQUNIRV9NQVhfU0laRSA9IDI1NTtcbnZhciBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbnZhciBzdHJpbmdIYXNoQ2FjaGUgPSB7fTtcblxudmFyIFRvS2V5ZWRTZXF1ZW5jZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEtleWVkU2VxJCQxKSB7XG4gIGZ1bmN0aW9uIFRvS2V5ZWRTZXF1ZW5jZShpbmRleGVkLCB1c2VLZXlzKSB7XG4gICAgdGhpcy5faXRlciA9IGluZGV4ZWQ7XG4gICAgdGhpcy5fdXNlS2V5cyA9IHVzZUtleXM7XG4gICAgdGhpcy5zaXplID0gaW5kZXhlZC5zaXplO1xuICB9XG5cbiAgaWYgKCBLZXllZFNlcSQkMSApIFRvS2V5ZWRTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcSQkMTtcbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkU2VxJCQxICYmIEtleWVkU2VxJCQxLnByb3RvdHlwZSApO1xuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9LZXllZFNlcXVlbmNlO1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuZ2V0KGtleSwgbm90U2V0VmFsdWUpO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlci5oYXMoa2V5KTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLnZhbHVlU2VxID0gZnVuY3Rpb24gdmFsdWVTZXEgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLnZhbHVlU2VxKCk7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpO1xuICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgcmV2ZXJzZWRTZXF1ZW5jZS52YWx1ZVNlcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5faXRlci50b1NlcSgpLnJldmVyc2UoKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gIH07XG5cbiAgVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpO1xuICAgIGlmICghdGhpcy5fdXNlS2V5cykge1xuICAgICAgbWFwcGVkU2VxdWVuY2UudmFsdWVTZXEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuX2l0ZXIudG9TZXEoKS5tYXAobWFwcGVyLCBjb250ZXh0KTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICB9O1xuXG4gIFRvS2V5ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCBrLCB0aGlzJDEpOyB9LCByZXZlcnNlKTtcbiAgfTtcblxuICBUb0tleWVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgfTtcblxuICByZXR1cm4gVG9LZXllZFNlcXVlbmNlO1xufShLZXllZFNlcSkpO1xuVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZVtJU19PUkRFUkVEX1NZTUJPTF0gPSB0cnVlO1xuXG52YXIgVG9JbmRleGVkU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJbmRleGVkU2VxJCQxKSB7XG4gIGZ1bmN0aW9uIFRvSW5kZXhlZFNlcXVlbmNlKGl0ZXIpIHtcbiAgICB0aGlzLl9pdGVyID0gaXRlcjtcbiAgICB0aGlzLnNpemUgPSBpdGVyLnNpemU7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRTZXEkJDEgKSBUb0luZGV4ZWRTZXF1ZW5jZS5fX3Byb3RvX18gPSBJbmRleGVkU2VxJCQxO1xuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbmRleGVkU2VxJCQxICYmIEluZGV4ZWRTZXEkJDEucHJvdG90eXBlICk7XG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvSW5kZXhlZFNlcXVlbmNlO1xuXG4gIFRvSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLmluY2x1ZGVzKHZhbHVlKTtcbiAgfTtcblxuICBUb0luZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHJldmVyc2UgJiYgZW5zdXJlU2l6ZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gZm4odiwgcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLCB0aGlzJDEpOyB9LFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gIH07XG5cbiAgVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHZhciBpID0gMDtcbiAgICByZXZlcnNlICYmIGVuc3VyZVNpemUodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHJldHVybiBzdGVwLmRvbmVcbiAgICAgICAgPyBzdGVwXG4gICAgICAgIDogaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICByZXZlcnNlID8gdGhpcyQxLnNpemUgLSArK2kgOiBpKyssXG4gICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgc3RlcFxuICAgICAgICAgICk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFRvSW5kZXhlZFNlcXVlbmNlO1xufShJbmRleGVkU2VxKSk7XG5cbnZhciBUb1NldFNlcXVlbmNlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoU2V0U2VxJCQxKSB7XG4gIGZ1bmN0aW9uIFRvU2V0U2VxdWVuY2UoaXRlcikge1xuICAgIHRoaXMuX2l0ZXIgPSBpdGVyO1xuICAgIHRoaXMuc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgfVxuXG4gIGlmICggU2V0U2VxJCQxICkgVG9TZXRTZXF1ZW5jZS5fX3Byb3RvX18gPSBTZXRTZXEkJDE7XG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2V0U2VxJCQxICYmIFNldFNlcSQkMS5wcm90b3R5cGUgKTtcbiAgVG9TZXRTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb1NldFNlcXVlbmNlO1xuXG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuaW5jbHVkZXMoa2V5KTtcbiAgfTtcblxuICBUb1NldFNlcXVlbmNlLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5faXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGZuKHYsIHYsIHRoaXMkMSk7IH0sIHJldmVyc2UpO1xuICB9O1xuXG4gIFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5faXRlci5fX2l0ZXJhdG9yKElURVJBVEVfVkFMVUVTLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgcmV0dXJuIHN0ZXAuZG9uZVxuICAgICAgICA/IHN0ZXBcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIHN0ZXAudmFsdWUsIHN0ZXAudmFsdWUsIHN0ZXApO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUb1NldFNlcXVlbmNlO1xufShTZXRTZXEpKTtcblxudmFyIEZyb21FbnRyaWVzU2VxdWVuY2UgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZFNlcSQkMSkge1xuICBmdW5jdGlvbiBGcm9tRW50cmllc1NlcXVlbmNlKGVudHJpZXMpIHtcbiAgICB0aGlzLl9pdGVyID0gZW50cmllcztcbiAgICB0aGlzLnNpemUgPSBlbnRyaWVzLnNpemU7XG4gIH1cblxuICBpZiAoIEtleWVkU2VxJCQxICkgRnJvbUVudHJpZXNTZXF1ZW5jZS5fX3Byb3RvX18gPSBLZXllZFNlcSQkMTtcbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBLZXllZFNlcSQkMSAmJiBLZXllZFNlcSQkMS5wcm90b3R5cGUgKTtcbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcm9tRW50cmllc1NlcXVlbmNlO1xuXG4gIEZyb21FbnRyaWVzU2VxdWVuY2UucHJvdG90eXBlLmVudHJ5U2VxID0gZnVuY3Rpb24gZW50cnlTZXEgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVyLnRvU2VxKCk7XG4gIH07XG5cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX2l0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgZXhpc3RzIGZpcnN0IHNvIGFycmF5IGFjY2VzcyBkb2Vzbid0IHRocm93IGZvciBob2xlc1xuICAgICAgLy8gaW4gdGhlIHBhcmVudCBpdGVyYXRpb24uXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdmFsaWRhdGVFbnRyeShlbnRyeSk7XG4gICAgICAgIHZhciBpbmRleGVkQ29sbGVjdGlvbiA9IGlzQ29sbGVjdGlvbihlbnRyeSk7XG4gICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgdGhpcyQxXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9pdGVyLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAvLyBDaGVjayBpZiBlbnRyeSBleGlzdHMgZmlyc3Qgc28gYXJyYXkgYWNjZXNzIGRvZXNuJ3QgdGhyb3cgZm9yIGhvbGVzXG4gICAgICAgIC8vIGluIHRoZSBwYXJlbnQgaXRlcmF0aW9uLlxuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB2YXIgaW5kZXhlZENvbGxlY3Rpb24gPSBpc0NvbGxlY3Rpb24oZW50cnkpO1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGluZGV4ZWRDb2xsZWN0aW9uID8gZW50cnkuZ2V0KDApIDogZW50cnlbMF0sXG4gICAgICAgICAgICBpbmRleGVkQ29sbGVjdGlvbiA/IGVudHJ5LmdldCgxKSA6IGVudHJ5WzFdLFxuICAgICAgICAgICAgc3RlcFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRnJvbUVudHJpZXNTZXF1ZW5jZTtcbn0oS2V5ZWRTZXEpKTtcblxuVG9JbmRleGVkU2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gVG9LZXllZFNlcXVlbmNlLnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IFRvU2V0U2VxdWVuY2UucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gRnJvbUVudHJpZXNTZXF1ZW5jZS5wcm90b3R5cGUuY2FjaGVSZXN1bHQgPSBjYWNoZVJlc3VsdFRocm91Z2g7XG5cbmZ1bmN0aW9uIGZsaXBGYWN0b3J5KGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZsaXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgZmxpcFNlcXVlbmNlLl9pdGVyID0gY29sbGVjdGlvbjtcbiAgZmxpcFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG4gIGZsaXBTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbjsgfTtcbiAgZmxpcFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmV2ZXJzZWRTZXF1ZW5jZSA9IGNvbGxlY3Rpb24ucmV2ZXJzZS5hcHBseSh0aGlzKTsgLy8gc3VwZXIucmV2ZXJzZSgpXG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29sbGVjdGlvbi5yZXZlcnNlKCk7IH07XG4gICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gIH07XG4gIGZsaXBTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmluY2x1ZGVzKGtleSk7IH07XG4gIGZsaXBTZXF1ZW5jZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGtleSk7IH07XG4gIGZsaXBTZXF1ZW5jZS5jYWNoZVJlc3VsdCA9IGNhY2hlUmVzdWx0VGhyb3VnaDtcbiAgZmxpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4oaywgdiwgdGhpcyQxKSAhPT0gZmFsc2U7IH0sIHJldmVyc2UpO1xuICB9O1xuICBmbGlwU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgICB2YXIgayA9IHN0ZXAudmFsdWVbMF07XG4gICAgICAgICAgc3RlcC52YWx1ZVswXSA9IHN0ZXAudmFsdWVbMV07XG4gICAgICAgICAgc3RlcC52YWx1ZVsxXSA9IGs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uX19pdGVyYXRvcihcbiAgICAgIHR5cGUgPT09IElURVJBVEVfVkFMVUVTID8gSVRFUkFURV9LRVlTIDogSVRFUkFURV9WQUxVRVMsXG4gICAgICByZXZlcnNlXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gbWFwRmFjdG9yeShjb2xsZWN0aW9uLCBtYXBwZXIsIGNvbnRleHQpIHtcbiAgdmFyIG1hcHBlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICBtYXBwZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICBtYXBwZWRTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb2xsZWN0aW9uLmhhcyhrZXkpOyB9O1xuICBtYXBwZWRTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciB2ID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICByZXR1cm4gdiA9PT0gTk9UX1NFVFxuICAgICAgPyBub3RTZXRWYWx1ZVxuICAgICAgOiBtYXBwZXIuY2FsbChjb250ZXh0LCB2LCBrZXksIGNvbGxlY3Rpb24pO1xuICB9O1xuICBtYXBwZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodiwgaywgYykgeyByZXR1cm4gZm4obWFwcGVyLmNhbGwoY29udGV4dCwgdiwgaywgYyksIGssIHRoaXMkMSkgIT09IGZhbHNlOyB9LFxuICAgICAgcmV2ZXJzZVxuICAgICk7XG4gIH07XG4gIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH1cbiAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICBtYXBwZXIuY2FsbChjb250ZXh0LCBlbnRyeVsxXSwga2V5LCBjb2xsZWN0aW9uKSxcbiAgICAgICAgc3RlcFxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlRmFjdG9yeShjb2xsZWN0aW9uLCB1c2VLZXlzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByZXZlcnNlZFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKGNvbGxlY3Rpb24pO1xuICByZXZlcnNlZFNlcXVlbmNlLl9pdGVyID0gY29sbGVjdGlvbjtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5zaXplID0gY29sbGVjdGlvbi5zaXplO1xuICByZXZlcnNlZFNlcXVlbmNlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2xsZWN0aW9uOyB9O1xuICBpZiAoY29sbGVjdGlvbi5mbGlwKSB7XG4gICAgcmV2ZXJzZWRTZXF1ZW5jZS5mbGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmxpcFNlcXVlbmNlID0gZmxpcEZhY3RvcnkoY29sbGVjdGlvbik7XG4gICAgICBmbGlwU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZmxpcCgpOyB9O1xuICAgICAgcmV0dXJuIGZsaXBTZXF1ZW5jZTtcbiAgICB9O1xuICB9XG4gIHJldmVyc2VkU2VxdWVuY2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbm90U2V0VmFsdWUpIHsgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0KHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSwgbm90U2V0VmFsdWUpOyB9O1xuICByZXZlcnNlZFNlcXVlbmNlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKHVzZUtleXMgPyBrZXkgOiAtMSAtIGtleSk7IH07XG4gIHJldmVyc2VkU2VxdWVuY2UuaW5jbHVkZXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGNvbGxlY3Rpb24uaW5jbHVkZXModmFsdWUpOyB9O1xuICByZXZlcnNlZFNlcXVlbmNlLmNhY2hlUmVzdWx0ID0gY2FjaGVSZXN1bHRUaHJvdWdoO1xuICByZXZlcnNlZFNlcXVlbmNlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLl9faXRlcmF0ZShcbiAgICAgIGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmbih2LCB1c2VLZXlzID8gayA6IHJldmVyc2UgPyB0aGlzJDEuc2l6ZSAtICsraSA6IGkrKywgdGhpcyQxKTsgfSxcbiAgICAgICFyZXZlcnNlXG4gICAgKTtcbiAgfTtcbiAgcmV2ZXJzZWRTZXF1ZW5jZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgcmV2ZXJzZSAmJiBlbnN1cmVTaXplKGNvbGxlY3Rpb24pO1xuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX0VOVFJJRVMsICFyZXZlcnNlKTtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgIH1cbiAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZShcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdXNlS2V5cyA/IGVudHJ5WzBdIDogcmV2ZXJzZSA/IHRoaXMkMS5zaXplIC0gKytpIDogaSsrLFxuICAgICAgICBlbnRyeVsxXSxcbiAgICAgICAgc3RlcFxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0LCB1c2VLZXlzKSB7XG4gIHZhciBmaWx0ZXJTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgaWYgKHVzZUtleXMpIHtcbiAgICBmaWx0ZXJTZXF1ZW5jZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdiA9IGNvbGxlY3Rpb24uZ2V0KGtleSwgTk9UX1NFVCk7XG4gICAgICByZXR1cm4gdiAhPT0gTk9UX1NFVCAmJiAhIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGtleSwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBmaWx0ZXJTZXF1ZW5jZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgICAgdmFyIHYgPSBjb2xsZWN0aW9uLmdldChrZXksIE5PVF9TRVQpO1xuICAgICAgcmV0dXJuIHYgIT09IE5PVF9TRVQgJiYgcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwga2V5LCBjb2xsZWN0aW9uKVxuICAgICAgICA/IHZcbiAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuICB9XG4gIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIGMpKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSk7XG4gICAgICB9XG4gICAgfSwgcmV2ZXJzZSk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG4gIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gZW50cnlbMV07XG4gICAgICAgIGlmIChwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIHVzZUtleXMgPyBrZXkgOiBpdGVyYXRpb25zKyssIHZhbHVlLCBzdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gZmlsdGVyU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGNvdW50QnlGYWN0b3J5KGNvbGxlY3Rpb24sIGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgdmFyIGdyb3VwcyA9IE1hcCgpLmFzTXV0YWJsZSgpO1xuICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgIGdyb3Vwcy51cGRhdGUoZ3JvdXBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pLCAwLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gYSArIDE7IH0pO1xuICB9KTtcbiAgcmV0dXJuIGdyb3Vwcy5hc0ltbXV0YWJsZSgpO1xufVxuXG5mdW5jdGlvbiBncm91cEJ5RmFjdG9yeShjb2xsZWN0aW9uLCBncm91cGVyLCBjb250ZXh0KSB7XG4gIHZhciBpc0tleWVkSXRlciA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBncm91cHMgPSAoaXNPcmRlcmVkKGNvbGxlY3Rpb24pID8gT3JkZXJlZE1hcCgpIDogTWFwKCkpLmFzTXV0YWJsZSgpO1xuICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgIGdyb3Vwcy51cGRhdGUoXG4gICAgICBncm91cGVyLmNhbGwoY29udGV4dCwgdiwgaywgY29sbGVjdGlvbiksXG4gICAgICBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChhID0gYSB8fCBbXSksIGEucHVzaChpc0tleWVkSXRlciA/IFtrLCB2XSA6IHYpLCBhKTsgfVxuICAgICk7XG4gIH0pO1xuICB2YXIgY29lcmNlID0gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gZ3JvdXBzLm1hcChmdW5jdGlvbiAoYXJyKSB7IHJldHVybiByZWlmeShjb2xsZWN0aW9uLCBjb2VyY2UoYXJyKSk7IH0pLmFzSW1tdXRhYmxlKCk7XG59XG5cbmZ1bmN0aW9uIHNsaWNlRmFjdG9yeShjb2xsZWN0aW9uLCBiZWdpbiwgZW5kLCB1c2VLZXlzKSB7XG4gIHZhciBvcmlnaW5hbFNpemUgPSBjb2xsZWN0aW9uLnNpemU7XG5cbiAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgb3JpZ2luYWxTaXplKSkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG5cbiAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIG9yaWdpbmFsU2l6ZSk7XG4gIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCBvcmlnaW5hbFNpemUpO1xuXG4gIC8vIGJlZ2luIG9yIGVuZCB3aWxsIGJlIE5hTiBpZiB0aGV5IHdlcmUgcHJvdmlkZWQgYXMgbmVnYXRpdmUgbnVtYmVycyBhbmRcbiAgLy8gdGhpcyBjb2xsZWN0aW9uJ3Mgc2l6ZSBpcyB1bmtub3duLiBJbiB0aGF0IGNhc2UsIGNhY2hlIGZpcnN0IHNvIHRoZXJlIGlzXG4gIC8vIGEga25vd24gc2l6ZSBhbmQgdGhlc2UgZG8gbm90IHJlc29sdmUgdG8gTmFOLlxuICBpZiAocmVzb2x2ZWRCZWdpbiAhPT0gcmVzb2x2ZWRCZWdpbiB8fCByZXNvbHZlZEVuZCAhPT0gcmVzb2x2ZWRFbmQpIHtcbiAgICByZXR1cm4gc2xpY2VGYWN0b3J5KGNvbGxlY3Rpb24udG9TZXEoKS5jYWNoZVJlc3VsdCgpLCBiZWdpbiwgZW5kLCB1c2VLZXlzKTtcbiAgfVxuXG4gIC8vIE5vdGU6IHJlc29sdmVkRW5kIGlzIHVuZGVmaW5lZCB3aGVuIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSdzIGxlbmd0aCBpc1xuICAvLyB1bmtub3duIGFuZCB0aGlzIHNsaWNlIGRpZCBub3Qgc3VwcGx5IGFuIGVuZCBhbmQgc2hvdWxkIGNvbnRhaW4gYWxsXG4gIC8vIGVsZW1lbnRzIGFmdGVyIHJlc29sdmVkQmVnaW4uXG4gIC8vIEluIHRoYXQgY2FzZSwgcmVzb2x2ZWRTaXplIHdpbGwgYmUgTmFOIGFuZCBzbGljZVNpemUgd2lsbCByZW1haW4gdW5kZWZpbmVkLlxuICB2YXIgcmVzb2x2ZWRTaXplID0gcmVzb2x2ZWRFbmQgLSByZXNvbHZlZEJlZ2luO1xuICB2YXIgc2xpY2VTaXplO1xuICBpZiAocmVzb2x2ZWRTaXplID09PSByZXNvbHZlZFNpemUpIHtcbiAgICBzbGljZVNpemUgPSByZXNvbHZlZFNpemUgPCAwID8gMCA6IHJlc29sdmVkU2l6ZTtcbiAgfVxuXG4gIHZhciBzbGljZVNlcSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcblxuICAvLyBJZiBjb2xsZWN0aW9uLnNpemUgaXMgdW5kZWZpbmVkLCB0aGUgc2l6ZSBvZiB0aGUgcmVhbGl6ZWQgc2xpY2VTZXEgaXNcbiAgLy8gdW5rbm93biBhdCB0aGlzIHBvaW50IHVubGVzcyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHNsaWNlIGlzIDBcbiAgc2xpY2VTZXEuc2l6ZSA9XG4gICAgc2xpY2VTaXplID09PSAwID8gc2xpY2VTaXplIDogKGNvbGxlY3Rpb24uc2l6ZSAmJiBzbGljZVNpemUpIHx8IHVuZGVmaW5lZDtcblxuICBpZiAoIXVzZUtleXMgJiYgaXNTZXEoY29sbGVjdGlvbikgJiYgc2xpY2VTaXplID49IDApIHtcbiAgICBzbGljZVNlcS5nZXQgPSBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgc2xpY2VTaXplXG4gICAgICAgID8gY29sbGVjdGlvbi5nZXQoaW5kZXggKyByZXNvbHZlZEJlZ2luLCBub3RTZXRWYWx1ZSlcbiAgICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgc2xpY2VTZXEuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHNsaWNlU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBza2lwcGVkID0gMDtcbiAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIGNvbGxlY3Rpb24uX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikpKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBmbih2LCB1c2VLZXlzID8gayA6IGl0ZXJhdGlvbnMgLSAxLCB0aGlzJDEpICE9PSBmYWxzZSAmJlxuICAgICAgICAgIGl0ZXJhdGlvbnMgIT09IHNsaWNlU2l6ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIHNsaWNlU2VxLl9faXRlcmF0b3JVbmNhY2hlZCA9IGZ1bmN0aW9uKHR5cGUsIHJldmVyc2UpIHtcbiAgICBpZiAoc2xpY2VTaXplICE9PSAwICYmIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgYm90aGVyIGluc3RhbnRpYXRpbmcgcGFyZW50IGl0ZXJhdG9yIGlmIHRha2luZyAwLlxuICAgIGlmIChzbGljZVNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgSXRlcmF0b3IoaXRlcmF0b3JEb25lKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIHZhciBza2lwcGVkID0gMDtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoc2tpcHBlZCsrIDwgcmVzb2x2ZWRCZWdpbikge1xuICAgICAgICBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAoKytpdGVyYXRpb25zID4gc2xpY2VTaXplKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKHVzZUtleXMgfHwgdHlwZSA9PT0gSVRFUkFURV9WQUxVRVMgfHwgc3RlcC5kb25lKSB7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zIC0gMSwgdW5kZWZpbmVkLCBzdGVwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMgLSAxLCBzdGVwLnZhbHVlWzFdLCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gc2xpY2VTZXE7XG59XG5cbmZ1bmN0aW9uIHRha2VXaGlsZUZhY3RvcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gIHZhciB0YWtlU2VxdWVuY2UgPSBtYWtlU2VxdWVuY2UoY29sbGVjdGlvbik7XG4gIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodiwgaywgYykgeyByZXR1cm4gcHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykgJiYgKytpdGVyYXRpb25zICYmIGZuKHYsIGssIHRoaXMkMSk7IH1cbiAgICApO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICB0YWtlU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdG9yID0gY29sbGVjdGlvbi5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIGl0ZXJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWl0ZXJhdGluZykge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgICB9XG4gICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgdmFyIGsgPSBlbnRyeVswXTtcbiAgICAgIHZhciB2ID0gZW50cnlbMV07XG4gICAgICBpZiAoIXByZWRpY2F0ZS5jYWxsKGNvbnRleHQsIHYsIGssIHRoaXMkMSkpIHtcbiAgICAgICAgaXRlcmF0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gc2tpcFdoaWxlRmFjdG9yeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGNvbnRleHQsIHVzZUtleXMpIHtcbiAgdmFyIHNraXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgc2tpcFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGssIGMpIHtcbiAgICAgIGlmICghKGlzU2tpcHBpbmcgJiYgKGlzU2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkpKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgcmV0dXJuIGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIHRoaXMkMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG4gIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSBjb2xsZWN0aW9uLl9faXRlcmF0b3IoSVRFUkFURV9FTlRSSUVTLCByZXZlcnNlKTtcbiAgICB2YXIgc2tpcHBpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGs7XG4gICAgICB2YXIgdjtcbiAgICAgIGRvIHtcbiAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIGlmICh1c2VLZXlzIHx8IHR5cGUgPT09IElURVJBVEVfVkFMVUVTKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09IElURVJBVEVfS0VZUykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgaXRlcmF0aW9ucysrLCB1bmRlZmluZWQsIHN0ZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHN0ZXAudmFsdWVbMV0sIHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgIGsgPSBlbnRyeVswXTtcbiAgICAgICAgdiA9IGVudHJ5WzFdO1xuICAgICAgICBza2lwcGluZyAmJiAoc2tpcHBpbmcgPSBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCB0aGlzJDEpKTtcbiAgICAgIH0gd2hpbGUgKHNraXBwaW5nKTtcbiAgICAgIHJldHVybiB0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBrLCB2LCBzdGVwKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHNraXBTZXF1ZW5jZTtcbn1cblxuZnVuY3Rpb24gY29uY2F0RmFjdG9yeShjb2xsZWN0aW9uLCB2YWx1ZXMpIHtcbiAgdmFyIGlzS2V5ZWRDb2xsZWN0aW9uID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgdmFyIGl0ZXJzID0gW2NvbGxlY3Rpb25dXG4gICAgLmNvbmNhdCh2YWx1ZXMpXG4gICAgLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgaWYgKCFpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgdiA9IGlzS2V5ZWRDb2xsZWN0aW9uXG4gICAgICAgICAgPyBrZXllZFNlcUZyb21WYWx1ZSh2KVxuICAgICAgICAgIDogaW5kZXhlZFNlcUZyb21WYWx1ZShBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2XSk7XG4gICAgICB9IGVsc2UgaWYgKGlzS2V5ZWRDb2xsZWN0aW9uKSB7XG4gICAgICAgIHYgPSBLZXllZENvbGxlY3Rpb24odik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuc2l6ZSAhPT0gMDsgfSk7XG5cbiAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG5cbiAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzaW5nbGV0b24gPSBpdGVyc1swXTtcbiAgICBpZiAoXG4gICAgICBzaW5nbGV0b24gPT09IGNvbGxlY3Rpb24gfHxcbiAgICAgIChpc0tleWVkQ29sbGVjdGlvbiAmJiBpc0tleWVkKHNpbmdsZXRvbikpIHx8XG4gICAgICAoaXNJbmRleGVkKGNvbGxlY3Rpb24pICYmIGlzSW5kZXhlZChzaW5nbGV0b24pKVxuICAgICkge1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbjtcbiAgICB9XG4gIH1cblxuICB2YXIgY29uY2F0U2VxID0gbmV3IEFycmF5U2VxKGl0ZXJzKTtcbiAgaWYgKGlzS2V5ZWRDb2xsZWN0aW9uKSB7XG4gICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvS2V5ZWRTZXEoKTtcbiAgfSBlbHNlIGlmICghaXNJbmRleGVkKGNvbGxlY3Rpb24pKSB7XG4gICAgY29uY2F0U2VxID0gY29uY2F0U2VxLnRvU2V0U2VxKCk7XG4gIH1cbiAgY29uY2F0U2VxID0gY29uY2F0U2VxLmZsYXR0ZW4odHJ1ZSk7XG4gIGNvbmNhdFNlcS5zaXplID0gaXRlcnMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHNlcSkge1xuICAgIGlmIChzdW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHNpemUgPSBzZXEuc2l6ZTtcbiAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN1bSArIHNpemU7XG4gICAgICB9XG4gICAgfVxuICB9LCAwKTtcbiAgcmV0dXJuIGNvbmNhdFNlcTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkZhY3RvcnkoY29sbGVjdGlvbiwgZGVwdGgsIHVzZUtleXMpIHtcbiAgdmFyIGZsYXRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgZmxhdFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBmbGF0RGVlcChpdGVyLCBjdXJyZW50RGVwdGgpIHtcbiAgICAgIGl0ZXIuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIGlmICgoIWRlcHRoIHx8IGN1cnJlbnREZXB0aCA8IGRlcHRoKSAmJiBpc0NvbGxlY3Rpb24odikpIHtcbiAgICAgICAgICBmbGF0RGVlcCh2LCBjdXJyZW50RGVwdGggKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgaWYgKGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucyAtIDEsIGZsYXRTZXF1ZW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFzdG9wcGVkO1xuICAgICAgfSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIGZsYXREZWVwKGNvbGxlY3Rpb24sIDApO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICBmbGF0U2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICB3aGlsZSAoaXRlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXRlcmF0b3IgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdiA9IHN0ZXAudmFsdWU7XG4gICAgICAgIGlmICh0eXBlID09PSBJVEVSQVRFX0VOVFJJRVMpIHtcbiAgICAgICAgICB2ID0gdlsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFkZXB0aCB8fCBzdGFjay5sZW5ndGggPCBkZXB0aCkgJiYgaXNDb2xsZWN0aW9uKHYpKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChpdGVyYXRvcik7XG4gICAgICAgICAgaXRlcmF0b3IgPSB2Ll9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHVzZUtleXMgPyBzdGVwIDogaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHYsIHN0ZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBmbGF0U2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBGYWN0b3J5KGNvbGxlY3Rpb24sIG1hcHBlciwgY29udGV4dCkge1xuICB2YXIgY29lcmNlID0gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pO1xuICByZXR1cm4gY29sbGVjdGlvblxuICAgIC50b1NlcSgpXG4gICAgLm1hcChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gY29lcmNlKG1hcHBlci5jYWxsKGNvbnRleHQsIHYsIGssIGNvbGxlY3Rpb24pKTsgfSlcbiAgICAuZmxhdHRlbih0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb3NlRmFjdG9yeShjb2xsZWN0aW9uLCBzZXBhcmF0b3IpIHtcbiAgdmFyIGludGVycG9zZWRTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKTtcbiAgaW50ZXJwb3NlZFNlcXVlbmNlLnNpemUgPSBjb2xsZWN0aW9uLnNpemUgJiYgY29sbGVjdGlvbi5zaXplICogMiAtIDE7XG4gIGludGVycG9zZWRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgY29sbGVjdGlvbi5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAodikgeyByZXR1cm4gKCFpdGVyYXRpb25zIHx8IGZuKHNlcGFyYXRvciwgaXRlcmF0aW9ucysrLCB0aGlzJDEpICE9PSBmYWxzZSkgJiZcbiAgICAgICAgZm4odiwgaXRlcmF0aW9ucysrLCB0aGlzJDEpICE9PSBmYWxzZTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICBpbnRlcnBvc2VkU2VxdWVuY2UuX19pdGVyYXRvclVuY2FjaGVkID0gZnVuY3Rpb24odHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBpdGVyYXRvciA9IGNvbGxlY3Rpb24uX19pdGVyYXRvcihJVEVSQVRFX1ZBTFVFUywgcmV2ZXJzZSk7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBzdGVwO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdGVwIHx8IGl0ZXJhdGlvbnMgJSAyKSB7XG4gICAgICAgIHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnMgJSAyXG4gICAgICAgID8gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHNlcGFyYXRvcilcbiAgICAgICAgOiBpdGVyYXRvclZhbHVlKHR5cGUsIGl0ZXJhdGlvbnMrKywgc3RlcC52YWx1ZSwgc3RlcCk7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBpbnRlcnBvc2VkU2VxdWVuY2U7XG59XG5cbmZ1bmN0aW9uIHNvcnRGYWN0b3J5KGNvbGxlY3Rpb24sIGNvbXBhcmF0b3IsIG1hcHBlcikge1xuICBpZiAoIWNvbXBhcmF0b3IpIHtcbiAgICBjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3I7XG4gIH1cbiAgdmFyIGlzS2V5ZWRDb2xsZWN0aW9uID0gaXNLZXllZChjb2xsZWN0aW9uKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGVudHJpZXMgPSBjb2xsZWN0aW9uXG4gICAgLnRvU2VxKClcbiAgICAubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBbaywgdiwgaW5kZXgrKywgbWFwcGVyID8gbWFwcGVyKHYsIGssIGNvbGxlY3Rpb24pIDogdl07IH0pXG4gICAgLnZhbHVlU2VxKClcbiAgICAudG9BcnJheSgpO1xuICBlbnRyaWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGNvbXBhcmF0b3IoYVszXSwgYlszXSkgfHwgYVsyXSAtIGJbMl07IH0pLmZvckVhY2goXG4gICAgaXNLZXllZENvbGxlY3Rpb25cbiAgICAgID8gZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICBlbnRyaWVzW2ldLmxlbmd0aCA9IDI7XG4gICAgICAgIH1cbiAgICAgIDogZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICBlbnRyaWVzW2ldID0gdlsxXTtcbiAgICAgICAgfVxuICApO1xuICByZXR1cm4gaXNLZXllZENvbGxlY3Rpb25cbiAgICA/IEtleWVkU2VxKGVudHJpZXMpXG4gICAgOiBpc0luZGV4ZWQoY29sbGVjdGlvbilcbiAgICAgID8gSW5kZXhlZFNlcShlbnRyaWVzKVxuICAgICAgOiBTZXRTZXEoZW50cmllcyk7XG59XG5cbmZ1bmN0aW9uIG1heEZhY3RvcnkoY29sbGVjdGlvbiwgY29tcGFyYXRvciwgbWFwcGVyKSB7XG4gIGlmICghY29tcGFyYXRvcikge1xuICAgIGNvbXBhcmF0b3IgPSBkZWZhdWx0Q29tcGFyYXRvcjtcbiAgfVxuICBpZiAobWFwcGVyKSB7XG4gICAgdmFyIGVudHJ5ID0gY29sbGVjdGlvblxuICAgICAgLnRvU2VxKClcbiAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIFt2LCBtYXBwZXIodiwgaywgY29sbGVjdGlvbildOyB9KVxuICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKG1heENvbXBhcmUoY29tcGFyYXRvciwgYVsxXSwgYlsxXSkgPyBiIDogYSk7IH0pO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbi5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChtYXhDb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpID8gYiA6IGEpOyB9KTtcbn1cblxuZnVuY3Rpb24gbWF4Q29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XG4gIHZhciBjb21wID0gY29tcGFyYXRvcihiLCBhKTtcbiAgLy8gYiBpcyBjb25zaWRlcmVkIHRoZSBuZXcgbWF4IGlmIHRoZSBjb21wYXJhdG9yIGRlY2xhcmVzIHRoZW0gZXF1YWwsIGJ1dFxuICAvLyB0aGV5IGFyZSBub3QgZXF1YWwgYW5kIGIgaXMgaW4gZmFjdCBhIG51bGxpc2ggdmFsdWUuXG4gIHJldHVybiAoXG4gICAgKGNvbXAgPT09IDAgJiYgYiAhPT0gYSAmJiAoYiA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiAhPT0gYikpIHx8XG4gICAgY29tcCA+IDBcbiAgKTtcbn1cblxuZnVuY3Rpb24gemlwV2l0aEZhY3Rvcnkoa2V5SXRlciwgemlwcGVyLCBpdGVycywgemlwQWxsKSB7XG4gIHZhciB6aXBTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZShrZXlJdGVyKTtcbiAgdmFyIHNpemVzID0gbmV3IEFycmF5U2VxKGl0ZXJzKS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGkuc2l6ZTsgfSk7XG4gIHppcFNlcXVlbmNlLnNpemUgPSB6aXBBbGwgPyBzaXplcy5tYXgoKSA6IHNpemVzLm1pbigpO1xuICAvLyBOb3RlOiB0aGlzIGEgZ2VuZXJpYyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIF9faXRlcmF0ZSBpbiB0ZXJtcyBvZlxuICAvLyBfX2l0ZXJhdG9yIHdoaWNoIG1heSBiZSBtb3JlIGdlbmVyaWNhbGx5IHVzZWZ1bCBpbiB0aGUgZnV0dXJlLlxuICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIC8qIGdlbmVyaWM6XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUywgcmV2ZXJzZSk7XG4gICAgdmFyIHN0ZXA7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgIGlmIChmbihzdGVwLnZhbHVlWzFdLCBzdGVwLnZhbHVlWzBdLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgICovXG4gICAgLy8gaW5kZXhlZDpcbiAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMsIHJldmVyc2UpO1xuICAgIHZhciBzdGVwO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICBpZiAoZm4oc3RlcC52YWx1ZSwgaXRlcmF0aW9ucysrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRpb25zO1xuICB9O1xuICB6aXBTZXF1ZW5jZS5fX2l0ZXJhdG9yVW5jYWNoZWQgPSBmdW5jdGlvbih0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGl0ZXJhdG9ycyA9IGl0ZXJzLm1hcChcbiAgICAgIGZ1bmN0aW9uIChpKSB7IHJldHVybiAoKGkgPSBDb2xsZWN0aW9uKGkpKSwgZ2V0SXRlcmF0b3IocmV2ZXJzZSA/IGkucmV2ZXJzZSgpIDogaSkpOyB9XG4gICAgKTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdmFyIGlzRG9uZSA9IGZhbHNlO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0ZXBzO1xuICAgICAgaWYgKCFpc0RvbmUpIHtcbiAgICAgICAgc3RlcHMgPSBpdGVyYXRvcnMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLm5leHQoKTsgfSk7XG4gICAgICAgIGlzRG9uZSA9IHppcEFsbCA/IHN0ZXBzLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLmRvbmU7IH0pIDogc3RlcHMuc29tZShmdW5jdGlvbiAocykgeyByZXR1cm4gcy5kb25lOyB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yRG9uZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGl0ZXJhdGlvbnMrKyxcbiAgICAgICAgemlwcGVyLmFwcGx5KG51bGwsIHN0ZXBzLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy52YWx1ZTsgfSkpXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gemlwU2VxdWVuY2U7XG59XG5cbi8vICNwcmFnbWEgSGVscGVyIEZ1bmN0aW9uc1xuXG5mdW5jdGlvbiByZWlmeShpdGVyLCBzZXEpIHtcbiAgcmV0dXJuIGl0ZXIgPT09IHNlcSA/IGl0ZXIgOiBpc1NlcShpdGVyKSA/IHNlcSA6IGl0ZXIuY29uc3RydWN0b3Ioc2VxKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFbnRyeShlbnRyeSkge1xuICBpZiAoZW50cnkgIT09IE9iamVjdChlbnRyeSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBbSywgVl0gdHVwbGU6ICcgKyBlbnRyeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29sbGVjdGlvbkNsYXNzKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIGlzS2V5ZWQoY29sbGVjdGlvbilcbiAgICA/IEtleWVkQ29sbGVjdGlvblxuICAgIDogaXNJbmRleGVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEluZGV4ZWRDb2xsZWN0aW9uXG4gICAgICA6IFNldENvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXF1ZW5jZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKFxuICAgIChpc0tleWVkKGNvbGxlY3Rpb24pXG4gICAgICA/IEtleWVkU2VxXG4gICAgICA6IGlzSW5kZXhlZChjb2xsZWN0aW9uKVxuICAgICAgICA/IEluZGV4ZWRTZXFcbiAgICAgICAgOiBTZXRTZXFcbiAgICApLnByb3RvdHlwZVxuICApO1xufVxuXG5mdW5jdGlvbiBjYWNoZVJlc3VsdFRocm91Z2goKSB7XG4gIGlmICh0aGlzLl9pdGVyLmNhY2hlUmVzdWx0KSB7XG4gICAgdGhpcy5faXRlci5jYWNoZVJlc3VsdCgpO1xuICAgIHRoaXMuc2l6ZSA9IHRoaXMuX2l0ZXIuc2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gU2VxLnByb3RvdHlwZS5jYWNoZVJlc3VsdC5jYWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihhLCBiKSB7XG4gIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufVxuXG4vLyBodHRwOi8vanNwZXJmLmNvbS9jb3B5LWFycmF5LWlubGluZVxuZnVuY3Rpb24gYXJyQ29weShhcnIsIG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIGFyci5sZW5ndGggLSBvZmZzZXQpO1xuICB2YXIgbmV3QXJyID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICBuZXdBcnJbaWldID0gYXJyW2lpICsgb2Zmc2V0XTtcbiAgfVxuICByZXR1cm4gbmV3QXJyO1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBlcnJvcikge1xuICBpZiAoIWNvbmRpdGlvbikgeyB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpOyB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE5vdEluZmluaXRlKHNpemUpIHtcbiAgaW52YXJpYW50KFxuICAgIHNpemUgIT09IEluZmluaXR5LFxuICAgICdDYW5ub3QgcGVyZm9ybSB0aGlzIGFjdGlvbiB3aXRoIGFuIGluZmluaXRlIHNpemUuJ1xuICApO1xufVxuXG5mdW5jdGlvbiBjb2VyY2VLZXlQYXRoKGtleVBhdGgpIHtcbiAgaWYgKGlzQXJyYXlMaWtlKGtleVBhdGgpICYmIHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBrZXlQYXRoO1xuICB9XG4gIGlmIChpc09yZGVyZWQoa2V5UGF0aCkpIHtcbiAgICByZXR1cm4ga2V5UGF0aC50b0FycmF5KCk7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnSW52YWxpZCBrZXlQYXRoOiBleHBlY3RlZCBPcmRlcmVkIENvbGxlY3Rpb24gb3IgQXJyYXk6ICcgKyBrZXlQYXRoXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmoodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAmJlxuICAgICh0eXBlb2YgdmFsdWUuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBwb3RlbnRpYWxseS1wZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlLCBlaXRoZXJcbiAqIHByb3ZpZGVkIGJ5IEltbXV0YWJsZS5qcyBvciBhIHBsYWluIEFycmF5IG9yIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNEYXRhU3RydWN0dXJlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgIChpc0ltbXV0YWJsZSh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iaih2YWx1ZSkpXG4gICk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSB2YWx1ZSB0byBhIHN0cmluZywgYWRkaW5nIHF1b3RlcyBpZiBhIHN0cmluZyB3YXMgcHJvdmlkZWQuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlU3RyaW5nKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBTdHJpbmcodmFsdWUpO1xuICB9IGNhdGNoIChfaWdub3JlRXJyb3IpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhcyhjb2xsZWN0aW9uLCBrZXkpIHtcbiAgcmV0dXJuIGlzSW1tdXRhYmxlKGNvbGxlY3Rpb24pXG4gICAgPyBjb2xsZWN0aW9uLmhhcyhrZXkpXG4gICAgOiBpc0RhdGFTdHJ1Y3R1cmUoY29sbGVjdGlvbikgJiYgaGFzT3duUHJvcGVydHkuY2FsbChjb2xsZWN0aW9uLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBnZXQoY29sbGVjdGlvbiwga2V5LCBub3RTZXRWYWx1ZSkge1xuICByZXR1cm4gaXNJbW11dGFibGUoY29sbGVjdGlvbilcbiAgICA/IGNvbGxlY3Rpb24uZ2V0KGtleSwgbm90U2V0VmFsdWUpXG4gICAgOiAhaGFzKGNvbGxlY3Rpb24sIGtleSlcbiAgICAgID8gbm90U2V0VmFsdWVcbiAgICAgIDogdHlwZW9mIGNvbGxlY3Rpb24uZ2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY29sbGVjdGlvbi5nZXQoa2V5KVxuICAgICAgICA6IGNvbGxlY3Rpb25ba2V5XTtcbn1cblxuZnVuY3Rpb24gc2hhbGxvd0NvcHkoZnJvbSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShmcm9tKSkge1xuICAgIHJldHVybiBhcnJDb3B5KGZyb20pO1xuICB9XG4gIHZhciB0byA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24sIGtleSkge1xuICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnQ2Fubm90IHVwZGF0ZSBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgKTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24ucmVtb3ZlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IHVwZGF0ZSBpbW11dGFibGUgdmFsdWUgd2l0aG91dCAucmVtb3ZlKCkgbWV0aG9kOiAnICsgY29sbGVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKGtleSk7XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSkpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfVxuICB2YXIgY29sbGVjdGlvbkNvcHkgPSBzaGFsbG93Q29weShjb2xsZWN0aW9uKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbkNvcHkpKSB7XG4gICAgY29sbGVjdGlvbkNvcHkuc3BsaWNlKGtleSwgMSk7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIGNvbGxlY3Rpb25Db3B5W2tleV07XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb25Db3B5O1xufVxuXG5mdW5jdGlvbiBzZXQoY29sbGVjdGlvbiwga2V5LCB2YWx1ZSkge1xuICBpZiAoIWlzRGF0YVN0cnVjdHVyZShjb2xsZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnQ2Fubm90IHVwZGF0ZSBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgKTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICBpZiAoIWNvbGxlY3Rpb24uc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnQ2Fubm90IHVwZGF0ZSBpbW11dGFibGUgdmFsdWUgd2l0aG91dCAuc2V0KCkgbWV0aG9kOiAnICsgY29sbGVjdGlvblxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbGxlY3Rpb24sIGtleSkgJiYgdmFsdWUgPT09IGNvbGxlY3Rpb25ba2V5XSkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG4gIHZhciBjb2xsZWN0aW9uQ29weSA9IHNoYWxsb3dDb3B5KGNvbGxlY3Rpb24pO1xuICBjb2xsZWN0aW9uQ29weVtrZXldID0gdmFsdWU7XG4gIHJldHVybiBjb2xsZWN0aW9uQ29weTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgaWYgKCF1cGRhdGVyKSB7XG4gICAgdXBkYXRlciA9IG5vdFNldFZhbHVlO1xuICAgIG5vdFNldFZhbHVlID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciB1cGRhdGVkVmFsdWUgPSB1cGRhdGVJbkRlZXBseShcbiAgICBpc0ltbXV0YWJsZShjb2xsZWN0aW9uKSxcbiAgICBjb2xsZWN0aW9uLFxuICAgIGNvZXJjZUtleVBhdGgoa2V5UGF0aCksXG4gICAgMCxcbiAgICBub3RTZXRWYWx1ZSxcbiAgICB1cGRhdGVyXG4gICk7XG4gIHJldHVybiB1cGRhdGVkVmFsdWUgPT09IE5PVF9TRVQgPyBub3RTZXRWYWx1ZSA6IHVwZGF0ZWRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW5EZWVwbHkoXG4gIGluSW1tdXRhYmxlLFxuICBleGlzdGluZyxcbiAga2V5UGF0aCxcbiAgaSxcbiAgbm90U2V0VmFsdWUsXG4gIHVwZGF0ZXJcbikge1xuICB2YXIgd2FzTm90U2V0ID0gZXhpc3RpbmcgPT09IE5PVF9TRVQ7XG4gIGlmIChpID09PSBrZXlQYXRoLmxlbmd0aCkge1xuICAgIHZhciBleGlzdGluZ1ZhbHVlID0gd2FzTm90U2V0ID8gbm90U2V0VmFsdWUgOiBleGlzdGluZztcbiAgICB2YXIgbmV3VmFsdWUgPSB1cGRhdGVyKGV4aXN0aW5nVmFsdWUpO1xuICAgIHJldHVybiBuZXdWYWx1ZSA9PT0gZXhpc3RpbmdWYWx1ZSA/IGV4aXN0aW5nIDogbmV3VmFsdWU7XG4gIH1cbiAgaWYgKCF3YXNOb3RTZXQgJiYgIWlzRGF0YVN0cnVjdHVyZShleGlzdGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ0Nhbm5vdCB1cGRhdGUgd2l0aGluIG5vbi1kYXRhLXN0cnVjdHVyZSB2YWx1ZSBpbiBwYXRoIFsnICtcbiAgICAgICAga2V5UGF0aC5zbGljZSgwLCBpKS5tYXAocXVvdGVTdHJpbmcpICtcbiAgICAgICAgJ106ICcgK1xuICAgICAgICBleGlzdGluZ1xuICAgICk7XG4gIH1cbiAgdmFyIGtleSA9IGtleVBhdGhbaV07XG4gIHZhciBuZXh0RXhpc3RpbmcgPSB3YXNOb3RTZXQgPyBOT1RfU0VUIDogZ2V0KGV4aXN0aW5nLCBrZXksIE5PVF9TRVQpO1xuICB2YXIgbmV4dFVwZGF0ZWQgPSB1cGRhdGVJbkRlZXBseShcbiAgICBuZXh0RXhpc3RpbmcgPT09IE5PVF9TRVQgPyBpbkltbXV0YWJsZSA6IGlzSW1tdXRhYmxlKG5leHRFeGlzdGluZyksXG4gICAgbmV4dEV4aXN0aW5nLFxuICAgIGtleVBhdGgsXG4gICAgaSArIDEsXG4gICAgbm90U2V0VmFsdWUsXG4gICAgdXBkYXRlclxuICApO1xuICByZXR1cm4gbmV4dFVwZGF0ZWQgPT09IG5leHRFeGlzdGluZ1xuICAgID8gZXhpc3RpbmdcbiAgICA6IG5leHRVcGRhdGVkID09PSBOT1RfU0VUXG4gICAgICA/IHJlbW92ZShleGlzdGluZywga2V5KVxuICAgICAgOiBzZXQoXG4gICAgICAgICAgd2FzTm90U2V0ID8gKGluSW1tdXRhYmxlID8gZW1wdHlNYXAoKSA6IHt9KSA6IGV4aXN0aW5nLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBuZXh0VXBkYXRlZFxuICAgICAgICApO1xufVxuXG5mdW5jdGlvbiBzZXRJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCB2YWx1ZSkge1xuICByZXR1cm4gdXBkYXRlSW4oY29sbGVjdGlvbiwga2V5UGF0aCwgTk9UX1NFVCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufVxuXG5mdW5jdGlvbiBzZXRJbiQxKGtleVBhdGgsIHYpIHtcbiAgcmV0dXJuIHNldEluKHRoaXMsIGtleVBhdGgsIHYpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVJbihjb2xsZWN0aW9uLCBrZXlQYXRoKSB7XG4gIHJldHVybiB1cGRhdGVJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCBmdW5jdGlvbiAoKSB7IHJldHVybiBOT1RfU0VUOyB9KTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSW4oa2V5UGF0aCkge1xuICByZXR1cm4gcmVtb3ZlSW4odGhpcywga2V5UGF0aCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZShjb2xsZWN0aW9uLCBrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIHJldHVybiB1cGRhdGVJbihjb2xsZWN0aW9uLCBba2V5XSwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUkMShrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBrZXkodGhpcylcbiAgICA6IHVwZGF0ZSh0aGlzLCBrZXksIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW4kMShrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICByZXR1cm4gdXBkYXRlSW4odGhpcywga2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHJldHVybiBtZXJnZUludG9LZXllZFdpdGgodGhpcywgaXRlcnMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVdpdGgobWVyZ2VyKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICBpZiAodHlwZW9mIG1lcmdlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWVyZ2VyIGZ1bmN0aW9uOiAnICsgbWVyZ2VyKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VJbnRvS2V5ZWRXaXRoKHRoaXMsIGl0ZXJzLCBtZXJnZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUludG9LZXllZFdpdGgoY29sbGVjdGlvbiwgY29sbGVjdGlvbnMsIG1lcmdlcikge1xuICB2YXIgaXRlcnMgPSBbXTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaWkrKykge1xuICAgIHZhciBjb2xsZWN0aW9uJDEgPSBLZXllZENvbGxlY3Rpb24oY29sbGVjdGlvbnNbaWldKTtcbiAgICBpZiAoY29sbGVjdGlvbiQxLnNpemUgIT09IDApIHtcbiAgICAgIGl0ZXJzLnB1c2goY29sbGVjdGlvbiQxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9XG4gIGlmIChcbiAgICBjb2xsZWN0aW9uLnRvU2VxKCkuc2l6ZSA9PT0gMCAmJlxuICAgICFjb2xsZWN0aW9uLl9fb3duZXJJRCAmJlxuICAgIGl0ZXJzLmxlbmd0aCA9PT0gMVxuICApIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5jb25zdHJ1Y3RvcihpdGVyc1swXSk7XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb24ud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciBtZXJnZUludG9Db2xsZWN0aW9uID0gbWVyZ2VyXG4gICAgICA/IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgdXBkYXRlKFxuICAgICAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIE5PVF9TRVQsXG4gICAgICAgICAgICBmdW5jdGlvbiAob2xkVmFsKSB7IHJldHVybiAob2xkVmFsID09PSBOT1RfU0VUID8gdmFsdWUgOiBtZXJnZXIob2xkVmFsLCB2YWx1ZSwga2V5KSk7IH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICA6IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgY29sbGVjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGl0ZXJzLmxlbmd0aDsgaWkrKykge1xuICAgICAgaXRlcnNbaWldLmZvckVhY2gobWVyZ2VJbnRvQ29sbGVjdGlvbik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UkMShjb2xsZWN0aW9uKSB7XG4gIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcyk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlV2l0aCQxKG1lcmdlciwgY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gIHJldHVybiBtZXJnZVdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMsIG1lcmdlcik7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcChjb2xsZWN0aW9uKSB7XG4gIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIG1lcmdlRGVlcFdpdGhTb3VyY2VzKGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXBXaXRoKG1lcmdlciwgY29sbGVjdGlvbikge1xuICB2YXIgc291cmNlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBzb3VyY2VzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXBXaXRoU291cmNlcyhjb2xsZWN0aW9uLCBzb3VyY2VzLCBtZXJnZXIpIHtcbiAgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgZGVlcE1lcmdlcldpdGgobWVyZ2VyKSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlV2l0aFNvdXJjZXMoY29sbGVjdGlvbiwgc291cmNlcywgbWVyZ2VyKSB7XG4gIGlmICghaXNEYXRhU3RydWN0dXJlKGNvbGxlY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdDYW5ub3QgbWVyZ2UgaW50byBub24tZGF0YS1zdHJ1Y3R1cmUgdmFsdWU6ICcgKyBjb2xsZWN0aW9uXG4gICAgKTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUoY29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lcmdlciA9PT0gJ2Z1bmN0aW9uJyAmJiBjb2xsZWN0aW9uLm1lcmdlV2l0aFxuICAgICAgPyBjb2xsZWN0aW9uLm1lcmdlV2l0aC5hcHBseShjb2xsZWN0aW9uLCBbIG1lcmdlciBdLmNvbmNhdCggc291cmNlcyApKVxuICAgICAgOiBjb2xsZWN0aW9uLm1lcmdlXG4gICAgICAgID8gY29sbGVjdGlvbi5tZXJnZS5hcHBseShjb2xsZWN0aW9uLCBzb3VyY2VzKVxuICAgICAgICA6IGNvbGxlY3Rpb24uY29uY2F0LmFwcGx5KGNvbGxlY3Rpb24sIHNvdXJjZXMpO1xuICB9XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKTtcbiAgdmFyIG1lcmdlZCA9IGNvbGxlY3Rpb247XG4gIHZhciBDb2xsZWN0aW9uJCQxID0gaXNBcnJheSA/IEluZGV4ZWRDb2xsZWN0aW9uIDogS2V5ZWRDb2xsZWN0aW9uO1xuICB2YXIgbWVyZ2VJdGVtID0gaXNBcnJheVxuICAgID8gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIENvcHkgb24gd3JpdGVcbiAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICAgIG1lcmdlZCA9IHNoYWxsb3dDb3B5KG1lcmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VkLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGhhc1ZhbCA9IGhhc093blByb3BlcnR5LmNhbGwobWVyZ2VkLCBrZXkpO1xuICAgICAgICB2YXIgbmV4dFZhbCA9XG4gICAgICAgICAgaGFzVmFsICYmIG1lcmdlciA/IG1lcmdlcihtZXJnZWRba2V5XSwgdmFsdWUsIGtleSkgOiB2YWx1ZTtcbiAgICAgICAgaWYgKCFoYXNWYWwgfHwgbmV4dFZhbCAhPT0gbWVyZ2VkW2tleV0pIHtcbiAgICAgICAgICAvLyBDb3B5IG9uIHdyaXRlXG4gICAgICAgICAgaWYgKG1lcmdlZCA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgbWVyZ2VkID0gc2hhbGxvd0NvcHkobWVyZ2VkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVyZ2VkW2tleV0gPSBuZXh0VmFsO1xuICAgICAgICB9XG4gICAgICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICBDb2xsZWN0aW9uJCQxKHNvdXJjZXNbaV0pLmZvckVhY2gobWVyZ2VJdGVtKTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiBkZWVwTWVyZ2VyV2l0aChtZXJnZXIpIHtcbiAgZnVuY3Rpb24gZGVlcE1lcmdlcihvbGRWYWx1ZSwgbmV3VmFsdWUsIGtleSkge1xuICAgIHJldHVybiBpc0RhdGFTdHJ1Y3R1cmUob2xkVmFsdWUpICYmIGlzRGF0YVN0cnVjdHVyZShuZXdWYWx1ZSlcbiAgICAgID8gbWVyZ2VXaXRoU291cmNlcyhvbGRWYWx1ZSwgW25ld1ZhbHVlXSwgZGVlcE1lcmdlcilcbiAgICAgIDogbWVyZ2VyXG4gICAgICAgID8gbWVyZ2VyKG9sZFZhbHVlLCBuZXdWYWx1ZSwga2V5KVxuICAgICAgICA6IG5ld1ZhbHVlO1xuICB9XG4gIHJldHVybiBkZWVwTWVyZ2VyO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAkMSgpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyh0aGlzLCBpdGVycyk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcFdpdGgkMShtZXJnZXIpIHtcbiAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXG4gIHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyh0aGlzLCBpdGVycywgbWVyZ2VyKTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJbihrZXlQYXRoKSB7XG4gIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCBsZW4tLSA+IDAgKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiArIDEgXTtcblxuICByZXR1cm4gdXBkYXRlSW4odGhpcywga2V5UGF0aCwgZW1wdHlNYXAoKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1lcmdlV2l0aFNvdXJjZXMobSwgaXRlcnMpOyB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEZWVwSW4oa2V5UGF0aCkge1xuICB2YXIgaXRlcnMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gIHdoaWxlICggbGVuLS0gPiAwICkgaXRlcnNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgcmV0dXJuIHVwZGF0ZUluKHRoaXMsIGtleVBhdGgsIGVtcHR5TWFwKCksIGZ1bmN0aW9uIChtKSB7IHJldHVybiBtZXJnZURlZXBXaXRoU291cmNlcyhtLCBpdGVycyk7IH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gd2l0aE11dGF0aW9ucyhmbikge1xuICB2YXIgbXV0YWJsZSA9IHRoaXMuYXNNdXRhYmxlKCk7XG4gIGZuKG11dGFibGUpO1xuICByZXR1cm4gbXV0YWJsZS53YXNBbHRlcmVkKCkgPyBtdXRhYmxlLl9fZW5zdXJlT3duZXIodGhpcy5fX293bmVySUQpIDogdGhpcztcbn1cblxuZnVuY3Rpb24gYXNNdXRhYmxlKCkge1xuICByZXR1cm4gdGhpcy5fX293bmVySUQgPyB0aGlzIDogdGhpcy5fX2Vuc3VyZU93bmVyKG5ldyBPd25lcklEKCkpO1xufVxuXG5mdW5jdGlvbiBhc0ltbXV0YWJsZSgpIHtcbiAgcmV0dXJuIHRoaXMuX19lbnN1cmVPd25lcigpO1xufVxuXG5mdW5jdGlvbiB3YXNBbHRlcmVkKCkge1xuICByZXR1cm4gdGhpcy5fX2FsdGVyZWQ7XG59XG5cbnZhciBNYXAgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChLZXllZENvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gTWFwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlNYXAoKVxuICAgICAgOiBpc01hcCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5TWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IEtleWVkQ29sbGVjdGlvbiQkMSh2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICB9KTtcbiAgfVxuXG4gIGlmICggS2V5ZWRDb2xsZWN0aW9uJCQxICkgTWFwLl9fcHJvdG9fXyA9IEtleWVkQ29sbGVjdGlvbiQkMTtcbiAgTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEtleWVkQ29sbGVjdGlvbiQkMSAmJiBLZXllZENvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXA7XG5cbiAgTWFwLm9mID0gZnVuY3Rpb24gb2YgKCkge1xuICAgIHZhciBrZXlWYWx1ZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkga2V5VmFsdWVzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gZW1wdHlNYXAoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChtYXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5VmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChpICsgMSA+PSBrZXlWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZhbHVlIGZvciBrZXk6ICcgKyBrZXlWYWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcC5zZXQoa2V5VmFsdWVzW2ldLCBrZXlWYWx1ZXNbaSArIDFdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ01hcCB7JywgJ30nKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9yb290XG4gICAgICA/IHRoaXMuX3Jvb3QuZ2V0KDAsIHVuZGVmaW5lZCwgaywgbm90U2V0VmFsdWUpXG4gICAgICA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cbiAgTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGssIHYpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFwKHRoaXMsIGssIHYpO1xuICB9O1xuXG4gIE1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hcCh0aGlzLCBrLCBOT1RfU0VUKTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLmRlbGV0ZUFsbCA9IGZ1bmN0aW9uIGRlbGV0ZUFsbCAoa2V5cykge1xuICAgIHZhciBjb2xsZWN0aW9uID0gQ29sbGVjdGlvbihrZXlzKTtcblxuICAgIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIG1hcC5yZW1vdmUoa2V5KTsgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gZW1wdHlNYXAoKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgTWFwLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gc29ydCAoY29tcGFyYXRvcikge1xuICAgIC8vIExhdGUgYmluZGluZ1xuICAgIHJldHVybiBPcmRlcmVkTWFwKHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IpKTtcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLnNvcnRCeSA9IGZ1bmN0aW9uIHNvcnRCeSAobWFwcGVyLCBjb21wYXJhdG9yKSB7XG4gICAgLy8gTGF0ZSBiaW5kaW5nXG4gICAgcmV0dXJuIE9yZGVyZWRNYXAoc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvciwgbWFwcGVyKSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKG1hcCkge1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcHBlci5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIG1hcCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNdXRhYmlsaXR5XG5cbiAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgdHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5fcm9vdCAmJlxuICAgICAgdGhpcy5fcm9vdC5pdGVyYXRlKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIHJldHVybiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIHRoaXMkMSk7XG4gICAgICB9LCByZXZlcnNlKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfTtcblxuICBNYXAucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eU1hcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZU1hcCh0aGlzLnNpemUsIHRoaXMuX3Jvb3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfTtcblxuICByZXR1cm4gTWFwO1xufShLZXllZENvbGxlY3Rpb24pKTtcblxuTWFwLmlzTWFwID0gaXNNYXA7XG5cbnZhciBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuTWFwUHJvdG90eXBlW0lTX01BUF9TWU1CT0xdID0gdHJ1ZTtcbk1hcFByb3RvdHlwZVtERUxFVEVdID0gTWFwUHJvdG90eXBlLnJlbW92ZTtcbk1hcFByb3RvdHlwZS5yZW1vdmVBbGwgPSBNYXBQcm90b3R5cGUuZGVsZXRlQWxsO1xuTWFwUHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcbk1hcFByb3RvdHlwZS5yZW1vdmVJbiA9IE1hcFByb3RvdHlwZS5kZWxldGVJbiA9IGRlbGV0ZUluO1xuTWFwUHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZSQxO1xuTWFwUHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW4kMTtcbk1hcFByb3RvdHlwZS5tZXJnZSA9IE1hcFByb3RvdHlwZS5jb25jYXQgPSBtZXJnZTtcbk1hcFByb3RvdHlwZS5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG5NYXBQcm90b3R5cGUubWVyZ2VEZWVwID0gbWVyZ2VEZWVwJDE7XG5NYXBQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGgkMTtcbk1hcFByb3RvdHlwZS5tZXJnZUluID0gbWVyZ2VJbjtcbk1hcFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuTWFwUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuTWFwUHJvdG90eXBlLndhc0FsdGVyZWQgPSB3YXNBbHRlcmVkO1xuTWFwUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5NYXBQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBNYXBQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuTWFwUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24ocmVzdWx0LCBhcnIpIHtcbiAgcmV0dXJuIHJlc3VsdC5zZXQoYXJyWzBdLCBhcnJbMV0pO1xufTtcbk1hcFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cbi8vICNwcmFnbWEgVHJpZSBOb2Rlc1xuXG52YXIgQXJyYXlNYXBOb2RlID0gZnVuY3Rpb24gQXJyYXlNYXBOb2RlKG93bmVySUQsIGVudHJpZXMpIHtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbn07XG5cbkFycmF5TWFwTm9kZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChzaGlmdCwga2V5SGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgZm9yICh2YXIgaWkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaWkgPCBsZW47IGlpKyspIHtcbiAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzW2lpXVsxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vdFNldFZhbHVlO1xufTtcblxuQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoO1xuICBmb3IgKDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWR4XVswXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuXG4gIGlmIChleGlzdHMgPyBlbnRyaWVzW2lkeF1bMV0gPT09IHZhbHVlIDogcmVtb3ZlZCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgKHJlbW92ZWQgfHwgIWV4aXN0cykgJiYgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuXG4gIGlmIChyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICghZXhpc3RzICYmICFyZW1vdmVkICYmIGVudHJpZXMubGVuZ3RoID49IE1BWF9BUlJBWV9NQVBfU0laRSkge1xuICAgIHJldHVybiBjcmVhdGVOb2Rlcyhvd25lcklELCBlbnRyaWVzLCBrZXksIHZhbHVlKTtcbiAgfVxuXG4gIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gIGlmIChleGlzdHMpIHtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaWR4ID09PSBsZW4gLSAxXG4gICAgICAgID8gbmV3RW50cmllcy5wb3AoKVxuICAgICAgICA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfVxuXG4gIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXcgQXJyYXlNYXBOb2RlKG93bmVySUQsIG5ld0VudHJpZXMpO1xufTtcblxudmFyIEJpdG1hcEluZGV4ZWROb2RlID0gZnVuY3Rpb24gQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgYml0bWFwLCBub2Rlcykge1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcbiAgdGhpcy5ub2RlcyA9IG5vZGVzO1xufTtcblxuQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoc2hpZnQsIGtleUhhc2gsIGtleSwgbm90U2V0VmFsdWUpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cbiAgdmFyIGJpdCA9IDEgPDwgKChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLKTtcbiAgdmFyIGJpdG1hcCA9IHRoaXMuYml0bWFwO1xuICByZXR1cm4gKGJpdG1hcCAmIGJpdCkgPT09IDBcbiAgICA/IG5vdFNldFZhbHVlXG4gICAgOiB0aGlzLm5vZGVzW3BvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSldLmdldChcbiAgICAgICAgc2hpZnQgKyBTSElGVCxcbiAgICAgICAga2V5SGFzaCxcbiAgICAgICAga2V5LFxuICAgICAgICBub3RTZXRWYWx1ZVxuICAgICAgKTtcbn07XG5cbkJpdG1hcEluZGV4ZWROb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgfVxuICB2YXIga2V5SGFzaEZyYWcgPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIGJpdCA9IDEgPDwga2V5SGFzaEZyYWc7XG4gIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgdmFyIGV4aXN0cyA9IChiaXRtYXAgJiBiaXQpICE9PSAwO1xuXG4gIGlmICghZXhpc3RzICYmIHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgaWR4ID0gcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIG5vZGUgPSBleGlzdHMgPyBub2Rlc1tpZHhdIDogdW5kZWZpbmVkO1xuICB2YXIgbmV3Tm9kZSA9IHVwZGF0ZU5vZGUoXG4gICAgbm9kZSxcbiAgICBvd25lcklELFxuICAgIHNoaWZ0ICsgU0hJRlQsXG4gICAga2V5SGFzaCxcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgZGlkQ2hhbmdlU2l6ZSxcbiAgICBkaWRBbHRlclxuICApO1xuXG4gIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoIWV4aXN0cyAmJiBuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA+PSBNQVhfQklUTUFQX0lOREVYRURfU0laRSkge1xuICAgIHJldHVybiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBrZXlIYXNoRnJhZywgbmV3Tm9kZSk7XG4gIH1cblxuICBpZiAoXG4gICAgZXhpc3RzICYmXG4gICAgIW5ld05vZGUgJiZcbiAgICBub2Rlcy5sZW5ndGggPT09IDIgJiZcbiAgICBpc0xlYWZOb2RlKG5vZGVzW2lkeCBeIDFdKVxuICApIHtcbiAgICByZXR1cm4gbm9kZXNbaWR4IF4gMV07XG4gIH1cblxuICBpZiAoZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAxICYmIGlzTGVhZk5vZGUobmV3Tm9kZSkpIHtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gIHZhciBuZXdCaXRtYXAgPSBleGlzdHMgPyAobmV3Tm9kZSA/IGJpdG1hcCA6IGJpdG1hcCBeIGJpdCkgOiBiaXRtYXAgfCBiaXQ7XG4gIHZhciBuZXdOb2RlcyA9IGV4aXN0c1xuICAgID8gbmV3Tm9kZVxuICAgICAgPyBzZXRBdChub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKVxuICAgICAgOiBzcGxpY2VPdXQobm9kZXMsIGlkeCwgaXNFZGl0YWJsZSlcbiAgICA6IHNwbGljZUluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuXG4gIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgdGhpcy5iaXRtYXAgPSBuZXdCaXRtYXA7XG4gICAgdGhpcy5ub2RlcyA9IG5ld05vZGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBuZXdCaXRtYXAsIG5ld05vZGVzKTtcbn07XG5cbnZhciBIYXNoQXJyYXlNYXBOb2RlID0gZnVuY3Rpb24gSGFzaEFycmF5TWFwTm9kZShvd25lcklELCBjb3VudCwgbm9kZXMpIHtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgdGhpcy5jb3VudCA9IGNvdW50O1xuICB0aGlzLm5vZGVzID0gbm9kZXM7XG59O1xuXG5IYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIGlmIChrZXlIYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBrZXlIYXNoID0gaGFzaChrZXkpO1xuICB9XG4gIHZhciBpZHggPSAoc2hpZnQgPT09IDAgPyBrZXlIYXNoIDoga2V5SGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2lkeF07XG4gIHJldHVybiBub2RlXG4gICAgPyBub2RlLmdldChzaGlmdCArIFNISUZULCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKVxuICAgIDogbm90U2V0VmFsdWU7XG59O1xuXG5IYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICBpZiAoa2V5SGFzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5SGFzaCA9IGhhc2goa2V5KTtcbiAgfVxuICB2YXIgaWR4ID0gKHNoaWZ0ID09PSAwID8ga2V5SGFzaCA6IGtleUhhc2ggPj4+IHNoaWZ0KSAmIE1BU0s7XG4gIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBub2RlID0gbm9kZXNbaWR4XTtcblxuICBpZiAocmVtb3ZlZCAmJiAhbm9kZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKFxuICAgIG5vZGUsXG4gICAgb3duZXJJRCxcbiAgICBzaGlmdCArIFNISUZULFxuICAgIGtleUhhc2gsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGRpZENoYW5nZVNpemUsXG4gICAgZGlkQWx0ZXJcbiAgKTtcbiAgaWYgKG5ld05vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBuZXdDb3VudCA9IHRoaXMuY291bnQ7XG4gIGlmICghbm9kZSkge1xuICAgIG5ld0NvdW50Kys7XG4gIH0gZWxzZSBpZiAoIW5ld05vZGUpIHtcbiAgICBuZXdDb3VudC0tO1xuICAgIGlmIChuZXdDb3VudCA8IE1JTl9IQVNIX0FSUkFZX01BUF9TSVpFKSB7XG4gICAgICByZXR1cm4gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBuZXdDb3VudCwgaWR4KTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICB2YXIgbmV3Tm9kZXMgPSBzZXRBdChub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKTtcblxuICBpZiAoaXNFZGl0YWJsZSkge1xuICAgIHRoaXMuY291bnQgPSBuZXdDb3VudDtcbiAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3IEhhc2hBcnJheU1hcE5vZGUob3duZXJJRCwgbmV3Q291bnQsIG5ld05vZGVzKTtcbn07XG5cbnZhciBIYXNoQ29sbGlzaW9uTm9kZSA9IGZ1bmN0aW9uIEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJpZXMpIHtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgdGhpcy5rZXlIYXNoID0ga2V5SGFzaDtcbiAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbn07XG5cbkhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICBmb3IgKHZhciBpaSA9IDAsIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKykge1xuICAgIGlmIChpcyhrZXksIGVudHJpZXNbaWldWzBdKSkge1xuICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm90U2V0VmFsdWU7XG59O1xuXG5IYXNoQ29sbGlzaW9uTm9kZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlIChvd25lcklELCBzaGlmdCwga2V5SGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlU2l6ZSwgZGlkQWx0ZXIpIHtcbiAgaWYgKGtleUhhc2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGtleUhhc2ggPSBoYXNoKGtleSk7XG4gIH1cblxuICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuXG4gIGlmIChrZXlIYXNoICE9PSB0aGlzLmtleUhhc2gpIHtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFNldFJlZihkaWRBbHRlcik7XG4gICAgU2V0UmVmKGRpZENoYW5nZVNpemUpO1xuICAgIHJldHVybiBtZXJnZUludG9Ob2RlKHRoaXMsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBba2V5LCB2YWx1ZV0pO1xuICB9XG5cbiAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gIGZvciAoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgaWYgKGlzKGtleSwgZW50cmllc1tpZHhdWzBdKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBleGlzdHMgPSBpZHggPCBsZW47XG5cbiAgaWYgKGV4aXN0cyA/IGVudHJpZXNbaWR4XVsxXSA9PT0gdmFsdWUgOiByZW1vdmVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAocmVtb3ZlZCB8fCAhZXhpc3RzKSAmJiBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG5cbiAgaWYgKHJlbW92ZWQgJiYgbGVuID09PSAyKSB7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBlbnRyaWVzW2lkeCBeIDFdKTtcbiAgfVxuXG4gIHZhciBpc0VkaXRhYmxlID0gb3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQ7XG4gIHZhciBuZXdFbnRyaWVzID0gaXNFZGl0YWJsZSA/IGVudHJpZXMgOiBhcnJDb3B5KGVudHJpZXMpO1xuXG4gIGlmIChleGlzdHMpIHtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgaWR4ID09PSBsZW4gLSAxXG4gICAgICAgID8gbmV3RW50cmllcy5wb3AoKVxuICAgICAgICA6IChuZXdFbnRyaWVzW2lkeF0gPSBuZXdFbnRyaWVzLnBvcCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfVxuXG4gIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgdGhpcy5lbnRyaWVzID0gbmV3RW50cmllcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBuZXcgSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwgdGhpcy5rZXlIYXNoLCBuZXdFbnRyaWVzKTtcbn07XG5cbnZhciBWYWx1ZU5vZGUgPSBmdW5jdGlvbiBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgZW50cnkpIHtcbiAgdGhpcy5vd25lcklEID0gb3duZXJJRDtcbiAgdGhpcy5rZXlIYXNoID0ga2V5SGFzaDtcbiAgdGhpcy5lbnRyeSA9IGVudHJ5O1xufTtcblxuVmFsdWVOb2RlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHNoaWZ0LCBrZXlIYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gIHJldHVybiBpcyhrZXksIHRoaXMuZW50cnlbMF0pID8gdGhpcy5lbnRyeVsxXSA6IG5vdFNldFZhbHVlO1xufTtcblxuVmFsdWVOb2RlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBrZXksIHZhbHVlLCBkaWRDaGFuZ2VTaXplLCBkaWRBbHRlcikge1xuICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICB2YXIga2V5TWF0Y2ggPSBpcyhrZXksIHRoaXMuZW50cnlbMF0pO1xuICBpZiAoa2V5TWF0Y2ggPyB2YWx1ZSA9PT0gdGhpcy5lbnRyeVsxXSA6IHJlbW92ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFNldFJlZihkaWRBbHRlcik7XG5cbiAgaWYgKHJlbW92ZWQpIHtcbiAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgfVxuXG4gIGlmIChrZXlNYXRjaCkge1xuICAgIGlmIChvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRCkge1xuICAgICAgdGhpcy5lbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVmFsdWVOb2RlKG93bmVySUQsIHRoaXMua2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgfVxuXG4gIFNldFJlZihkaWRDaGFuZ2VTaXplKTtcbiAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGhhc2goa2V5KSwgW2tleSwgdmFsdWVdKTtcbn07XG5cbi8vICNwcmFnbWEgSXRlcmF0b3JzXG5cbkFycmF5TWFwTm9kZS5wcm90b3R5cGUuaXRlcmF0ZSA9IEhhc2hDb2xsaXNpb25Ob2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24oXG4gIGZuLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIGVudHJpZXMgPSB0aGlzLmVudHJpZXM7XG4gIGZvciAodmFyIGlpID0gMCwgbWF4SW5kZXggPSBlbnRyaWVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgaWYgKGZuKGVudHJpZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuQml0bWFwSW5kZXhlZE5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBIYXNoQXJyYXlNYXBOb2RlLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24oXG4gIGZuLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgZm9yICh2YXIgaWkgPSAwLCBtYXhJbmRleCA9IG5vZGVzLmxlbmd0aCAtIDE7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tyZXZlcnNlID8gbWF4SW5kZXggLSBpaSA6IGlpXTtcbiAgICBpZiAobm9kZSAmJiBub2RlLml0ZXJhdGUoZm4sIHJldmVyc2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5WYWx1ZU5vZGUucHJvdG90eXBlLml0ZXJhdGUgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICByZXR1cm4gZm4odGhpcy5lbnRyeSk7XG59O1xuXG52YXIgTWFwSXRlcmF0b3IgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChJdGVyYXRvciQkMSkge1xuICBmdW5jdGlvbiBNYXBJdGVyYXRvcihtYXAsIHR5cGUsIHJldmVyc2UpIHtcbiAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICB0aGlzLl9yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICB0aGlzLl9zdGFjayA9IG1hcC5fcm9vdCAmJiBtYXBJdGVyYXRvckZyYW1lKG1hcC5fcm9vdCk7XG4gIH1cblxuICBpZiAoIEl0ZXJhdG9yJCQxICkgTWFwSXRlcmF0b3IuX19wcm90b19fID0gSXRlcmF0b3IkJDE7XG4gIE1hcEl0ZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZXJhdG9yJCQxICYmIEl0ZXJhdG9yJCQxLnByb3RvdHlwZSApO1xuICBNYXBJdGVyYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBJdGVyYXRvcjtcblxuICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICB3aGlsZSAoc3RhY2spIHtcbiAgICAgIHZhciBub2RlID0gc3RhY2subm9kZTtcbiAgICAgIHZhciBpbmRleCA9IHN0YWNrLmluZGV4Kys7XG4gICAgICB2YXIgbWF4SW5kZXggPSAodm9pZCAwKTtcbiAgICAgIGlmIChub2RlLmVudHJ5KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIG5vZGUuZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuZW50cmllcykge1xuICAgICAgICBtYXhJbmRleCA9IG5vZGUuZW50cmllcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaW5kZXggPD0gbWF4SW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZShcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBub2RlLmVudHJpZXNbdGhpcy5fcmV2ZXJzZSA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhJbmRleCA9IG5vZGUubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgdmFyIHN1Yk5vZGUgPSBub2RlLm5vZGVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdO1xuICAgICAgICAgIGlmIChzdWJOb2RlKSB7XG4gICAgICAgICAgICBpZiAoc3ViTm9kZS5lbnRyeSkge1xuICAgICAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBzdWJOb2RlLmVudHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSBtYXBJdGVyYXRvckZyYW1lKHN1Yk5vZGUsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSB0aGlzLl9zdGFjay5fX3ByZXY7XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgfTtcblxuICByZXR1cm4gTWFwSXRlcmF0b3I7XG59KEl0ZXJhdG9yKSk7XG5cbmZ1bmN0aW9uIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnkpIHtcbiAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgZW50cnlbMF0sIGVudHJ5WzFdKTtcbn1cblxuZnVuY3Rpb24gbWFwSXRlcmF0b3JGcmFtZShub2RlLCBwcmV2KSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBpbmRleDogMCxcbiAgICBfX3ByZXY6IHByZXYsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VNYXAoc2l6ZSwgcm9vdCwgb3duZXJJRCwgaGFzaCQkMSkge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShNYXBQcm90b3R5cGUpO1xuICBtYXAuc2l6ZSA9IHNpemU7XG4gIG1hcC5fcm9vdCA9IHJvb3Q7XG4gIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICBtYXAuX19oYXNoID0gaGFzaCQkMTtcbiAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICByZXR1cm4gbWFwO1xufVxuXG52YXIgRU1QVFlfTUFQO1xuZnVuY3Rpb24gZW1wdHlNYXAoKSB7XG4gIHJldHVybiBFTVBUWV9NQVAgfHwgKEVNUFRZX01BUCA9IG1ha2VNYXAoMCkpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXAobWFwLCBrLCB2KSB7XG4gIHZhciBuZXdSb290O1xuICB2YXIgbmV3U2l6ZTtcbiAgaWYgKCFtYXAuX3Jvb3QpIHtcbiAgICBpZiAodiA9PT0gTk9UX1NFVCkge1xuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgbmV3U2l6ZSA9IDE7XG4gICAgbmV3Um9vdCA9IG5ldyBBcnJheU1hcE5vZGUobWFwLl9fb3duZXJJRCwgW1trLCB2XV0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBkaWRDaGFuZ2VTaXplID0gTWFrZVJlZigpO1xuICAgIHZhciBkaWRBbHRlciA9IE1ha2VSZWYoKTtcbiAgICBuZXdSb290ID0gdXBkYXRlTm9kZShcbiAgICAgIG1hcC5fcm9vdCxcbiAgICAgIG1hcC5fX293bmVySUQsXG4gICAgICAwLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgayxcbiAgICAgIHYsXG4gICAgICBkaWRDaGFuZ2VTaXplLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuICAgIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIG5ld1NpemUgPSBtYXAuc2l6ZSArIChkaWRDaGFuZ2VTaXplLnZhbHVlID8gKHYgPT09IE5PVF9TRVQgPyAtMSA6IDEpIDogMCk7XG4gIH1cbiAgaWYgKG1hcC5fX293bmVySUQpIHtcbiAgICBtYXAuc2l6ZSA9IG5ld1NpemU7XG4gICAgbWFwLl9yb290ID0gbmV3Um9vdDtcbiAgICBtYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgIG1hcC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgcmV0dXJuIG5ld1Jvb3QgPyBtYWtlTWFwKG5ld1NpemUsIG5ld1Jvb3QpIDogZW1wdHlNYXAoKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTm9kZShcbiAgbm9kZSxcbiAgb3duZXJJRCxcbiAgc2hpZnQsXG4gIGtleUhhc2gsXG4gIGtleSxcbiAgdmFsdWUsXG4gIGRpZENoYW5nZVNpemUsXG4gIGRpZEFsdGVyXG4pIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgaWYgKHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICBTZXRSZWYoZGlkQ2hhbmdlU2l6ZSk7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwga2V5SGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgfVxuICByZXR1cm4gbm9kZS51cGRhdGUoXG4gICAgb3duZXJJRCxcbiAgICBzaGlmdCxcbiAgICBrZXlIYXNoLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBkaWRDaGFuZ2VTaXplLFxuICAgIGRpZEFsdGVyXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzTGVhZk5vZGUobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUuY29uc3RydWN0b3IgPT09IFZhbHVlTm9kZSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBIYXNoQ29sbGlzaW9uTm9kZVxuICApO1xufVxuXG5mdW5jdGlvbiBtZXJnZUludG9Ob2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0LCBrZXlIYXNoLCBlbnRyeSkge1xuICBpZiAobm9kZS5rZXlIYXNoID09PSBrZXlIYXNoKSB7XG4gICAgcmV0dXJuIG5ldyBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBrZXlIYXNoLCBbbm9kZS5lbnRyeSwgZW50cnldKTtcbiAgfVxuXG4gIHZhciBpZHgxID0gKHNoaWZ0ID09PSAwID8gbm9kZS5rZXlIYXNoIDogbm9kZS5rZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICB2YXIgaWR4MiA9IChzaGlmdCA9PT0gMCA/IGtleUhhc2ggOiBrZXlIYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuXG4gIHZhciBuZXdOb2RlO1xuICB2YXIgbm9kZXMgPVxuICAgIGlkeDEgPT09IGlkeDJcbiAgICAgID8gW21lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQgKyBTSElGVCwga2V5SGFzaCwgZW50cnkpXVxuICAgICAgOiAoKG5ld05vZGUgPSBuZXcgVmFsdWVOb2RlKG93bmVySUQsIGtleUhhc2gsIGVudHJ5KSksXG4gICAgICAgIGlkeDEgPCBpZHgyID8gW25vZGUsIG5ld05vZGVdIDogW25ld05vZGUsIG5vZGVdKTtcblxuICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsICgxIDw8IGlkeDEpIHwgKDEgPDwgaWR4MiksIG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZXMob3duZXJJRCwgZW50cmllcywga2V5LCB2YWx1ZSkge1xuICBpZiAoIW93bmVySUQpIHtcbiAgICBvd25lcklEID0gbmV3IE93bmVySUQoKTtcbiAgfVxuICB2YXIgbm9kZSA9IG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgaGFzaChrZXkpLCBba2V5LCB2YWx1ZV0pO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgZW50cmllcy5sZW5ndGg7IGlpKyspIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2lpXTtcbiAgICBub2RlID0gbm9kZS51cGRhdGUob3duZXJJRCwgMCwgdW5kZWZpbmVkLCBlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIGNvdW50LCBleGNsdWRpbmcpIHtcbiAgdmFyIGJpdG1hcCA9IDA7XG4gIHZhciBwYWNrZWRJSSA9IDA7XG4gIHZhciBwYWNrZWROb2RlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gIGZvciAodmFyIGlpID0gMCwgYml0ID0gMSwgbGVuID0gbm9kZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKywgYml0IDw8PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpaV07XG4gICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBpaSAhPT0gZXhjbHVkaW5nKSB7XG4gICAgICBiaXRtYXAgfD0gYml0O1xuICAgICAgcGFja2VkTm9kZXNbcGFja2VkSUkrK10gPSBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgcGFja2VkTm9kZXMpO1xufVxuXG5mdW5jdGlvbiBleHBhbmROb2Rlcyhvd25lcklELCBub2RlcywgYml0bWFwLCBpbmNsdWRpbmcsIG5vZGUpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGV4cGFuZGVkTm9kZXMgPSBuZXcgQXJyYXkoU0laRSk7XG4gIGZvciAodmFyIGlpID0gMDsgYml0bWFwICE9PSAwOyBpaSsrLCBiaXRtYXAgPj4+PSAxKSB7XG4gICAgZXhwYW5kZWROb2Rlc1tpaV0gPSBiaXRtYXAgJiAxID8gbm9kZXNbY291bnQrK10gOiB1bmRlZmluZWQ7XG4gIH1cbiAgZXhwYW5kZWROb2Rlc1tpbmNsdWRpbmddID0gbm9kZTtcbiAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBOb2RlKG93bmVySUQsIGNvdW50ICsgMSwgZXhwYW5kZWROb2Rlcyk7XG59XG5cbmZ1bmN0aW9uIHBvcENvdW50KHgpIHtcbiAgeCAtPSAoeCA+PiAxKSAmIDB4NTU1NTU1NTU7XG4gIHggPSAoeCAmIDB4MzMzMzMzMzMpICsgKCh4ID4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHggPSAoeCArICh4ID4+IDQpKSAmIDB4MGYwZjBmMGY7XG4gIHggKz0geCA+PiA4O1xuICB4ICs9IHggPj4gMTY7XG4gIHJldHVybiB4ICYgMHg3Zjtcbn1cblxuZnVuY3Rpb24gc2V0QXQoYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gIHZhciBuZXdBcnJheSA9IGNhbkVkaXQgPyBhcnJheSA6IGFyckNvcHkoYXJyYXkpO1xuICBuZXdBcnJheVtpZHhdID0gdmFsO1xuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZUluKGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICB2YXIgbmV3TGVuID0gYXJyYXkubGVuZ3RoICsgMTtcbiAgaWYgKGNhbkVkaXQgJiYgaWR4ICsgMSA9PT0gbmV3TGVuKSB7XG4gICAgYXJyYXlbaWR4XSA9IHZhbDtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgdmFyIG5ld0FycmF5ID0gbmV3IEFycmF5KG5ld0xlbik7XG4gIHZhciBhZnRlciA9IDA7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBuZXdMZW47IGlpKyspIHtcbiAgICBpZiAoaWkgPT09IGlkeCkge1xuICAgICAgbmV3QXJyYXlbaWldID0gdmFsO1xuICAgICAgYWZ0ZXIgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT3V0KGFycmF5LCBpZHgsIGNhbkVkaXQpIHtcbiAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gIGlmIChjYW5FZGl0ICYmIGlkeCA9PT0gbmV3TGVuKSB7XG4gICAgYXJyYXkucG9wKCk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICB2YXIgYWZ0ZXIgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgIGFmdGVyID0gMTtcbiAgICB9XG4gICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG52YXIgTUFYX0FSUkFZX01BUF9TSVpFID0gU0laRSAvIDQ7XG52YXIgTUFYX0JJVE1BUF9JTkRFWEVEX1NJWkUgPSBTSVpFIC8gMjtcbnZhciBNSU5fSEFTSF9BUlJBWV9NQVBfU0laRSA9IFNJWkUgLyA0O1xuXG52YXIgSVNfTElTVF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9MSVNUX19AQCc7XG5cbmZ1bmN0aW9uIGlzTGlzdChtYXliZUxpc3QpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVMaXN0ICYmIG1heWJlTGlzdFtJU19MSVNUX1NZTUJPTF0pO1xufVxuXG52YXIgTGlzdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIExpc3QodmFsdWUpIHtcbiAgICB2YXIgZW1wdHkgPSBlbXB0eUxpc3QoKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cbiAgICBpZiAoaXNMaXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB2YXIgaXRlciA9IEluZGV4ZWRDb2xsZWN0aW9uJCQxKHZhbHVlKTtcbiAgICB2YXIgc2l6ZSA9IGl0ZXIuc2l6ZTtcbiAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH1cbiAgICBhc3NlcnROb3RJbmZpbml0ZShzaXplKTtcbiAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSA8IFNJWkUpIHtcbiAgICAgIHJldHVybiBtYWtlTGlzdCgwLCBzaXplLCBTSElGVCwgbnVsbCwgbmV3IFZOb2RlKGl0ZXIudG9BcnJheSgpKSk7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBsaXN0LnNldFNpemUoc2l6ZSk7XG4gICAgICBpdGVyLmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIGxpc3Quc2V0KGksIHYpOyB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICggSW5kZXhlZENvbGxlY3Rpb24kJDEgKSBMaXN0Ll9fcHJvdG9fXyA9IEluZGV4ZWRDb2xsZWN0aW9uJCQxO1xuICBMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRDb2xsZWN0aW9uJCQxICYmIEluZGV4ZWRDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpc3Q7XG5cbiAgTGlzdC5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdMaXN0IFsnLCAnXScpO1xuICB9O1xuXG4gIC8vIEBwcmFnbWEgQWNjZXNzXG5cbiAgTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICBpbmRleCA9IHdyYXBJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNpemUpIHtcbiAgICAgIGluZGV4ICs9IHRoaXMuX29yaWdpbjtcbiAgICAgIHZhciBub2RlID0gbGlzdE5vZGVGb3IodGhpcywgaW5kZXgpO1xuICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5hcnJheVtpbmRleCAmIE1BU0tdO1xuICAgIH1cbiAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB1cGRhdGVMaXN0KHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5oYXMoaW5kZXgpXG4gICAgICA/IHRoaXNcbiAgICAgIDogaW5kZXggPT09IDBcbiAgICAgICAgPyB0aGlzLnNoaWZ0KClcbiAgICAgICAgOiBpbmRleCA9PT0gdGhpcy5zaXplIC0gMVxuICAgICAgICAgID8gdGhpcy5wb3AoKVxuICAgICAgICAgIDogdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKGluZGV4LCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gdGhpcy5fb3JpZ2luID0gdGhpcy5fY2FwYWNpdHkgPSAwO1xuICAgICAgdGhpcy5fbGV2ZWwgPSBTSElGVDtcbiAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl90YWlsID0gbnVsbDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAoLyouLi52YWx1ZXMqLykge1xuICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgdmFyIG9sZFNpemUgPSB0aGlzLnNpemU7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobGlzdCkge1xuICAgICAgc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBvbGRTaXplICsgdmFsdWVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgdmFsdWVzLmxlbmd0aDsgaWkrKykge1xuICAgICAgICBsaXN0LnNldChvbGRTaXplICsgaWksIHZhbHVlc1tpaV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCAoKSB7XG4gICAgcmV0dXJuIHNldExpc3RCb3VuZHModGhpcywgMCwgLTEpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0ICgvKi4uLnZhbHVlcyovKSB7XG4gICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBzZXRMaXN0Qm91bmRzKGxpc3QsIC12YWx1ZXMubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCB2YWx1ZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIGxpc3Quc2V0KGlpLCB2YWx1ZXNbaWldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0ICgpIHtcbiAgICByZXR1cm4gc2V0TGlzdEJvdW5kcyh0aGlzLCAxKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0ICgvKi4uLmNvbGxlY3Rpb25zKi8pIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgc2VxcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXJndW1lbnQgPSBhcmd1bWVudHMkMVtpXTtcbiAgICAgIHZhciBzZXEgPSBJbmRleGVkQ29sbGVjdGlvbiQkMShcbiAgICAgICAgdHlwZW9mIGFyZ3VtZW50ICE9PSAnc3RyaW5nJyAmJiBoYXNJdGVyYXRvcihhcmd1bWVudClcbiAgICAgICAgICA/IGFyZ3VtZW50XG4gICAgICAgICAgOiBbYXJndW1lbnRdXG4gICAgICApO1xuICAgICAgaWYgKHNlcS5zaXplICE9PSAwKSB7XG4gICAgICAgIHNlcXMucHVzaChzZXEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2Vxcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaXplID09PSAwICYmICF0aGlzLl9fb3duZXJJRCAmJiBzZXFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Ioc2Vxc1swXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgIHNlcXMuZm9yRWFjaChmdW5jdGlvbiAoc2VxKSB7IHJldHVybiBzZXEuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGxpc3QucHVzaCh2YWx1ZSk7IH0pOyB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBMaXN0LnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZSAoc2l6ZSkge1xuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKHRoaXMsIDAsIHNpemUpO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMkMS5zaXplOyBpKyspIHtcbiAgICAgICAgbGlzdC5zZXQoaSwgbWFwcGVyLmNhbGwoY29udGV4dCwgbGlzdC5nZXQoaSksIGksIGxpc3QpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gIExpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBzZXRMaXN0Qm91bmRzKFxuICAgICAgdGhpcyxcbiAgICAgIHJlc29sdmVCZWdpbihiZWdpbiwgc2l6ZSksXG4gICAgICByZXNvbHZlRW5kKGVuZCwgc2l6ZSlcbiAgICApO1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgdmFyIGluZGV4ID0gcmV2ZXJzZSA/IHRoaXMuc2l6ZSA6IDA7XG4gICAgdmFyIHZhbHVlcyA9IGl0ZXJhdGVMaXN0KHRoaXMsIHJldmVyc2UpO1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3IoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzKCk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IERPTkVcbiAgICAgICAgPyBpdGVyYXRvckRvbmUoKVxuICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IC0taW5kZXggOiBpbmRleCsrLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgTGlzdC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyB0aGlzLnNpemUgOiAwO1xuICAgIHZhciB2YWx1ZXMgPSBpdGVyYXRlTGlzdCh0aGlzLCByZXZlcnNlKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgd2hpbGUgKCh2YWx1ZSA9IHZhbHVlcygpKSAhPT0gRE9ORSkge1xuICAgICAgaWYgKGZuKHZhbHVlLCByZXZlcnNlID8gLS1pbmRleCA6IGluZGV4KyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG4gIExpc3QucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBlbXB0eUxpc3QoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VMaXN0KFxuICAgICAgdGhpcy5fb3JpZ2luLFxuICAgICAgdGhpcy5fY2FwYWNpdHksXG4gICAgICB0aGlzLl9sZXZlbCxcbiAgICAgIHRoaXMuX3Jvb3QsXG4gICAgICB0aGlzLl90YWlsLFxuICAgICAgb3duZXJJRCxcbiAgICAgIHRoaXMuX19oYXNoXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gTGlzdDtcbn0oSW5kZXhlZENvbGxlY3Rpb24pKTtcblxuTGlzdC5pc0xpc3QgPSBpc0xpc3Q7XG5cbnZhciBMaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG5MaXN0UHJvdG90eXBlW0lTX0xJU1RfU1lNQk9MXSA9IHRydWU7XG5MaXN0UHJvdG90eXBlW0RFTEVURV0gPSBMaXN0UHJvdG90eXBlLnJlbW92ZTtcbkxpc3RQcm90b3R5cGUubWVyZ2UgPSBMaXN0UHJvdG90eXBlLmNvbmNhdDtcbkxpc3RQcm90b3R5cGUuc2V0SW4gPSBzZXRJbiQxO1xuTGlzdFByb3RvdHlwZS5kZWxldGVJbiA9IExpc3RQcm90b3R5cGUucmVtb3ZlSW4gPSBkZWxldGVJbjtcbkxpc3RQcm90b3R5cGUudXBkYXRlID0gdXBkYXRlJDE7XG5MaXN0UHJvdG90eXBlLnVwZGF0ZUluID0gdXBkYXRlSW4kMTtcbkxpc3RQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG5MaXN0UHJvdG90eXBlLm1lcmdlRGVlcEluID0gbWVyZ2VEZWVwSW47XG5MaXN0UHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuTGlzdFByb3RvdHlwZS53YXNBbHRlcmVkID0gd2FzQWx0ZXJlZDtcbkxpc3RQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcbkxpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBMaXN0UHJvdG90eXBlLmFzTXV0YWJsZSA9IGFzTXV0YWJsZTtcbkxpc3RQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGFycikge1xuICByZXR1cm4gcmVzdWx0LnB1c2goYXJyKTtcbn07XG5MaXN0UHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xufTtcblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUoYXJyYXksIG93bmVySUQpIHtcbiAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xufTtcblxuLy8gVE9ETzogc2VlbXMgbGlrZSB0aGVzZSBtZXRob2RzIGFyZSB2ZXJ5IHNpbWlsYXJcblxuVk5vZGUucHJvdG90eXBlLnJlbW92ZUJlZm9yZSA9IGZ1bmN0aW9uIHJlbW92ZUJlZm9yZSAob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gbGV2ZWwgPyAxIDw8IGxldmVsIDogdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgb3JpZ2luSW5kZXggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gIGlmIChvcmlnaW5JbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgVk5vZGUoW10sIG93bmVySUQpO1xuICB9XG4gIHZhciByZW1vdmluZ0ZpcnN0ID0gb3JpZ2luSW5kZXggPT09IDA7XG4gIHZhciBuZXdDaGlsZDtcbiAgaWYgKGxldmVsID4gMCkge1xuICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbb3JpZ2luSW5kZXhdO1xuICAgIG5ld0NoaWxkID1cbiAgICAgIG9sZENoaWxkICYmIG9sZENoaWxkLnJlbW92ZUJlZm9yZShvd25lcklELCBsZXZlbCAtIFNISUZULCBpbmRleCk7XG4gICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiByZW1vdmluZ0ZpcnN0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92aW5nRmlyc3QgJiYgIW5ld0NoaWxkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgaWYgKCFyZW1vdmluZ0ZpcnN0KSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG9yaWdpbkluZGV4OyBpaSsrKSB7XG4gICAgICBlZGl0YWJsZS5hcnJheVtpaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIGlmIChuZXdDaGlsZCkge1xuICAgIGVkaXRhYmxlLmFycmF5W29yaWdpbkluZGV4XSA9IG5ld0NoaWxkO1xuICB9XG4gIHJldHVybiBlZGl0YWJsZTtcbn07XG5cblZOb2RlLnByb3RvdHlwZS5yZW1vdmVBZnRlciA9IGZ1bmN0aW9uIHJlbW92ZUFmdGVyIChvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSAobGV2ZWwgPyAxIDw8IGxldmVsIDogMCkgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgc2l6ZUluZGV4ID0gKChpbmRleCAtIDEpID4+PiBsZXZlbCkgJiBNQVNLO1xuICBpZiAoc2l6ZUluZGV4ID49IHRoaXMuYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbmV3Q2hpbGQ7XG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W3NpemVJbmRleF07XG4gICAgbmV3Q2hpbGQgPVxuICAgICAgb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQWZ0ZXIob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgc2l6ZUluZGV4ID09PSB0aGlzLmFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlZGl0YWJsZSA9IGVkaXRhYmxlVk5vZGUodGhpcywgb3duZXJJRCk7XG4gIGVkaXRhYmxlLmFycmF5LnNwbGljZShzaXplSW5kZXggKyAxKTtcbiAgaWYgKG5ld0NoaWxkKSB7XG4gICAgZWRpdGFibGUuYXJyYXlbc2l6ZUluZGV4XSA9IG5ld0NoaWxkO1xuICB9XG4gIHJldHVybiBlZGl0YWJsZTtcbn07XG5cbnZhciBET05FID0ge307XG5cbmZ1bmN0aW9uIGl0ZXJhdGVMaXN0KGxpc3QsIHJldmVyc2UpIHtcbiAgdmFyIGxlZnQgPSBsaXN0Ll9vcmlnaW47XG4gIHZhciByaWdodCA9IGxpc3QuX2NhcGFjaXR5O1xuICB2YXIgdGFpbFBvcyA9IGdldFRhaWxPZmZzZXQocmlnaHQpO1xuICB2YXIgdGFpbCA9IGxpc3QuX3RhaWw7XG5cbiAgcmV0dXJuIGl0ZXJhdGVOb2RlT3JMZWFmKGxpc3QuX3Jvb3QsIGxpc3QuX2xldmVsLCAwKTtcblxuICBmdW5jdGlvbiBpdGVyYXRlTm9kZU9yTGVhZihub2RlLCBsZXZlbCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGxldmVsID09PSAwXG4gICAgICA/IGl0ZXJhdGVMZWFmKG5vZGUsIG9mZnNldClcbiAgICAgIDogaXRlcmF0ZU5vZGUobm9kZSwgbGV2ZWwsIG9mZnNldCk7XG4gIH1cblxuICBmdW5jdGlvbiBpdGVyYXRlTGVhZihub2RlLCBvZmZzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBvZmZzZXQgPT09IHRhaWxQb3MgPyB0YWlsICYmIHRhaWwuYXJyYXkgOiBub2RlICYmIG5vZGUuYXJyYXk7XG4gICAgdmFyIGZyb20gPSBvZmZzZXQgPiBsZWZ0ID8gMCA6IGxlZnQgLSBvZmZzZXQ7XG4gICAgdmFyIHRvID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgdG8gPSBTSVpFO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgIHJldHVybiBET05FO1xuICAgICAgfVxuICAgICAgdmFyIGlkeCA9IHJldmVyc2UgPyAtLXRvIDogZnJvbSsrO1xuICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5W2lkeF07XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQpIHtcbiAgICB2YXIgdmFsdWVzO1xuICAgIHZhciBhcnJheSA9IG5vZGUgJiYgbm9kZS5hcnJheTtcbiAgICB2YXIgZnJvbSA9IG9mZnNldCA+IGxlZnQgPyAwIDogKGxlZnQgLSBvZmZzZXQpID4+IGxldmVsO1xuICAgIHZhciB0byA9ICgocmlnaHQgLSBvZmZzZXQpID4+IGxldmVsKSArIDE7XG4gICAgaWYgKHRvID4gU0laRSkge1xuICAgICAgdG8gPSBTSVpFO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcygpO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gRE9ORSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgIHJldHVybiBET05FO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZHggPSByZXZlcnNlID8gLS10byA6IGZyb20rKztcbiAgICAgICAgdmFsdWVzID0gaXRlcmF0ZU5vZGVPckxlYWYoXG4gICAgICAgICAgYXJyYXkgJiYgYXJyYXlbaWR4XSxcbiAgICAgICAgICBsZXZlbCAtIFNISUZULFxuICAgICAgICAgIG9mZnNldCArIChpZHggPDwgbGV2ZWwpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlTGlzdChvcmlnaW4sIGNhcGFjaXR5LCBsZXZlbCwgcm9vdCwgdGFpbCwgb3duZXJJRCwgaGFzaCkge1xuICB2YXIgbGlzdCA9IE9iamVjdC5jcmVhdGUoTGlzdFByb3RvdHlwZSk7XG4gIGxpc3Quc2l6ZSA9IGNhcGFjaXR5IC0gb3JpZ2luO1xuICBsaXN0Ll9vcmlnaW4gPSBvcmlnaW47XG4gIGxpc3QuX2NhcGFjaXR5ID0gY2FwYWNpdHk7XG4gIGxpc3QuX2xldmVsID0gbGV2ZWw7XG4gIGxpc3QuX3Jvb3QgPSByb290O1xuICBsaXN0Ll90YWlsID0gdGFpbDtcbiAgbGlzdC5fX293bmVySUQgPSBvd25lcklEO1xuICBsaXN0Ll9faGFzaCA9IGhhc2g7XG4gIGxpc3QuX19hbHRlcmVkID0gZmFsc2U7XG4gIHJldHVybiBsaXN0O1xufVxuXG52YXIgRU1QVFlfTElTVDtcbmZ1bmN0aW9uIGVtcHR5TGlzdCgpIHtcbiAgcmV0dXJuIEVNUFRZX0xJU1QgfHwgKEVNUFRZX0xJU1QgPSBtYWtlTGlzdCgwLCAwLCBTSElGVCkpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0KGxpc3QsIGluZGV4LCB2YWx1ZSkge1xuICBpbmRleCA9IHdyYXBJbmRleChsaXN0LCBpbmRleCk7XG5cbiAgaWYgKGluZGV4ICE9PSBpbmRleCkge1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgaWYgKGluZGV4ID49IGxpc3Quc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICByZXR1cm4gbGlzdC53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICBpbmRleCA8IDBcbiAgICAgICAgPyBzZXRMaXN0Qm91bmRzKGxpc3QsIGluZGV4KS5zZXQoMCwgdmFsdWUpXG4gICAgICAgIDogc2V0TGlzdEJvdW5kcyhsaXN0LCAwLCBpbmRleCArIDEpLnNldChpbmRleCwgdmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgaW5kZXggKz0gbGlzdC5fb3JpZ2luO1xuXG4gIHZhciBuZXdUYWlsID0gbGlzdC5fdGFpbDtcbiAgdmFyIG5ld1Jvb3QgPSBsaXN0Ll9yb290O1xuICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKCk7XG4gIGlmIChpbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgIG5ld1RhaWwgPSB1cGRhdGVWTm9kZShuZXdUYWlsLCBsaXN0Ll9fb3duZXJJRCwgMCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV3Um9vdCA9IHVwZGF0ZVZOb2RlKFxuICAgICAgbmV3Um9vdCxcbiAgICAgIGxpc3QuX19vd25lcklELFxuICAgICAgbGlzdC5fbGV2ZWwsXG4gICAgICBpbmRleCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuICB9XG5cbiAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgbGlzdC5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgbGlzdC5fdGFpbCA9IG5ld1RhaWw7XG4gICAgbGlzdC5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgbGlzdC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG4gIHJldHVybiBtYWtlTGlzdChsaXN0Ll9vcmlnaW4sIGxpc3QuX2NhcGFjaXR5LCBsaXN0Ll9sZXZlbCwgbmV3Um9vdCwgbmV3VGFpbCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZOb2RlKG5vZGUsIG93bmVySUQsIGxldmVsLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKSB7XG4gIHZhciBpZHggPSAoaW5kZXggPj4+IGxldmVsKSAmIE1BU0s7XG4gIHZhciBub2RlSGFzID0gbm9kZSAmJiBpZHggPCBub2RlLmFycmF5Lmxlbmd0aDtcbiAgaWYgKCFub2RlSGFzICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBuZXdOb2RlO1xuXG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICB2YXIgbG93ZXJOb2RlID0gbm9kZSAmJiBub2RlLmFycmF5W2lkeF07XG4gICAgdmFyIG5ld0xvd2VyTm9kZSA9IHVwZGF0ZVZOb2RlKFxuICAgICAgbG93ZXJOb2RlLFxuICAgICAgb3duZXJJRCxcbiAgICAgIGxldmVsIC0gU0hJRlQsXG4gICAgICBpbmRleCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGlkQWx0ZXJcbiAgICApO1xuICAgIGlmIChuZXdMb3dlck5vZGUgPT09IGxvd2VyTm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG5ld05vZGUgPSBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpO1xuICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IG5ld0xvd2VyTm9kZTtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIGlmIChub2RlSGFzICYmIG5vZGUuYXJyYXlbaWR4XSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGlmIChkaWRBbHRlcikge1xuICAgIFNldFJlZihkaWRBbHRlcik7XG4gIH1cblxuICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgaWR4ID09PSBuZXdOb2RlLmFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICBuZXdOb2RlLmFycmF5LnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIG5ld05vZGUuYXJyYXlbaWR4XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBuZXdOb2RlO1xufVxuXG5mdW5jdGlvbiBlZGl0YWJsZVZOb2RlKG5vZGUsIG93bmVySUQpIHtcbiAgaWYgKG93bmVySUQgJiYgbm9kZSAmJiBvd25lcklEID09PSBub2RlLm93bmVySUQpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbmV3IFZOb2RlKG5vZGUgPyBub2RlLmFycmF5LnNsaWNlKCkgOiBbXSwgb3duZXJJRCk7XG59XG5cbmZ1bmN0aW9uIGxpc3ROb2RlRm9yKGxpc3QsIHJhd0luZGV4KSB7XG4gIGlmIChyYXdJbmRleCA+PSBnZXRUYWlsT2Zmc2V0KGxpc3QuX2NhcGFjaXR5KSkge1xuICAgIHJldHVybiBsaXN0Ll90YWlsO1xuICB9XG4gIGlmIChyYXdJbmRleCA8IDEgPDwgKGxpc3QuX2xldmVsICsgU0hJRlQpKSB7XG4gICAgdmFyIG5vZGUgPSBsaXN0Ll9yb290O1xuICAgIHZhciBsZXZlbCA9IGxpc3QuX2xldmVsO1xuICAgIHdoaWxlIChub2RlICYmIGxldmVsID4gMCkge1xuICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbKHJhd0luZGV4ID4+PiBsZXZlbCkgJiBNQVNLXTtcbiAgICAgIGxldmVsIC09IFNISUZUO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRMaXN0Qm91bmRzKGxpc3QsIGJlZ2luLCBlbmQpIHtcbiAgLy8gU2FuaXRpemUgYmVnaW4gJiBlbmQgdXNpbmcgdGhpcyBzaG9ydGhhbmQgZm9yIFRvSW50MzIoYXJndW1lbnQpXG4gIC8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2ludDMyXG4gIGlmIChiZWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYmVnaW4gfD0gMDtcbiAgfVxuICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgfD0gMDtcbiAgfVxuICB2YXIgb3duZXIgPSBsaXN0Ll9fb3duZXJJRCB8fCBuZXcgT3duZXJJRCgpO1xuICB2YXIgb2xkT3JpZ2luID0gbGlzdC5fb3JpZ2luO1xuICB2YXIgb2xkQ2FwYWNpdHkgPSBsaXN0Ll9jYXBhY2l0eTtcbiAgdmFyIG5ld09yaWdpbiA9IG9sZE9yaWdpbiArIGJlZ2luO1xuICB2YXIgbmV3Q2FwYWNpdHkgPVxuICAgIGVuZCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IG9sZENhcGFjaXR5XG4gICAgICA6IGVuZCA8IDBcbiAgICAgICAgPyBvbGRDYXBhY2l0eSArIGVuZFxuICAgICAgICA6IG9sZE9yaWdpbiArIGVuZDtcbiAgaWYgKG5ld09yaWdpbiA9PT0gb2xkT3JpZ2luICYmIG5ld0NhcGFjaXR5ID09PSBvbGRDYXBhY2l0eSkge1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgLy8gSWYgaXQncyBnb2luZyB0byBlbmQgYWZ0ZXIgaXQgc3RhcnRzLCBpdCdzIGVtcHR5LlxuICBpZiAobmV3T3JpZ2luID49IG5ld0NhcGFjaXR5KSB7XG4gICAgcmV0dXJuIGxpc3QuY2xlYXIoKTtcbiAgfVxuXG4gIHZhciBuZXdMZXZlbCA9IGxpc3QuX2xldmVsO1xuICB2YXIgbmV3Um9vdCA9IGxpc3QuX3Jvb3Q7XG5cbiAgLy8gTmV3IG9yaWdpbiBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gIHZhciBvZmZzZXRTaGlmdCA9IDA7XG4gIHdoaWxlIChuZXdPcmlnaW4gKyBvZmZzZXRTaGlmdCA8IDApIHtcbiAgICBuZXdSb290ID0gbmV3IFZOb2RlKFxuICAgICAgbmV3Um9vdCAmJiBuZXdSb290LmFycmF5Lmxlbmd0aCA/IFt1bmRlZmluZWQsIG5ld1Jvb3RdIDogW10sXG4gICAgICBvd25lclxuICAgICk7XG4gICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgb2Zmc2V0U2hpZnQgKz0gMSA8PCBuZXdMZXZlbDtcbiAgfVxuICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICBuZXdPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgb2xkT3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgIG5ld0NhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICAgIG9sZENhcGFjaXR5ICs9IG9mZnNldFNoaWZ0O1xuICB9XG5cbiAgdmFyIG9sZFRhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG9sZENhcGFjaXR5KTtcbiAgdmFyIG5ld1RhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KG5ld0NhcGFjaXR5KTtcblxuICAvLyBOZXcgc2l6ZSBtaWdodCBuZWVkIGNyZWF0aW5nIGEgaGlnaGVyIHJvb3QuXG4gIHdoaWxlIChuZXdUYWlsT2Zmc2V0ID49IDEgPDwgKG5ld0xldmVsICsgU0hJRlQpKSB7XG4gICAgbmV3Um9vdCA9IG5ldyBWTm9kZShcbiAgICAgIG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbbmV3Um9vdF0gOiBbXSxcbiAgICAgIG93bmVyXG4gICAgKTtcbiAgICBuZXdMZXZlbCArPSBTSElGVDtcbiAgfVxuXG4gIC8vIExvY2F0ZSBvciBjcmVhdGUgdGhlIG5ldyB0YWlsLlxuICB2YXIgb2xkVGFpbCA9IGxpc3QuX3RhaWw7XG4gIHZhciBuZXdUYWlsID1cbiAgICBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldFxuICAgICAgPyBsaXN0Tm9kZUZvcihsaXN0LCBuZXdDYXBhY2l0eSAtIDEpXG4gICAgICA6IG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0XG4gICAgICAgID8gbmV3IFZOb2RlKFtdLCBvd25lcilcbiAgICAgICAgOiBvbGRUYWlsO1xuXG4gIC8vIE1lcmdlIFRhaWwgaW50byB0cmVlLlxuICBpZiAoXG4gICAgb2xkVGFpbCAmJlxuICAgIG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ICYmXG4gICAgbmV3T3JpZ2luIDwgb2xkQ2FwYWNpdHkgJiZcbiAgICBvbGRUYWlsLmFycmF5Lmxlbmd0aFxuICApIHtcbiAgICBuZXdSb290ID0gZWRpdGFibGVWTm9kZShuZXdSb290LCBvd25lcik7XG4gICAgdmFyIG5vZGUgPSBuZXdSb290O1xuICAgIGZvciAodmFyIGxldmVsID0gbmV3TGV2ZWw7IGxldmVsID4gU0hJRlQ7IGxldmVsIC09IFNISUZUKSB7XG4gICAgICB2YXIgaWR4ID0gKG9sZFRhaWxPZmZzZXQgPj4+IGxldmVsKSAmIE1BU0s7XG4gICAgICBub2RlID0gbm9kZS5hcnJheVtpZHhdID0gZWRpdGFibGVWTm9kZShub2RlLmFycmF5W2lkeF0sIG93bmVyKTtcbiAgICB9XG4gICAgbm9kZS5hcnJheVsob2xkVGFpbE9mZnNldCA+Pj4gU0hJRlQpICYgTUFTS10gPSBvbGRUYWlsO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNpemUgaGFzIGJlZW4gcmVkdWNlZCwgdGhlcmUncyBhIGNoYW5jZSB0aGUgdGFpbCBuZWVkcyB0byBiZSB0cmltbWVkLlxuICBpZiAobmV3Q2FwYWNpdHkgPCBvbGRDYXBhY2l0eSkge1xuICAgIG5ld1RhaWwgPSBuZXdUYWlsICYmIG5ld1RhaWwucmVtb3ZlQWZ0ZXIob3duZXIsIDAsIG5ld0NhcGFjaXR5KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBuZXcgb3JpZ2luIGlzIHdpdGhpbiB0aGUgdGFpbCwgdGhlbiB3ZSBkbyBub3QgbmVlZCBhIHJvb3QuXG4gIGlmIChuZXdPcmlnaW4gPj0gbmV3VGFpbE9mZnNldCkge1xuICAgIG5ld09yaWdpbiAtPSBuZXdUYWlsT2Zmc2V0O1xuICAgIG5ld0NhcGFjaXR5IC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICBuZXdSb290ID0gbnVsbDtcbiAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcblxuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIHJvb3QgaGFzIGJlZW4gdHJpbW1lZCwgZ2FyYmFnZSBjb2xsZWN0LlxuICB9IGVsc2UgaWYgKG5ld09yaWdpbiA+IG9sZE9yaWdpbiB8fCBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgIG9mZnNldFNoaWZ0ID0gMDtcblxuICAgIC8vIElkZW50aWZ5IHRoZSBuZXcgdG9wIHJvb3Qgbm9kZSBvZiB0aGUgc3VidHJlZSBvZiB0aGUgb2xkIHJvb3QuXG4gICAgd2hpbGUgKG5ld1Jvb3QpIHtcbiAgICAgIHZhciBiZWdpbkluZGV4ID0gKG5ld09yaWdpbiA+Pj4gbmV3TGV2ZWwpICYgTUFTSztcbiAgICAgIGlmICgoYmVnaW5JbmRleCAhPT0gbmV3VGFpbE9mZnNldCA+Pj4gbmV3TGV2ZWwpICYgTUFTSykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgIG9mZnNldFNoaWZ0ICs9ICgxIDw8IG5ld0xldmVsKSAqIGJlZ2luSW5kZXg7XG4gICAgICB9XG4gICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgIG5ld1Jvb3QgPSBuZXdSb290LmFycmF5W2JlZ2luSW5kZXhdO1xuICAgIH1cblxuICAgIC8vIFRyaW0gdGhlIG5ldyBzaWRlcyBvZiB0aGUgbmV3IHJvb3QuXG4gICAgaWYgKG5ld1Jvb3QgJiYgbmV3T3JpZ2luID4gb2xkT3JpZ2luKSB7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVCZWZvcmUob3duZXIsIG5ld0xldmVsLCBuZXdPcmlnaW4gLSBvZmZzZXRTaGlmdCk7XG4gICAgfVxuICAgIGlmIChuZXdSb290ICYmIG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0KSB7XG4gICAgICBuZXdSb290ID0gbmV3Um9vdC5yZW1vdmVBZnRlcihcbiAgICAgICAgb3duZXIsXG4gICAgICAgIG5ld0xldmVsLFxuICAgICAgICBuZXdUYWlsT2Zmc2V0IC0gb2Zmc2V0U2hpZnRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgbmV3T3JpZ2luIC09IG9mZnNldFNoaWZ0O1xuICAgICAgbmV3Q2FwYWNpdHkgLT0gb2Zmc2V0U2hpZnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpc3QuX19vd25lcklEKSB7XG4gICAgbGlzdC5zaXplID0gbmV3Q2FwYWNpdHkgLSBuZXdPcmlnaW47XG4gICAgbGlzdC5fb3JpZ2luID0gbmV3T3JpZ2luO1xuICAgIGxpc3QuX2NhcGFjaXR5ID0gbmV3Q2FwYWNpdHk7XG4gICAgbGlzdC5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICBsaXN0Ll9yb290ID0gbmV3Um9vdDtcbiAgICBsaXN0Ll90YWlsID0gbmV3VGFpbDtcbiAgICBsaXN0Ll9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICBsaXN0Ll9fYWx0ZXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgcmV0dXJuIG1ha2VMaXN0KG5ld09yaWdpbiwgbmV3Q2FwYWNpdHksIG5ld0xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFpbE9mZnNldChzaXplKSB7XG4gIHJldHVybiBzaXplIDwgU0laRSA/IDAgOiAoKHNpemUgLSAxKSA+Pj4gU0hJRlQpIDw8IFNISUZUO1xufVxuXG52YXIgT3JkZXJlZE1hcCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcCQkMSkge1xuICBmdW5jdGlvbiBPcmRlcmVkTWFwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlPcmRlcmVkTWFwKClcbiAgICAgIDogaXNPcmRlcmVkTWFwKHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlPcmRlcmVkTWFwKCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IEtleWVkQ29sbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBhc3NlcnROb3RJbmZpbml0ZShpdGVyLnNpemUpO1xuICAgICAgICAgICAgaXRlci5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICB9KTtcbiAgfVxuXG4gIGlmICggTWFwJCQxICkgT3JkZXJlZE1hcC5fX3Byb3RvX18gPSBNYXAkJDE7XG4gIE9yZGVyZWRNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwJCQxICYmIE1hcCQkMS5wcm90b3R5cGUgKTtcbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPcmRlcmVkTWFwO1xuXG4gIE9yZGVyZWRNYXAub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgT3JkZXJlZE1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZE1hcCB7JywgJ30nKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEFjY2Vzc1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaywgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9tYXAuZ2V0KGspO1xuICAgIHJldHVybiBpbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fbGlzdC5nZXQoaW5kZXgpWzFdIDogbm90U2V0VmFsdWU7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICB0aGlzLl9saXN0LmNsZWFyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaywgdikge1xuICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIHYpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaykge1xuICAgIHJldHVybiB1cGRhdGVPcmRlcmVkTWFwKHRoaXMsIGssIE5PVF9TRVQpO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLndhc0FsdGVyZWQgPSBmdW5jdGlvbiB3YXNBbHRlcmVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKSB8fCB0aGlzLl9saXN0Lndhc0FsdGVyZWQoKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fbGlzdC5fX2l0ZXJhdGUoXG4gICAgICBmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5ICYmIGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyQxKTsgfSxcbiAgICAgIHJldmVyc2VcbiAgICApO1xuICB9O1xuXG4gIE9yZGVyZWRNYXAucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpc3QuZnJvbUVudHJ5U2VxKCkuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbiAgfTtcblxuICBPcmRlcmVkTWFwLnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICB2YXIgbmV3TGlzdCA9IHRoaXMuX2xpc3QuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5T3JkZXJlZE1hcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgdGhpcy5fbGlzdCA9IG5ld0xpc3Q7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VPcmRlcmVkTWFwKG5ld01hcCwgbmV3TGlzdCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICB9O1xuXG4gIHJldHVybiBPcmRlcmVkTWFwO1xufShNYXApKTtcblxuT3JkZXJlZE1hcC5pc09yZGVyZWRNYXAgPSBpc09yZGVyZWRNYXA7XG5cbk9yZGVyZWRNYXAucHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5PcmRlcmVkTWFwLnByb3RvdHlwZVtERUxFVEVdID0gT3JkZXJlZE1hcC5wcm90b3R5cGUucmVtb3ZlO1xuXG5mdW5jdGlvbiBtYWtlT3JkZXJlZE1hcChtYXAsIGxpc3QsIG93bmVySUQsIGhhc2gpIHtcbiAgdmFyIG9tYXAgPSBPYmplY3QuY3JlYXRlKE9yZGVyZWRNYXAucHJvdG90eXBlKTtcbiAgb21hcC5zaXplID0gbWFwID8gbWFwLnNpemUgOiAwO1xuICBvbWFwLl9tYXAgPSBtYXA7XG4gIG9tYXAuX2xpc3QgPSBsaXN0O1xuICBvbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gIG9tYXAuX19oYXNoID0gaGFzaDtcbiAgcmV0dXJuIG9tYXA7XG59XG5cbnZhciBFTVBUWV9PUkRFUkVEX01BUDtcbmZ1bmN0aW9uIGVtcHR5T3JkZXJlZE1hcCgpIHtcbiAgcmV0dXJuIChcbiAgICBFTVBUWV9PUkRFUkVEX01BUCB8fFxuICAgIChFTVBUWV9PUkRFUkVEX01BUCA9IG1ha2VPcmRlcmVkTWFwKGVtcHR5TWFwKCksIGVtcHR5TGlzdCgpKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT3JkZXJlZE1hcChvbWFwLCBrLCB2KSB7XG4gIHZhciBtYXAgPSBvbWFwLl9tYXA7XG4gIHZhciBsaXN0ID0gb21hcC5fbGlzdDtcbiAgdmFyIGkgPSBtYXAuZ2V0KGspO1xuICB2YXIgaGFzID0gaSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgbmV3TWFwO1xuICB2YXIgbmV3TGlzdDtcbiAgaWYgKHYgPT09IE5PVF9TRVQpIHtcbiAgICAvLyByZW1vdmVkXG4gICAgaWYgKCFoYXMpIHtcbiAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbiAgICBpZiAobGlzdC5zaXplID49IFNJWkUgJiYgbGlzdC5zaXplID49IG1hcC5zaXplICogMikge1xuICAgICAgbmV3TGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7IHJldHVybiBlbnRyeSAhPT0gdW5kZWZpbmVkICYmIGkgIT09IGlkeDsgfSk7XG4gICAgICBuZXdNYXAgPSBuZXdMaXN0XG4gICAgICAgIC50b0tleWVkU2VxKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5WzBdOyB9KVxuICAgICAgICAuZmxpcCgpXG4gICAgICAgIC50b01hcCgpO1xuICAgICAgaWYgKG9tYXAuX19vd25lcklEKSB7XG4gICAgICAgIG5ld01hcC5fX293bmVySUQgPSBuZXdMaXN0Ll9fb3duZXJJRCA9IG9tYXAuX19vd25lcklEO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdNYXAgPSBtYXAucmVtb3ZlKGspO1xuICAgICAgbmV3TGlzdCA9IGkgPT09IGxpc3Quc2l6ZSAtIDEgPyBsaXN0LnBvcCgpIDogbGlzdC5zZXQoaSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaGFzKSB7XG4gICAgaWYgKHYgPT09IGxpc3QuZ2V0KGkpWzFdKSB7XG4gICAgICByZXR1cm4gb21hcDtcbiAgICB9XG4gICAgbmV3TWFwID0gbWFwO1xuICAgIG5ld0xpc3QgPSBsaXN0LnNldChpLCBbaywgdl0pO1xuICB9IGVsc2Uge1xuICAgIG5ld01hcCA9IG1hcC5zZXQoaywgbGlzdC5zaXplKTtcbiAgICBuZXdMaXN0ID0gbGlzdC5zZXQobGlzdC5zaXplLCBbaywgdl0pO1xuICB9XG4gIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgIG9tYXAuc2l6ZSA9IG5ld01hcC5zaXplO1xuICAgIG9tYXAuX21hcCA9IG5ld01hcDtcbiAgICBvbWFwLl9saXN0ID0gbmV3TGlzdDtcbiAgICBvbWFwLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gb21hcDtcbiAgfVxuICByZXR1cm4gbWFrZU9yZGVyZWRNYXAobmV3TWFwLCBuZXdMaXN0KTtcbn1cblxudmFyIElTX1NUQUNLX1NZTUJPTCA9ICdAQF9fSU1NVVRBQkxFX1NUQUNLX19AQCc7XG5cbmZ1bmN0aW9uIGlzU3RhY2sobWF5YmVTdGFjaykge1xuICByZXR1cm4gQm9vbGVhbihtYXliZVN0YWNrICYmIG1heWJlU3RhY2tbSVNfU1RBQ0tfU1lNQk9MXSk7XG59XG5cbnZhciBTdGFjayA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIFN0YWNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTdGFjaygpXG4gICAgICA6IGlzU3RhY2sodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiBlbXB0eVN0YWNrKCkucHVzaEFsbCh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIEluZGV4ZWRDb2xsZWN0aW9uJCQxICkgU3RhY2suX19wcm90b19fID0gSW5kZXhlZENvbGxlY3Rpb24kJDE7XG4gIFN0YWNrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRDb2xsZWN0aW9uJCQxICYmIEluZGV4ZWRDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBTdGFjay5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdGFjaztcblxuICBTdGFjay5vZiA9IGZ1bmN0aW9uIG9mICgvKi4uLnZhbHVlcyovKSB7XG4gICAgcmV0dXJuIHRoaXMoYXJndW1lbnRzKTtcbiAgfTtcblxuICBTdGFjay5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU3RhY2sgWycsICddJyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBTdGFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIHdoaWxlIChoZWFkICYmIGluZGV4LS0pIHtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBoZWFkID8gaGVhZC52YWx1ZSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gcGVlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQgJiYgdGhpcy5faGVhZC52YWx1ZTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE1vZGlmaWNhdGlvblxuXG4gIFN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAoLyouLi52YWx1ZXMqLykge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld1NpemUgPSB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICBmb3IgKHZhciBpaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICBoZWFkID0ge1xuICAgICAgICB2YWx1ZTogYXJndW1lbnRzJDFbaWldLFxuICAgICAgICBuZXh0OiBoZWFkLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5wdXNoQWxsID0gZnVuY3Rpb24gcHVzaEFsbCAoaXRlcikge1xuICAgIGl0ZXIgPSBJbmRleGVkQ29sbGVjdGlvbiQkMShpdGVyKTtcbiAgICBpZiAoaXRlci5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCAmJiBpc1N0YWNrKGl0ZXIpKSB7XG4gICAgICByZXR1cm4gaXRlcjtcbiAgICB9XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gICAgaXRlci5fX2l0ZXJhdGUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBuZXdTaXplKys7XG4gICAgICBoZWFkID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG5leHQ6IGhlYWQsXG4gICAgICB9O1xuICAgIH0sIC8qIHJldmVyc2UgKi8gdHJ1ZSk7XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSBuZXdTaXplO1xuICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgICB0aGlzLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVN0YWNrKG5ld1NpemUsIGhlYWQpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDEpO1xuICB9O1xuXG4gIFN0YWNrLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eVN0YWNrKCk7XG4gIH07XG5cbiAgU3RhY2sucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgaWYgKHJlc29sdmVkRW5kICE9PSB0aGlzLnNpemUpIHtcbiAgICAgIC8vIHN1cGVyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICAgICAgcmV0dXJuIEluZGV4ZWRDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIH1cbiAgICB2YXIgbmV3U2l6ZSA9IHRoaXMuc2l6ZSAtIHJlc29sdmVkQmVnaW47XG4gICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xuICAgIHdoaWxlIChyZXNvbHZlZEJlZ2luLS0pIHtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5zaXplID0gbmV3U2l6ZTtcbiAgICAgIHRoaXMuX2hlYWQgPSBoZWFkO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayhuZXdTaXplLCBoZWFkKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIE11dGFiaWxpdHlcblxuICBTdGFjay5wcm90b3R5cGUuX19lbnN1cmVPd25lciA9IGZ1bmN0aW9uIF9fZW5zdXJlT3duZXIgKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5U3RhY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VTdGFjayh0aGlzLnNpemUsIHRoaXMuX2hlYWQsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIEl0ZXJhdGlvblxuXG4gIFN0YWNrLnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheVNlcSh0aGlzLnRvQXJyYXkoKSkuX19pdGVyYXRlKFxuICAgICAgICBmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gZm4odiwgaywgdGhpcyQxKTsgfSxcbiAgICAgICAgcmV2ZXJzZVxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgIHZhciBub2RlID0gdGhpcy5faGVhZDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKGZuKG5vZGUudmFsdWUsIGl0ZXJhdGlvbnMrKywgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgU3RhY2sucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEodGhpcy50b0FycmF5KCkpLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gICAgfVxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX2hlYWQ7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JWYWx1ZSh0eXBlLCBpdGVyYXRpb25zKyssIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3RhY2s7XG59KEluZGV4ZWRDb2xsZWN0aW9uKSk7XG5cblN0YWNrLmlzU3RhY2sgPSBpc1N0YWNrO1xuXG52YXIgU3RhY2tQcm90b3R5cGUgPSBTdGFjay5wcm90b3R5cGU7XG5TdGFja1Byb3RvdHlwZVtJU19TVEFDS19TWU1CT0xdID0gdHJ1ZTtcblN0YWNrUHJvdG90eXBlLnNoaWZ0ID0gU3RhY2tQcm90b3R5cGUucG9wO1xuU3RhY2tQcm90b3R5cGUudW5zaGlmdCA9IFN0YWNrUHJvdG90eXBlLnB1c2g7XG5TdGFja1Byb3RvdHlwZS51bnNoaWZ0QWxsID0gU3RhY2tQcm90b3R5cGUucHVzaEFsbDtcblN0YWNrUHJvdG90eXBlLndpdGhNdXRhdGlvbnMgPSB3aXRoTXV0YXRpb25zO1xuU3RhY2tQcm90b3R5cGUud2FzQWx0ZXJlZCA9IHdhc0FsdGVyZWQ7XG5TdGFja1Byb3RvdHlwZS5hc0ltbXV0YWJsZSA9IGFzSW1tdXRhYmxlO1xuU3RhY2tQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBTdGFja1Byb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG5TdGFja1Byb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uKHJlc3VsdCwgYXJyKSB7XG4gIHJldHVybiByZXN1bHQudW5zaGlmdChhcnIpO1xufTtcblN0YWNrUHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iai5hc0ltbXV0YWJsZSgpO1xufTtcblxuZnVuY3Rpb24gbWFrZVN0YWNrKHNpemUsIGhlYWQsIG93bmVySUQsIGhhc2gpIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUoU3RhY2tQcm90b3R5cGUpO1xuICBtYXAuc2l6ZSA9IHNpemU7XG4gIG1hcC5faGVhZCA9IGhlYWQ7XG4gIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICBtYXAuX19oYXNoID0gaGFzaDtcbiAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICByZXR1cm4gbWFwO1xufVxuXG52YXIgRU1QVFlfU1RBQ0s7XG5mdW5jdGlvbiBlbXB0eVN0YWNrKCkge1xuICByZXR1cm4gRU1QVFlfU1RBQ0sgfHwgKEVNUFRZX1NUQUNLID0gbWFrZVN0YWNrKDApKTtcbn1cblxudmFyIElTX1NFVF9TWU1CT0wgPSAnQEBfX0lNTVVUQUJMRV9TRVRfX0BAJztcblxuZnVuY3Rpb24gaXNTZXQobWF5YmVTZXQpIHtcbiAgcmV0dXJuIEJvb2xlYW4obWF5YmVTZXQgJiYgbWF5YmVTZXRbSVNfU0VUX1NZTUJPTF0pO1xufVxuXG5mdW5jdGlvbiBpc09yZGVyZWRTZXQobWF5YmVPcmRlcmVkU2V0KSB7XG4gIHJldHVybiBpc1NldChtYXliZU9yZGVyZWRTZXQpICYmIGlzT3JkZXJlZChtYXliZU9yZGVyZWRTZXQpO1xufVxuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgICFpc0NvbGxlY3Rpb24oYikgfHxcbiAgICAoYS5zaXplICE9PSB1bmRlZmluZWQgJiYgYi5zaXplICE9PSB1bmRlZmluZWQgJiYgYS5zaXplICE9PSBiLnNpemUpIHx8XG4gICAgKGEuX19oYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGIuX19oYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGEuX19oYXNoICE9PSBiLl9faGFzaCkgfHxcbiAgICBpc0tleWVkKGEpICE9PSBpc0tleWVkKGIpIHx8XG4gICAgaXNJbmRleGVkKGEpICE9PSBpc0luZGV4ZWQoYikgfHxcbiAgICBpc09yZGVyZWQoYSkgIT09IGlzT3JkZXJlZChiKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5zaXplID09PSAwICYmIGIuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG5vdEFzc29jaWF0aXZlID0gIWlzQXNzb2NpYXRpdmUoYSk7XG5cbiAgaWYgKGlzT3JkZXJlZChhKSkge1xuICAgIHZhciBlbnRyaWVzID0gYS5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGIuZXZlcnkoZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllcy5uZXh0KCkudmFsdWU7XG4gICAgICAgIHJldHVybiBlbnRyeSAmJiBpcyhlbnRyeVsxXSwgdikgJiYgKG5vdEFzc29jaWF0aXZlIHx8IGlzKGVudHJ5WzBdLCBrKSk7XG4gICAgICB9KSAmJiBlbnRyaWVzLm5leHQoKS5kb25lXG4gICAgKTtcbiAgfVxuXG4gIHZhciBmbGlwcGVkID0gZmFsc2U7XG5cbiAgaWYgKGEuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGIuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGEuY2FjaGVSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYS5jYWNoZVJlc3VsdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgIHZhciBfID0gYTtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IF87XG4gICAgfVxuICB9XG5cbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZTtcbiAgdmFyIGJTaXplID0gYi5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBpZiAoXG4gICAgICBub3RBc3NvY2lhdGl2ZVxuICAgICAgICA/ICFhLmhhcyh2KVxuICAgICAgICA6IGZsaXBwZWRcbiAgICAgICAgICA/ICFpcyh2LCBhLmdldChrLCBOT1RfU0VUKSlcbiAgICAgICAgICA6ICFpcyhhLmdldChrLCBOT1RfU0VUKSwgdilcbiAgICApIHtcbiAgICAgIGFsbEVxdWFsID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYWxsRXF1YWwgJiYgYS5zaXplID09PSBiU2l6ZTtcbn1cblxuLyoqXG4gKiBDb250cmlidXRlcyBhZGRpdGlvbmFsIG1ldGhvZHMgdG8gYSBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBtaXhpbihjdG9yLCBtZXRob2RzKSB7XG4gIHZhciBrZXlDb3BpZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgfTtcbiAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChrZXlDb3BpZXIpO1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmXG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtZXRob2RzKS5mb3JFYWNoKGtleUNvcGllcik7XG4gIHJldHVybiBjdG9yO1xufVxuXG5mdW5jdGlvbiB0b0pTKHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoIWlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICBpZiAoIWlzRGF0YVN0cnVjdHVyZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBTZXEodmFsdWUpO1xuICB9XG4gIGlmIChpc0tleWVkKHZhbHVlKSkge1xuICAgIHZhciByZXN1bHQkMSA9IHt9O1xuICAgIHZhbHVlLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgcmVzdWx0JDFba10gPSB0b0pTKHYpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQkMTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhbHVlLl9faXRlcmF0ZShmdW5jdGlvbiAodikge1xuICAgIHJlc3VsdC5wdXNoKHRvSlModikpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFNldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldENvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlTZXQoKVxuICAgICAgOiBpc1NldCh2YWx1ZSkgJiYgIWlzT3JkZXJlZCh2YWx1ZSlcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IGVtcHR5U2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IFNldENvbGxlY3Rpb24kJDEodmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0LmFkZCh2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIFNldENvbGxlY3Rpb24kJDEgKSBTZXQuX19wcm90b19fID0gU2V0Q29sbGVjdGlvbiQkMTtcbiAgU2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldENvbGxlY3Rpb24kJDEgJiYgU2V0Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNldDtcblxuICBTZXQub2YgPSBmdW5jdGlvbiBvZiAoLyouLi52YWx1ZXMqLykge1xuICAgIHJldHVybiB0aGlzKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgU2V0LmZyb21LZXlzID0gZnVuY3Rpb24gZnJvbUtleXMgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMoS2V5ZWRDb2xsZWN0aW9uKHZhbHVlKS5rZXlTZXEoKSk7XG4gIH07XG5cbiAgU2V0LmludGVyc2VjdCA9IGZ1bmN0aW9uIGludGVyc2VjdCAoc2V0cykge1xuICAgIHNldHMgPSBDb2xsZWN0aW9uKHNldHMpLnRvQXJyYXkoKTtcbiAgICByZXR1cm4gc2V0cy5sZW5ndGhcbiAgICAgID8gU2V0UHJvdG90eXBlLmludGVyc2VjdC5hcHBseShTZXQoc2V0cy5wb3AoKSksIHNldHMpXG4gICAgICA6IGVtcHR5U2V0KCk7XG4gIH07XG5cbiAgU2V0LnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKHNldHMpIHtcbiAgICBzZXRzID0gQ29sbGVjdGlvbihzZXRzKS50b0FycmF5KCk7XG4gICAgcmV0dXJuIHNldHMubGVuZ3RoXG4gICAgICA/IFNldFByb3RvdHlwZS51bmlvbi5hcHBseShTZXQoc2V0cy5wb3AoKSksIHNldHMpXG4gICAgICA6IGVtcHR5U2V0KCk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXQgeycsICd9Jyk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBBY2Nlc3NcblxuICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7XG4gIH07XG5cbiAgLy8gQHByYWdtYSBNb2RpZmljYXRpb25cblxuICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAodmFsdWUpIHtcbiAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5zZXQodmFsdWUsIHZhbHVlKSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVNldCh0aGlzLCB0aGlzLl9tYXAucmVtb3ZlKHZhbHVlKSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICByZXR1cm4gdXBkYXRlU2V0KHRoaXMsIHRoaXMuX21hcC5jbGVhcigpKTtcbiAgfTtcblxuICAvLyBAcHJhZ21hIENvbXBvc2l0aW9uXG5cbiAgU2V0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKG1hcHBlciwgY29udGV4dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlbW92ZXMgPSBbXTtcbiAgICB2YXIgYWRkcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBtYXBwZWQgPSBtYXBwZXIuY2FsbChjb250ZXh0LCB2YWx1ZSwgdmFsdWUsIHRoaXMkMSk7XG4gICAgICBpZiAobWFwcGVkICE9PSB2YWx1ZSkge1xuICAgICAgICByZW1vdmVzLnB1c2godmFsdWUpO1xuICAgICAgICBhZGRzLnB1c2gobWFwcGVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIHJlbW92ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNldC5yZW1vdmUodmFsdWUpOyB9KTtcbiAgICAgIGFkZHMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHNldC5hZGQodmFsdWUpOyB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaXRlcnMgPSBpdGVycy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2l6ZSAhPT0gMDsgfSk7XG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpemUgPT09IDAgJiYgIXRoaXMuX19vd25lcklEICYmIGl0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoaXRlcnNbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChzZXQpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVycy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgU2V0Q29sbGVjdGlvbiQkMShpdGVyc1tpaV0pLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBzZXQuYWRkKHZhbHVlKTsgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5pbnRlcnNlY3QgPSBmdW5jdGlvbiBpbnRlcnNlY3QgKCkge1xuICAgIHZhciBpdGVycyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBpdGVyc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGl0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGl0ZXJzID0gaXRlcnMubWFwKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBTZXRDb2xsZWN0aW9uJCQxKGl0ZXIpOyB9KTtcbiAgICB2YXIgdG9SZW1vdmUgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoIWl0ZXJzLmV2ZXJ5KGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCAoKSB7XG4gICAgdmFyIGl0ZXJzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGl0ZXJzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXRlcnMgPSBpdGVycy5tYXAoZnVuY3Rpb24gKGl0ZXIpIHsgcmV0dXJuIFNldENvbGxlY3Rpb24kJDEoaXRlcik7IH0pO1xuICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChpdGVycy5zb21lKGZ1bmN0aW9uIChpdGVyKSB7IHJldHVybiBpdGVyLmluY2x1ZGVzKHZhbHVlKTsgfSkpIHtcbiAgICAgICAgdG9SZW1vdmUucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGNvbXBhcmF0b3IpIHtcbiAgICAvLyBMYXRlIGJpbmRpbmdcbiAgICByZXR1cm4gT3JkZXJlZFNldChzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yKSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5zb3J0QnkgPSBmdW5jdGlvbiBzb3J0QnkgKG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIC8vIExhdGUgYmluZGluZ1xuICAgIHJldHVybiBPcmRlcmVkU2V0KHNvcnRGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcikpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX21hcC5fX2l0ZXJhdGUoZnVuY3Rpb24gKGspIHsgcmV0dXJuIGZuKGssIGssIHRoaXMkMSk7IH0sIHJldmVyc2UpO1xuICB9O1xuXG4gIFNldC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLl9faXRlcmF0b3IodHlwZSwgcmV2ZXJzZSk7XG4gIH07XG5cbiAgU2V0LnByb3RvdHlwZS5fX2Vuc3VyZU93bmVyID0gZnVuY3Rpb24gX19lbnN1cmVPd25lciAob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbXB0eSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fbWFrZShuZXdNYXAsIG93bmVySUQpO1xuICB9O1xuXG4gIHJldHVybiBTZXQ7XG59KFNldENvbGxlY3Rpb24pKTtcblxuU2V0LmlzU2V0ID0gaXNTZXQ7XG5cbnZhciBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xuU2V0UHJvdG90eXBlW0lTX1NFVF9TWU1CT0xdID0gdHJ1ZTtcblNldFByb3RvdHlwZVtERUxFVEVdID0gU2V0UHJvdG90eXBlLnJlbW92ZTtcblNldFByb3RvdHlwZS5tZXJnZSA9IFNldFByb3RvdHlwZS5jb25jYXQgPSBTZXRQcm90b3R5cGUudW5pb247XG5TZXRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG5TZXRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBhc0ltbXV0YWJsZTtcblNldFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IFNldFByb3RvdHlwZS5hc011dGFibGUgPSBhc011dGFibGU7XG5TZXRQcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbihyZXN1bHQsIGFycikge1xuICByZXR1cm4gcmVzdWx0LmFkZChhcnIpO1xufTtcblNldFByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmouYXNJbW11dGFibGUoKTtcbn07XG5cblNldFByb3RvdHlwZS5fX2VtcHR5ID0gZW1wdHlTZXQ7XG5TZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZVNldDtcblxuZnVuY3Rpb24gdXBkYXRlU2V0KHNldCwgbmV3TWFwKSB7XG4gIGlmIChzZXQuX19vd25lcklEKSB7XG4gICAgc2V0LnNpemUgPSBuZXdNYXAuc2l6ZTtcbiAgICBzZXQuX21hcCA9IG5ld01hcDtcbiAgICByZXR1cm4gc2V0O1xuICB9XG4gIHJldHVybiBuZXdNYXAgPT09IHNldC5fbWFwXG4gICAgPyBzZXRcbiAgICA6IG5ld01hcC5zaXplID09PSAwXG4gICAgICA/IHNldC5fX2VtcHR5KClcbiAgICAgIDogc2V0Ll9fbWFrZShuZXdNYXApO1xufVxuXG5mdW5jdGlvbiBtYWtlU2V0KG1hcCwgb3duZXJJRCkge1xuICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShTZXRQcm90b3R5cGUpO1xuICBzZXQuc2l6ZSA9IG1hcCA/IG1hcC5zaXplIDogMDtcbiAgc2V0Ll9tYXAgPSBtYXA7XG4gIHNldC5fX293bmVySUQgPSBvd25lcklEO1xuICByZXR1cm4gc2V0O1xufVxuXG52YXIgRU1QVFlfU0VUO1xuZnVuY3Rpb24gZW1wdHlTZXQoKSB7XG4gIHJldHVybiBFTVBUWV9TRVQgfHwgKEVNUFRZX1NFVCA9IG1ha2VTZXQoZW1wdHlNYXAoKSkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsYXp5IHNlcSBvZiBudW1zIGZyb20gc3RhcnQgKGluY2x1c2l2ZSkgdG8gZW5kXG4gKiAoZXhjbHVzaXZlKSwgYnkgc3RlcCwgd2hlcmUgc3RhcnQgZGVmYXVsdHMgdG8gMCwgc3RlcCB0byAxLCBhbmQgZW5kIHRvXG4gKiBpbmZpbml0eS4gV2hlbiBzdGFydCBpcyBlcXVhbCB0byBlbmQsIHJldHVybnMgZW1wdHkgbGlzdC5cbiAqL1xudmFyIFJhbmdlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSW5kZXhlZFNlcSQkMSkge1xuICBmdW5jdGlvbiBSYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kLCBzdGVwKTtcbiAgICB9XG4gICAgaW52YXJpYW50KHN0ZXAgIT09IDAsICdDYW5ub3Qgc3RlcCBhIFJhbmdlIGJ5IDAnKTtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IDEgOiBNYXRoLmFicyhzdGVwKTtcbiAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSAtc3RlcDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gICAgdGhpcy5zaXplID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChlbmQgLSBzdGFydCkgLyBzdGVwIC0gMSkgKyAxKTtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoRU1QVFlfUkFOR0UpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX1JBTkdFO1xuICAgICAgfVxuICAgICAgRU1QVFlfUkFOR0UgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIGlmICggSW5kZXhlZFNlcSQkMSApIFJhbmdlLl9fcHJvdG9fXyA9IEluZGV4ZWRTZXEkJDE7XG4gIFJhbmdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEluZGV4ZWRTZXEkJDEgJiYgSW5kZXhlZFNlcSQkMS5wcm90b3R5cGUgKTtcbiAgUmFuZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFuZ2U7XG5cbiAgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiAnUmFuZ2UgW10nO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgJ1JhbmdlIFsgJyArXG4gICAgICB0aGlzLl9zdGFydCArXG4gICAgICAnLi4uJyArXG4gICAgICB0aGlzLl9lbmQgK1xuICAgICAgKHRoaXMuX3N0ZXAgIT09IDEgPyAnIGJ5ICcgKyB0aGlzLl9zdGVwIDogJycpICtcbiAgICAgICcgXSdcbiAgICApO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhpbmRleClcbiAgICAgID8gdGhpcy5fc3RhcnQgKyB3cmFwSW5kZXgodGhpcywgaW5kZXgpICogdGhpcy5fc3RlcFxuICAgICAgOiBub3RTZXRWYWx1ZTtcbiAgfTtcblxuICBSYW5nZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAoc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIgcG9zc2libGVJbmRleCA9IChzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0KSAvIHRoaXMuX3N0ZXA7XG4gICAgcmV0dXJuIChcbiAgICAgIHBvc3NpYmxlSW5kZXggPj0gMCAmJlxuICAgICAgcG9zc2libGVJbmRleCA8IHRoaXMuc2l6ZSAmJlxuICAgICAgcG9zc2libGVJbmRleCA9PT0gTWF0aC5mbG9vcihwb3NzaWJsZUluZGV4KVxuICAgICk7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLnNpemUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHRoaXMuc2l6ZSk7XG4gICAgZW5kID0gcmVzb2x2ZUVuZChlbmQsIHRoaXMuc2l6ZSk7XG4gICAgaWYgKGVuZCA8PSBiZWdpbikge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZSgwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgIHRoaXMuZ2V0KGJlZ2luLCB0aGlzLl9lbmQpLFxuICAgICAgdGhpcy5nZXQoZW5kLCB0aGlzLl9lbmQpLFxuICAgICAgdGhpcy5fc3RlcFxuICAgICk7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIHZhciBvZmZzZXRWYWx1ZSA9IHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQ7XG4gICAgaWYgKG9mZnNldFZhbHVlICUgdGhpcy5fc3RlcCA9PT0gMCkge1xuICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0VmFsdWUgLyB0aGlzLl9zdGVwO1xuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLl9faXRlcmF0ZSA9IGZ1bmN0aW9uIF9faXRlcmF0ZSAoZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgKHNpemUgLSAxKSAqIHN0ZXAgOiB0aGlzLl9zdGFydDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgIT09IHNpemUpIHtcbiAgICAgIGlmIChmbih2YWx1ZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5fX2l0ZXJhdG9yID0gZnVuY3Rpb24gX19pdGVyYXRvciAodHlwZSwgcmV2ZXJzZSkge1xuICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcbiAgICB2YXIgdmFsdWUgPSByZXZlcnNlID8gdGhpcy5fc3RhcnQgKyAoc2l6ZSAtIDEpICogc3RlcCA6IHRoaXMuX3N0YXJ0O1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciB2ID0gdmFsdWU7XG4gICAgICB2YWx1ZSArPSByZXZlcnNlID8gLXN0ZXAgOiBzdGVwO1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHYpO1xuICAgIH0pO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUmFuZ2VcbiAgICAgID8gdGhpcy5fc3RhcnQgPT09IG90aGVyLl9zdGFydCAmJlxuICAgICAgICAgIHRoaXMuX2VuZCA9PT0gb3RoZXIuX2VuZCAmJlxuICAgICAgICAgIHRoaXMuX3N0ZXAgPT09IG90aGVyLl9zdGVwXG4gICAgICA6IGRlZXBFcXVhbCh0aGlzLCBvdGhlcik7XG4gIH07XG5cbiAgcmV0dXJuIFJhbmdlO1xufShJbmRleGVkU2VxKSk7XG5cbnZhciBFTVBUWV9SQU5HRTtcblxuZnVuY3Rpb24gZ2V0SW4oY29sbGVjdGlvbiwgc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpIHtcbiAgdmFyIGtleVBhdGggPSBjb2VyY2VLZXlQYXRoKHNlYXJjaEtleVBhdGgpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpICE9PSBrZXlQYXRoLmxlbmd0aCkge1xuICAgIGNvbGxlY3Rpb24gPSBnZXQoY29sbGVjdGlvbiwga2V5UGF0aFtpKytdLCBOT1RfU0VUKTtcbiAgICBpZiAoY29sbGVjdGlvbiA9PT0gTk9UX1NFVCkge1xuICAgICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0SW4kMShzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSkge1xuICByZXR1cm4gZ2V0SW4odGhpcywgc2VhcmNoS2V5UGF0aCwgbm90U2V0VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBoYXNJbihjb2xsZWN0aW9uLCBrZXlQYXRoKSB7XG4gIHJldHVybiBnZXRJbihjb2xsZWN0aW9uLCBrZXlQYXRoLCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbn1cblxuZnVuY3Rpb24gaGFzSW4kMShzZWFyY2hLZXlQYXRoKSB7XG4gIHJldHVybiBoYXNJbih0aGlzLCBzZWFyY2hLZXlQYXRoKTtcbn1cblxuZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gIHZhciBvYmplY3QgPSB7fTtcbiAgdGhpcy5fX2l0ZXJhdGUoZnVuY3Rpb24gKHYsIGspIHtcbiAgICBvYmplY3Rba10gPSB2O1xuICB9KTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLy8gTm90ZTogYWxsIG9mIHRoZXNlIG1ldGhvZHMgYXJlIGRlcHJlY2F0ZWQuXG5Db2xsZWN0aW9uLmlzSXRlcmFibGUgPSBpc0NvbGxlY3Rpb247XG5Db2xsZWN0aW9uLmlzS2V5ZWQgPSBpc0tleWVkO1xuQ29sbGVjdGlvbi5pc0luZGV4ZWQgPSBpc0luZGV4ZWQ7XG5Db2xsZWN0aW9uLmlzQXNzb2NpYXRpdmUgPSBpc0Fzc29jaWF0aXZlO1xuQ29sbGVjdGlvbi5pc09yZGVyZWQgPSBpc09yZGVyZWQ7XG5cbkNvbGxlY3Rpb24uSXRlcmF0b3IgPSBJdGVyYXRvcjtcblxubWl4aW4oQ29sbGVjdGlvbiwge1xuICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5zaXplKTtcbiAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkodGhpcy5zaXplIHx8IDApO1xuICAgIHZhciB1c2VUdXBsZXMgPSBpc0tleWVkKHRoaXMpO1xuICAgIHZhciBpID0gMDtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaykge1xuICAgICAgLy8gS2V5ZWQgY29sbGVjdGlvbnMgcHJvZHVjZSBhbiBhcnJheSBvZiB0dXBsZXMuXG4gICAgICBhcnJheVtpKytdID0gdXNlVHVwbGVzID8gW2ssIHZdIDogdjtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG5cbiAgdG9JbmRleGVkU2VxOiBmdW5jdGlvbiB0b0luZGV4ZWRTZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBUb0luZGV4ZWRTZXF1ZW5jZSh0aGlzKTtcbiAgfSxcblxuICB0b0pTOiBmdW5jdGlvbiB0b0pTJDEoKSB7XG4gICAgcmV0dXJuIHRvSlModGhpcyk7XG4gIH0sXG5cbiAgdG9LZXllZFNlcTogZnVuY3Rpb24gdG9LZXllZFNlcSgpIHtcbiAgICByZXR1cm4gbmV3IFRvS2V5ZWRTZXF1ZW5jZSh0aGlzLCB0cnVlKTtcbiAgfSxcblxuICB0b01hcDogZnVuY3Rpb24gdG9NYXAoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICB9LFxuXG4gIHRvT2JqZWN0OiB0b09iamVjdCxcblxuICB0b09yZGVyZWRNYXA6IGZ1bmN0aW9uIHRvT3JkZXJlZE1hcCgpIHtcbiAgICAvLyBVc2UgTGF0ZSBCaW5kaW5nIGhlcmUgdG8gc29sdmUgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgcmV0dXJuIE9yZGVyZWRNYXAodGhpcy50b0tleWVkU2VxKCkpO1xuICB9LFxuXG4gIHRvT3JkZXJlZFNldDogZnVuY3Rpb24gdG9PcmRlcmVkU2V0KCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gT3JkZXJlZFNldChpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgdG9TZXQ6IGZ1bmN0aW9uIHRvU2V0KCkge1xuICAgIC8vIFVzZSBMYXRlIEJpbmRpbmcgaGVyZSB0byBzb2x2ZSB0aGUgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICByZXR1cm4gU2V0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgfSxcblxuICB0b1NldFNlcTogZnVuY3Rpb24gdG9TZXRTZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBUb1NldFNlcXVlbmNlKHRoaXMpO1xuICB9LFxuXG4gIHRvU2VxOiBmdW5jdGlvbiB0b1NlcSgpIHtcbiAgICByZXR1cm4gaXNJbmRleGVkKHRoaXMpXG4gICAgICA/IHRoaXMudG9JbmRleGVkU2VxKClcbiAgICAgIDogaXNLZXllZCh0aGlzKVxuICAgICAgICA/IHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAgIDogdGhpcy50b1NldFNlcSgpO1xuICB9LFxuXG4gIHRvU3RhY2s6IGZ1bmN0aW9uIHRvU3RhY2soKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBTdGFjayhpc0tleWVkKHRoaXMpID8gdGhpcy52YWx1ZVNlcSgpIDogdGhpcyk7XG4gIH0sXG5cbiAgdG9MaXN0OiBmdW5jdGlvbiB0b0xpc3QoKSB7XG4gICAgLy8gVXNlIExhdGUgQmluZGluZyBoZXJlIHRvIHNvbHZlIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgIHJldHVybiBMaXN0KGlzS2V5ZWQodGhpcykgPyB0aGlzLnZhbHVlU2VxKCkgOiB0aGlzKTtcbiAgfSxcblxuICAvLyAjIyMgQ29tbW9uIEphdmFTY3JpcHQgbWV0aG9kcyBhbmQgcHJvcGVydGllc1xuXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tDb2xsZWN0aW9uXSc7XG4gIH0sXG5cbiAgX190b1N0cmluZzogZnVuY3Rpb24gX190b1N0cmluZyhoZWFkLCB0YWlsKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgaGVhZCArXG4gICAgICAnICcgK1xuICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgIC5tYXAodGhpcy5fX3RvU3RyaW5nTWFwcGVyKVxuICAgICAgICAuam9pbignLCAnKSArXG4gICAgICAnICcgK1xuICAgICAgdGFpbFxuICAgICk7XG4gIH0sXG5cbiAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgdmFsdWVzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gcmVpZnkodGhpcywgY29uY2F0RmFjdG9yeSh0aGlzLCB2YWx1ZXMpKTtcbiAgfSxcblxuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKTsgfSk7XG4gIH0sXG5cbiAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUyk7XG4gIH0sXG5cbiAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMuc2l6ZSk7XG4gICAgdmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgICAgaWYgKCFwcmVkaWNhdGUuY2FsbChjb250ZXh0LCB2LCBrLCBjKSkge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9LFxuXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCwgdHJ1ZSkpO1xuICB9LFxuXG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMV0gOiBub3RTZXRWYWx1ZTtcbiAgfSxcblxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKHNpZGVFZmZlY3QsIGNvbnRleHQpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0ZShjb250ZXh0ID8gc2lkZUVmZmVjdC5iaW5kKGNvbnRleHQpIDogc2lkZUVmZmVjdCk7XG4gIH0sXG5cbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLnNpemUpO1xuICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gJycgKyBzZXBhcmF0b3IgOiAnLCc7XG4gICAgdmFyIGpvaW5lZCA9ICcnO1xuICAgIHZhciBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9faXRlcmF0ZShmdW5jdGlvbiAodikge1xuICAgICAgaXNGaXJzdCA/IChpc0ZpcnN0ID0gZmFsc2UpIDogKGpvaW5lZCArPSBzZXBhcmF0b3IpO1xuICAgICAgam9pbmVkICs9IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkID8gdi50b1N0cmluZygpIDogJyc7XG4gICAgfSk7XG4gICAgcmV0dXJuIGpvaW5lZDtcbiAgfSxcblxuICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9LRVlTKTtcbiAgfSxcblxuICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgbWFwRmFjdG9yeSh0aGlzLCBtYXBwZXIsIGNvbnRleHQpKTtcbiAgfSxcblxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZSQxKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVkdWNlKFxuICAgICAgdGhpcyxcbiAgICAgIHJlZHVjZXIsXG4gICAgICBpbml0aWFsUmVkdWN0aW9uLFxuICAgICAgY29udGV4dCxcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPCAyLFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9LFxuXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChyZWR1Y2VyLCBpbml0aWFsUmVkdWN0aW9uLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlZHVjZShcbiAgICAgIHRoaXMsXG4gICAgICByZWR1Y2VyLFxuICAgICAgaW5pdGlhbFJlZHVjdGlvbixcbiAgICAgIGNvbnRleHQsXG4gICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMixcbiAgICAgIHRydWVcbiAgICApO1xuICB9LFxuXG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHJldmVyc2VGYWN0b3J5KHRoaXMsIHRydWUpKTtcbiAgfSxcblxuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBzbGljZUZhY3RvcnkodGhpcywgYmVnaW4sIGVuZCwgdHJ1ZSkpO1xuICB9LFxuXG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICF0aGlzLmV2ZXJ5KG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgfSxcblxuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc29ydEZhY3RvcnkodGhpcywgY29tcGFyYXRvcikpO1xuICB9LFxuXG4gIHZhbHVlczogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9faXRlcmF0b3IoSVRFUkFURV9WQUxVRVMpO1xuICB9LFxuXG4gIC8vICMjIyBNb3JlIHNlcXVlbnRpYWwgbWV0aG9kc1xuXG4gIGJ1dExhc3Q6IGZ1bmN0aW9uIGJ1dExhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgLTEpO1xuICB9LFxuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5zaXplID09PSAwIDogIXRoaXMuc29tZShmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgfSxcblxuICBjb3VudDogZnVuY3Rpb24gY291bnQocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGVuc3VyZVNpemUoXG4gICAgICBwcmVkaWNhdGUgPyB0aGlzLnRvU2VxKCkuZmlsdGVyKHByZWRpY2F0ZSwgY29udGV4dCkgOiB0aGlzXG4gICAgKTtcbiAgfSxcblxuICBjb3VudEJ5OiBmdW5jdGlvbiBjb3VudEJ5KGdyb3VwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY291bnRCeUZhY3RvcnkodGhpcywgZ3JvdXBlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gZGVlcEVxdWFsKHRoaXMsIG90aGVyKTtcbiAgfSxcblxuICBlbnRyeVNlcTogZnVuY3Rpb24gZW50cnlTZXEoKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgIGlmIChjb2xsZWN0aW9uLl9jYWNoZSkge1xuICAgICAgLy8gV2UgY2FjaGUgYXMgYW4gZW50cmllcyBhcnJheSwgc28gd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBjYWNoZSFcbiAgICAgIHJldHVybiBuZXcgQXJyYXlTZXEoY29sbGVjdGlvbi5fY2FjaGUpO1xuICAgIH1cbiAgICB2YXIgZW50cmllc1NlcXVlbmNlID0gY29sbGVjdGlvblxuICAgICAgLnRvU2VxKClcbiAgICAgIC5tYXAoZW50cnlNYXBwZXIpXG4gICAgICAudG9JbmRleGVkU2VxKCk7XG4gICAgZW50cmllc1NlcXVlbmNlLmZyb21FbnRyeVNlcSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbGxlY3Rpb24udG9TZXEoKTsgfTtcbiAgICByZXR1cm4gZW50cmllc1NlcXVlbmNlO1xuICB9LFxuXG4gIGZpbHRlck5vdDogZnVuY3Rpb24gZmlsdGVyTm90KHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihub3QocHJlZGljYXRlKSwgY29udGV4dCk7XG4gIH0sXG5cbiAgZmluZEVudHJ5OiBmdW5jdGlvbiBmaW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBmb3VuZCA9IG5vdFNldFZhbHVlO1xuICAgIHRoaXMuX19pdGVyYXRlKGZ1bmN0aW9uICh2LCBrLCBjKSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwoY29udGV4dCwgdiwgaywgYykpIHtcbiAgICAgICAgZm91bmQgPSBbaywgdl07XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH0sXG5cbiAgZmluZEtleTogZnVuY3Rpb24gZmluZEtleShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmZpbmRFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXTtcbiAgfSxcblxuICBmaW5kTGFzdDogZnVuY3Rpb24gZmluZExhc3QocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpbmQocHJlZGljYXRlLCBjb250ZXh0LCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgZmluZExhc3RFbnRyeTogZnVuY3Rpb24gZmluZExhc3RFbnRyeShwcmVkaWNhdGUsIGNvbnRleHQsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9LZXllZFNlcSgpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZpbmRMYXN0S2V5OiBmdW5jdGlvbiBmaW5kTGFzdEtleShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy50b0tleWVkU2VxKClcbiAgICAgIC5yZXZlcnNlKClcbiAgICAgIC5maW5kS2V5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gIH0sXG5cbiAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZChyZXR1cm5UcnVlLCBudWxsLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG5cbiAgZmxhdE1hcDogZnVuY3Rpb24gZmxhdE1hcChtYXBwZXIsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdE1hcEZhY3RvcnkodGhpcywgbWFwcGVyLCBjb250ZXh0KSk7XG4gIH0sXG5cbiAgZmxhdHRlbjogZnVuY3Rpb24gZmxhdHRlbihkZXB0aCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGF0dGVuRmFjdG9yeSh0aGlzLCBkZXB0aCwgdHJ1ZSkpO1xuICB9LFxuXG4gIGZyb21FbnRyeVNlcTogZnVuY3Rpb24gZnJvbUVudHJ5U2VxKCkge1xuICAgIHJldHVybiBuZXcgRnJvbUVudHJpZXNTZXF1ZW5jZSh0aGlzKTtcbiAgfSxcblxuICBnZXQ6IGZ1bmN0aW9uIGdldChzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZChmdW5jdGlvbiAoXywga2V5KSB7IHJldHVybiBpcyhrZXksIHNlYXJjaEtleSk7IH0sIHVuZGVmaW5lZCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGdldEluOiBnZXRJbiQxLFxuXG4gIGdyb3VwQnk6IGZ1bmN0aW9uIGdyb3VwQnkoZ3JvdXBlciwgY29udGV4dCkge1xuICAgIHJldHVybiBncm91cEJ5RmFjdG9yeSh0aGlzLCBncm91cGVyLCBjb250ZXh0KTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIGhhcyhzZWFyY2hLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VhcmNoS2V5LCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgfSxcblxuICBoYXNJbjogaGFzSW4kMSxcblxuICBpc1N1YnNldDogZnVuY3Rpb24gaXNTdWJzZXQoaXRlcikge1xuICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pbmNsdWRlcyA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBDb2xsZWN0aW9uKGl0ZXIpO1xuICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gaXRlci5pbmNsdWRlcyh2YWx1ZSk7IH0pO1xuICB9LFxuXG4gIGlzU3VwZXJzZXQ6IGZ1bmN0aW9uIGlzU3VwZXJzZXQoaXRlcikge1xuICAgIGl0ZXIgPSB0eXBlb2YgaXRlci5pc1N1YnNldCA9PT0gJ2Z1bmN0aW9uJyA/IGl0ZXIgOiBDb2xsZWN0aW9uKGl0ZXIpO1xuICAgIHJldHVybiBpdGVyLmlzU3Vic2V0KHRoaXMpO1xuICB9LFxuXG4gIGtleU9mOiBmdW5jdGlvbiBrZXlPZihzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmRLZXkoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpcyh2YWx1ZSwgc2VhcmNoVmFsdWUpOyB9KTtcbiAgfSxcblxuICBrZXlTZXE6IGZ1bmN0aW9uIGtleVNlcSgpIHtcbiAgICByZXR1cm4gdGhpcy50b1NlcSgpXG4gICAgICAubWFwKGtleU1hcHBlcilcbiAgICAgIC50b0luZGV4ZWRTZXEoKTtcbiAgfSxcblxuICBsYXN0OiBmdW5jdGlvbiBsYXN0KG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TZXEoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmZpcnN0KG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBsYXN0S2V5T2Y6IGZ1bmN0aW9uIGxhc3RLZXlPZihzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRvS2V5ZWRTZXEoKVxuICAgICAgLnJldmVyc2UoKVxuICAgICAgLmtleU9mKHNlYXJjaFZhbHVlKTtcbiAgfSxcblxuICBtYXg6IGZ1bmN0aW9uIG1heChjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIG1heEZhY3RvcnkodGhpcywgY29tcGFyYXRvcik7XG4gIH0sXG5cbiAgbWF4Qnk6IGZ1bmN0aW9uIG1heEJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KHRoaXMsIGNvbXBhcmF0b3IsIG1hcHBlcik7XG4gIH0sXG5cbiAgbWluOiBmdW5jdGlvbiBtaW4oY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KFxuICAgICAgdGhpcyxcbiAgICAgIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvclxuICAgICk7XG4gIH0sXG5cbiAgbWluQnk6IGZ1bmN0aW9uIG1pbkJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiBtYXhGYWN0b3J5KFxuICAgICAgdGhpcyxcbiAgICAgIGNvbXBhcmF0b3IgPyBuZWcoY29tcGFyYXRvcikgOiBkZWZhdWx0TmVnQ29tcGFyYXRvcixcbiAgICAgIG1hcHBlclxuICAgICk7XG4gIH0sXG5cbiAgcmVzdDogZnVuY3Rpb24gcmVzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgxKTtcbiAgfSxcblxuICBza2lwOiBmdW5jdGlvbiBza2lwKGFtb3VudCkge1xuICAgIHJldHVybiBhbW91bnQgPT09IDAgPyB0aGlzIDogdGhpcy5zbGljZShNYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgfSxcblxuICBza2lwTGFzdDogZnVuY3Rpb24gc2tpcExhc3QoYW1vdW50KSB7XG4gICAgcmV0dXJuIGFtb3VudCA9PT0gMCA/IHRoaXMgOiB0aGlzLnNsaWNlKDAsIC1NYXRoLm1heCgwLCBhbW91bnQpKTtcbiAgfSxcblxuICBza2lwV2hpbGU6IGZ1bmN0aW9uIHNraXBXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIHRydWUpKTtcbiAgfSxcblxuICBza2lwVW50aWw6IGZ1bmN0aW9uIHNraXBVbnRpbChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5za2lwV2hpbGUobm90KHByZWRpY2F0ZSksIGNvbnRleHQpO1xuICB9LFxuXG4gIHNvcnRCeTogZnVuY3Rpb24gc29ydEJ5KG1hcHBlciwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBzb3J0RmFjdG9yeSh0aGlzLCBjb21wYXJhdG9yLCBtYXBwZXIpKTtcbiAgfSxcblxuICB0YWtlOiBmdW5jdGlvbiB0YWtlKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIE1hdGgubWF4KDAsIGFtb3VudCkpO1xuICB9LFxuXG4gIHRha2VMYXN0OiBmdW5jdGlvbiB0YWtlTGFzdChhbW91bnQpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZSgtTWF0aC5tYXgoMCwgYW1vdW50KSk7XG4gIH0sXG5cbiAgdGFrZVdoaWxlOiBmdW5jdGlvbiB0YWtlV2hpbGUocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHRha2VXaGlsZUZhY3RvcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KSk7XG4gIH0sXG5cbiAgdGFrZVVudGlsOiBmdW5jdGlvbiB0YWtlVW50aWwocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudGFrZVdoaWxlKG5vdChwcmVkaWNhdGUpLCBjb250ZXh0KTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuICAgIHJldHVybiBmbih0aGlzKTtcbiAgfSxcblxuICB2YWx1ZVNlcTogZnVuY3Rpb24gdmFsdWVTZXEoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JbmRleGVkU2VxKCk7XG4gIH0sXG5cbiAgLy8gIyMjIEhhc2hhYmxlIE9iamVjdFxuXG4gIGhhc2hDb2RlOiBmdW5jdGlvbiBoYXNoQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2hhc2ggfHwgKHRoaXMuX19oYXNoID0gaGFzaENvbGxlY3Rpb24odGhpcykpO1xuICB9LFxuXG4gIC8vICMjIyBJbnRlcm5hbFxuXG4gIC8vIGFic3RyYWN0IF9faXRlcmF0ZShmbiwgcmV2ZXJzZSlcblxuICAvLyBhYnN0cmFjdCBfX2l0ZXJhdG9yKHR5cGUsIHJldmVyc2UpXG59KTtcblxudmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbkNvbGxlY3Rpb25Qcm90b3R5cGVbSVNfQ09MTEVDVElPTl9TWU1CT0xdID0gdHJ1ZTtcbkNvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUudmFsdWVzO1xuQ29sbGVjdGlvblByb3RvdHlwZS50b0pTT04gPSBDb2xsZWN0aW9uUHJvdG90eXBlLnRvQXJyYXk7XG5Db2xsZWN0aW9uUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBxdW90ZVN0cmluZztcbkNvbGxlY3Rpb25Qcm90b3R5cGUuaW5zcGVjdCA9IENvbGxlY3Rpb25Qcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5Db2xsZWN0aW9uUHJvdG90eXBlLmNoYWluID0gQ29sbGVjdGlvblByb3RvdHlwZS5mbGF0TWFwO1xuQ29sbGVjdGlvblByb3RvdHlwZS5jb250YWlucyA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaW5jbHVkZXM7XG5cbm1peGluKEtleWVkQ29sbGVjdGlvbiwge1xuICAvLyAjIyMgTW9yZSBzZXF1ZW50aWFsIG1ldGhvZHNcblxuICBmbGlwOiBmdW5jdGlvbiBmbGlwKCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCBmbGlwRmFjdG9yeSh0aGlzKSk7XG4gIH0sXG5cbiAgbWFwRW50cmllczogZnVuY3Rpb24gbWFwRW50cmllcyhtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICByZXR1cm4gcmVpZnkoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIG1hcHBlci5jYWxsKGNvbnRleHQsIFtrLCB2XSwgaXRlcmF0aW9ucysrLCB0aGlzJDEpOyB9KVxuICAgICAgICAuZnJvbUVudHJ5U2VxKClcbiAgICApO1xuICB9LFxuXG4gIG1hcEtleXM6IGZ1bmN0aW9uIG1hcEtleXMobWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICByZXR1cm4gcmVpZnkoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy50b1NlcSgpXG4gICAgICAgIC5mbGlwKClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoaywgdikgeyByZXR1cm4gbWFwcGVyLmNhbGwoY29udGV4dCwgaywgdiwgdGhpcyQxKTsgfSlcbiAgICAgICAgLmZsaXAoKVxuICAgICk7XG4gIH0sXG59KTtcblxudmFyIEtleWVkQ29sbGVjdGlvblByb3RvdHlwZSA9IEtleWVkQ29sbGVjdGlvbi5wcm90b3R5cGU7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfS0VZRURfU1lNQk9MXSA9IHRydWU7XG5LZXllZENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IENvbGxlY3Rpb25Qcm90b3R5cGUuZW50cmllcztcbktleWVkQ29sbGVjdGlvblByb3RvdHlwZS50b0pTT04gPSB0b09iamVjdDtcbktleWVkQ29sbGVjdGlvblByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gZnVuY3Rpb24gKHYsIGspIHsgcmV0dXJuIHF1b3RlU3RyaW5nKGspICsgJzogJyArIHF1b3RlU3RyaW5nKHYpOyB9O1xuXG5taXhpbihJbmRleGVkQ29sbGVjdGlvbiwge1xuICAvLyAjIyMgQ29udmVyc2lvbiB0byBvdGhlciB0eXBlc1xuXG4gIHRvS2V5ZWRTZXE6IGZ1bmN0aW9uIHRvS2V5ZWRTZXEoKSB7XG4gICAgcmV0dXJuIG5ldyBUb0tleWVkU2VxdWVuY2UodGhpcywgZmFsc2UpO1xuICB9LFxuXG4gIC8vICMjIyBFUzYgQ29sbGVjdGlvbiBtZXRob2RzIChFUzYgQXJyYXkgYW5kIE1hcClcblxuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gIH0sXG5cbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kRW50cnkocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZW50cnkgPyBlbnRyeVswXSA6IC0xO1xuICB9LFxuXG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXlPZihzZWFyY2hWYWx1ZSk7XG4gICAgcmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID8gLTEgOiBrZXk7XG4gIH0sXG5cbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaFZhbHVlKSB7XG4gICAgdmFyIGtleSA9IHRoaXMubGFzdEtleU9mKHNlYXJjaFZhbHVlKTtcbiAgICByZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgPyAtMSA6IGtleTtcbiAgfSxcblxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIHJldHVybiByZWlmeSh0aGlzLCByZXZlcnNlRmFjdG9yeSh0aGlzLCBmYWxzZSkpO1xuICB9LFxuXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShiZWdpbiwgZW5kKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIHNsaWNlRmFjdG9yeSh0aGlzLCBiZWdpbiwgZW5kLCBmYWxzZSkpO1xuICB9LFxuXG4gIHNwbGljZTogZnVuY3Rpb24gc3BsaWNlKGluZGV4LCByZW1vdmVOdW0gLyosIC4uLnZhbHVlcyovKSB7XG4gICAgdmFyIG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJlbW92ZU51bSA9IE1hdGgubWF4KHJlbW92ZU51bSB8fCAwLCAwKTtcbiAgICBpZiAobnVtQXJncyA9PT0gMCB8fCAobnVtQXJncyA9PT0gMiAmJiAhcmVtb3ZlTnVtKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIElmIGluZGV4IGlzIG5lZ2F0aXZlLCBpdCBzaG91bGQgcmVzb2x2ZSByZWxhdGl2ZSB0byB0aGUgc2l6ZSBvZiB0aGVcbiAgICAvLyBjb2xsZWN0aW9uLiBIb3dldmVyIHNpemUgbWF5IGJlIGV4cGVuc2l2ZSB0byBjb21wdXRlIGlmIG5vdCBjYWNoZWQsIHNvXG4gICAgLy8gb25seSBjYWxsIGNvdW50KCkgaWYgdGhlIG51bWJlciBpcyBpbiBmYWN0IG5lZ2F0aXZlLlxuICAgIGluZGV4ID0gcmVzb2x2ZUJlZ2luKGluZGV4LCBpbmRleCA8IDAgPyB0aGlzLmNvdW50KCkgOiB0aGlzLnNpemUpO1xuICAgIHZhciBzcGxpY2VkID0gdGhpcy5zbGljZSgwLCBpbmRleCk7XG4gICAgcmV0dXJuIHJlaWZ5KFxuICAgICAgdGhpcyxcbiAgICAgIG51bUFyZ3MgPT09IDFcbiAgICAgICAgPyBzcGxpY2VkXG4gICAgICAgIDogc3BsaWNlZC5jb25jYXQoYXJyQ29weShhcmd1bWVudHMsIDIpLCB0aGlzLnNsaWNlKGluZGV4ICsgcmVtb3ZlTnVtKSlcbiAgICApO1xuICB9LFxuXG4gIC8vICMjIyBNb3JlIGNvbGxlY3Rpb24gbWV0aG9kc1xuXG4gIGZpbmRMYXN0SW5kZXg6IGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5maW5kTGFzdEVudHJ5KHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnlbMF0gOiAtMTtcbiAgfSxcblxuICBmaXJzdDogZnVuY3Rpb24gZmlyc3Qobm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoMCwgbm90U2V0VmFsdWUpO1xuICB9LFxuXG4gIGZsYXR0ZW46IGZ1bmN0aW9uIGZsYXR0ZW4oZGVwdGgpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgZmxhdHRlbkZhY3RvcnkodGhpcywgZGVwdGgsIGZhbHNlKSk7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiBnZXQoaW5kZXgsIG5vdFNldFZhbHVlKSB7XG4gICAgaW5kZXggPSB3cmFwSW5kZXgodGhpcywgaW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA8IDAgfHxcbiAgICAgICh0aGlzLnNpemUgPT09IEluZmluaXR5IHx8ICh0aGlzLnNpemUgIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+IHRoaXMuc2l6ZSkpXG4gICAgICA/IG5vdFNldFZhbHVlXG4gICAgICA6IHRoaXMuZmluZChmdW5jdGlvbiAoXywga2V5KSB7IHJldHVybiBrZXkgPT09IGluZGV4OyB9LCB1bmRlZmluZWQsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIGhhcyhpbmRleCkge1xuICAgIGluZGV4ID0gd3JhcEluZGV4KHRoaXMsIGluZGV4KTtcbiAgICByZXR1cm4gKFxuICAgICAgaW5kZXggPj0gMCAmJlxuICAgICAgKHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gdGhpcy5zaXplID09PSBJbmZpbml0eSB8fCBpbmRleCA8IHRoaXMuc2l6ZVxuICAgICAgICA6IHRoaXMuaW5kZXhPZihpbmRleCkgIT09IC0xKVxuICAgICk7XG4gIH0sXG5cbiAgaW50ZXJwb3NlOiBmdW5jdGlvbiBpbnRlcnBvc2Uoc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIHJlaWZ5KHRoaXMsIGludGVycG9zZUZhY3RvcnkodGhpcywgc2VwYXJhdG9yKSk7XG4gIH0sXG5cbiAgaW50ZXJsZWF2ZTogZnVuY3Rpb24gaW50ZXJsZWF2ZSgvKi4uLmNvbGxlY3Rpb25zKi8pIHtcbiAgICB2YXIgY29sbGVjdGlvbnMgPSBbdGhpc10uY29uY2F0KGFyckNvcHkoYXJndW1lbnRzKSk7XG4gICAgdmFyIHppcHBlZCA9IHppcFdpdGhGYWN0b3J5KHRoaXMudG9TZXEoKSwgSW5kZXhlZFNlcS5vZiwgY29sbGVjdGlvbnMpO1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHppcHBlZC5mbGF0dGVuKHRydWUpO1xuICAgIGlmICh6aXBwZWQuc2l6ZSkge1xuICAgICAgaW50ZXJsZWF2ZWQuc2l6ZSA9IHppcHBlZC5zaXplICogY29sbGVjdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVpZnkodGhpcywgaW50ZXJsZWF2ZWQpO1xuICB9LFxuXG4gIGtleVNlcTogZnVuY3Rpb24ga2V5U2VxKCkge1xuICAgIHJldHVybiBSYW5nZSgwLCB0aGlzLnNpemUpO1xuICB9LFxuXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3Qobm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoLTEsIG5vdFNldFZhbHVlKTtcbiAgfSxcblxuICBza2lwV2hpbGU6IGZ1bmN0aW9uIHNraXBXaGlsZShwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgc2tpcFdoaWxlRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQsIGZhbHNlKSk7XG4gIH0sXG5cbiAgemlwOiBmdW5jdGlvbiB6aXAoLyosIC4uLmNvbGxlY3Rpb25zICovKSB7XG4gICAgdmFyIGNvbGxlY3Rpb25zID0gW3RoaXNdLmNvbmNhdChhcnJDb3B5KGFyZ3VtZW50cykpO1xuICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCBkZWZhdWx0WmlwcGVyLCBjb2xsZWN0aW9ucykpO1xuICB9LFxuXG4gIHppcEFsbDogZnVuY3Rpb24gemlwQWxsKC8qLCAuLi5jb2xsZWN0aW9ucyAqLykge1xuICAgIHZhciBjb2xsZWN0aW9ucyA9IFt0aGlzXS5jb25jYXQoYXJyQ29weShhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gcmVpZnkodGhpcywgemlwV2l0aEZhY3RvcnkodGhpcywgZGVmYXVsdFppcHBlciwgY29sbGVjdGlvbnMsIHRydWUpKTtcbiAgfSxcblxuICB6aXBXaXRoOiBmdW5jdGlvbiB6aXBXaXRoKHppcHBlciAvKiwgLi4uY29sbGVjdGlvbnMgKi8pIHtcbiAgICB2YXIgY29sbGVjdGlvbnMgPSBhcnJDb3B5KGFyZ3VtZW50cyk7XG4gICAgY29sbGVjdGlvbnNbMF0gPSB0aGlzO1xuICAgIHJldHVybiByZWlmeSh0aGlzLCB6aXBXaXRoRmFjdG9yeSh0aGlzLCB6aXBwZXIsIGNvbGxlY3Rpb25zKSk7XG4gIH0sXG59KTtcblxudmFyIEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlID0gSW5kZXhlZENvbGxlY3Rpb24ucHJvdG90eXBlO1xuSW5kZXhlZENvbGxlY3Rpb25Qcm90b3R5cGVbSVNfSU5ERVhFRF9TWU1CT0xdID0gdHJ1ZTtcbkluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5cbm1peGluKFNldENvbGxlY3Rpb24sIHtcbiAgLy8gIyMjIEVTNiBDb2xsZWN0aW9uIG1ldGhvZHMgKEVTNiBBcnJheSBhbmQgTWFwKVxuXG4gIGdldDogZnVuY3Rpb24gZ2V0KHZhbHVlLCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSkgPyB2YWx1ZSA6IG5vdFNldFZhbHVlO1xuICB9LFxuXG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyh2YWx1ZSk7XG4gIH0sXG5cbiAgLy8gIyMjIE1vcmUgc2VxdWVudGlhbCBtZXRob2RzXG5cbiAga2V5U2VxOiBmdW5jdGlvbiBrZXlTZXEoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVTZXEoKTtcbiAgfSxcbn0pO1xuXG5TZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5oYXMgPSBDb2xsZWN0aW9uUHJvdG90eXBlLmluY2x1ZGVzO1xuU2V0Q29sbGVjdGlvbi5wcm90b3R5cGUuY29udGFpbnMgPSBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZS5pbmNsdWRlcztcblxuLy8gTWl4aW4gc3ViY2xhc3Nlc1xuXG5taXhpbihLZXllZFNlcSwgS2V5ZWRDb2xsZWN0aW9uLnByb3RvdHlwZSk7XG5taXhpbihJbmRleGVkU2VxLCBJbmRleGVkQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xubWl4aW4oU2V0U2VxLCBTZXRDb2xsZWN0aW9uLnByb3RvdHlwZSk7XG5cbi8vICNwcmFnbWEgSGVscGVyIGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgcmVkdWNlciwgcmVkdWN0aW9uLCBjb250ZXh0LCB1c2VGaXJzdCwgcmV2ZXJzZSkge1xuICBhc3NlcnROb3RJbmZpbml0ZShjb2xsZWN0aW9uLnNpemUpO1xuICBjb2xsZWN0aW9uLl9faXRlcmF0ZShmdW5jdGlvbiAodiwgaywgYykge1xuICAgIGlmICh1c2VGaXJzdCkge1xuICAgICAgdXNlRmlyc3QgPSBmYWxzZTtcbiAgICAgIHJlZHVjdGlvbiA9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHVjdGlvbiA9IHJlZHVjZXIuY2FsbChjb250ZXh0LCByZWR1Y3Rpb24sIHYsIGssIGMpO1xuICAgIH1cbiAgfSwgcmV2ZXJzZSk7XG4gIHJldHVybiByZWR1Y3Rpb247XG59XG5cbmZ1bmN0aW9uIGtleU1hcHBlcih2LCBrKSB7XG4gIHJldHVybiBrO1xufVxuXG5mdW5jdGlvbiBlbnRyeU1hcHBlcih2LCBrKSB7XG4gIHJldHVybiBbaywgdl07XG59XG5cbmZ1bmN0aW9uIG5vdChwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5lZyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAtcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRaaXBwZXIoKSB7XG4gIHJldHVybiBhcnJDb3B5KGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHROZWdDb21wYXJhdG9yKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gMSA6IGEgPiBiID8gLTEgOiAwO1xufVxuXG5mdW5jdGlvbiBoYXNoQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gIGlmIChjb2xsZWN0aW9uLnNpemUgPT09IEluZmluaXR5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIG9yZGVyZWQgPSBpc09yZGVyZWQoY29sbGVjdGlvbik7XG4gIHZhciBrZXllZCA9IGlzS2V5ZWQoY29sbGVjdGlvbik7XG4gIHZhciBoID0gb3JkZXJlZCA/IDEgOiAwO1xuICB2YXIgc2l6ZSA9IGNvbGxlY3Rpb24uX19pdGVyYXRlKFxuICAgIGtleWVkXG4gICAgICA/IG9yZGVyZWRcbiAgICAgICAgPyBmdW5jdGlvbiAodiwgaykge1xuICAgICAgICAgICAgaCA9ICgzMSAqIGggKyBoYXNoTWVyZ2UoaGFzaCh2KSwgaGFzaChrKSkpIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgIGggPSAoaCArIGhhc2hNZXJnZShoYXNoKHYpLCBoYXNoKGspKSkgfCAwO1xuICAgICAgICAgIH1cbiAgICAgIDogb3JkZXJlZFxuICAgICAgICA/IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBoID0gKDMxICogaCArIGhhc2godikpIHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgIDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGggPSAoaCArIGhhc2godikpIHwgMDtcbiAgICAgICAgICB9XG4gICk7XG4gIHJldHVybiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpO1xufVxuXG5mdW5jdGlvbiBtdXJtdXJIYXNoT2ZTaXplKHNpemUsIGgpIHtcbiAgaCA9IGltdWwoaCwgMHhjYzllMmQ1MSk7XG4gIGggPSBpbXVsKChoIDw8IDE1KSB8IChoID4+PiAtMTUpLCAweDFiODczNTkzKTtcbiAgaCA9IGltdWwoKGggPDwgMTMpIHwgKGggPj4+IC0xMyksIDUpO1xuICBoID0gKChoICsgMHhlNjU0NmI2NCkgfCAwKSBeIHNpemU7XG4gIGggPSBpbXVsKGggXiAoaCA+Pj4gMTYpLCAweDg1ZWJjYTZiKTtcbiAgaCA9IGltdWwoaCBeIChoID4+PiAxMyksIDB4YzJiMmFlMzUpO1xuICBoID0gc21pKGggXiAoaCA+Pj4gMTYpKTtcbiAgcmV0dXJuIGg7XG59XG5cbmZ1bmN0aW9uIGhhc2hNZXJnZShhLCBiKSB7XG4gIHJldHVybiAoYSBeIChiICsgMHg5ZTM3NzliOSArIChhIDw8IDYpICsgKGEgPj4gMikpKSB8IDA7IC8vIGludFxufVxuXG52YXIgT3JkZXJlZFNldCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFNldCQkMSkge1xuICBmdW5jdGlvbiBPcmRlcmVkU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gZW1wdHlPcmRlcmVkU2V0KClcbiAgICAgIDogaXNPcmRlcmVkU2V0KHZhbHVlKVxuICAgICAgICA/IHZhbHVlXG4gICAgICAgIDogZW1wdHlPcmRlcmVkU2V0KCkud2l0aE11dGF0aW9ucyhmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICB2YXIgaXRlciA9IFNldENvbGxlY3Rpb24odmFsdWUpO1xuICAgICAgICAgICAgYXNzZXJ0Tm90SW5maW5pdGUoaXRlci5zaXplKTtcbiAgICAgICAgICAgIGl0ZXIuZm9yRWFjaChmdW5jdGlvbiAodikgeyByZXR1cm4gc2V0LmFkZCh2KTsgfSk7XG4gICAgICAgICAgfSk7XG4gIH1cblxuICBpZiAoIFNldCQkMSApIE9yZGVyZWRTZXQuX19wcm90b19fID0gU2V0JCQxO1xuICBPcmRlcmVkU2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldCQkMSAmJiBTZXQkJDEucHJvdG90eXBlICk7XG4gIE9yZGVyZWRTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JkZXJlZFNldDtcblxuICBPcmRlcmVkU2V0Lm9mID0gZnVuY3Rpb24gb2YgKC8qLi4udmFsdWVzKi8pIHtcbiAgICByZXR1cm4gdGhpcyhhcmd1bWVudHMpO1xuICB9O1xuXG4gIE9yZGVyZWRTZXQuZnJvbUtleXMgPSBmdW5jdGlvbiBmcm9tS2V5cyAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcyhLZXllZENvbGxlY3Rpb24odmFsdWUpLmtleVNlcSgpKTtcbiAgfTtcblxuICBPcmRlcmVkU2V0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdPcmRlcmVkU2V0IHsnLCAnfScpO1xuICB9O1xuXG4gIHJldHVybiBPcmRlcmVkU2V0O1xufShTZXQpKTtcblxuT3JkZXJlZFNldC5pc09yZGVyZWRTZXQgPSBpc09yZGVyZWRTZXQ7XG5cbnZhciBPcmRlcmVkU2V0UHJvdG90eXBlID0gT3JkZXJlZFNldC5wcm90b3R5cGU7XG5PcmRlcmVkU2V0UHJvdG90eXBlW0lTX09SREVSRURfU1lNQk9MXSA9IHRydWU7XG5PcmRlcmVkU2V0UHJvdG90eXBlLnppcCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcDtcbk9yZGVyZWRTZXRQcm90b3R5cGUuemlwV2l0aCA9IEluZGV4ZWRDb2xsZWN0aW9uUHJvdG90eXBlLnppcFdpdGg7XG5cbk9yZGVyZWRTZXRQcm90b3R5cGUuX19lbXB0eSA9IGVtcHR5T3JkZXJlZFNldDtcbk9yZGVyZWRTZXRQcm90b3R5cGUuX19tYWtlID0gbWFrZU9yZGVyZWRTZXQ7XG5cbmZ1bmN0aW9uIG1ha2VPcmRlcmVkU2V0KG1hcCwgb3duZXJJRCkge1xuICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkU2V0UHJvdG90eXBlKTtcbiAgc2V0LnNpemUgPSBtYXAgPyBtYXAuc2l6ZSA6IDA7XG4gIHNldC5fbWFwID0gbWFwO1xuICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHNldDtcbn1cblxudmFyIEVNUFRZX09SREVSRURfU0VUO1xuZnVuY3Rpb24gZW1wdHlPcmRlcmVkU2V0KCkge1xuICByZXR1cm4gKFxuICAgIEVNUFRZX09SREVSRURfU0VUIHx8IChFTVBUWV9PUkRFUkVEX1NFVCA9IG1ha2VPcmRlcmVkU2V0KGVtcHR5T3JkZXJlZE1hcCgpKSlcbiAgKTtcbn1cblxudmFyIFJlY29yZCA9IGZ1bmN0aW9uIFJlY29yZChkZWZhdWx0VmFsdWVzLCBuYW1lKSB7XG4gIHZhciBoYXNJbml0aWFsaXplZDtcblxuICB2YXIgUmVjb3JkVHlwZSA9IGZ1bmN0aW9uIFJlY29yZCh2YWx1ZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBSZWNvcmRUeXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoIWhhc0luaXRpYWxpemVkKSB7XG4gICAgICBoYXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRWYWx1ZXMpO1xuICAgICAgdmFyIGluZGljZXMgPSAoUmVjb3JkVHlwZVByb3RvdHlwZS5faW5kaWNlcyA9IHt9KTtcbiAgICAgIC8vIERlcHJlY2F0ZWQ6IGxlZnQgdG8gYXR0ZW1wdCBub3QgdG8gYnJlYWsgYW55IGV4dGVybmFsIGNvZGUgd2hpY2hcbiAgICAgIC8vIHJlbGllcyBvbiBhIC5fbmFtZSBwcm9wZXJ0eSBleGlzdGluZyBvbiByZWNvcmQgaW5zdGFuY2VzLlxuICAgICAgLy8gVXNlIFJlY29yZC5nZXREZXNjcmlwdGl2ZU5hbWUoKSBpbnN0ZWFkXG4gICAgICBSZWNvcmRUeXBlUHJvdG90eXBlLl9uYW1lID0gbmFtZTtcbiAgICAgIFJlY29yZFR5cGVQcm90b3R5cGUuX2tleXMgPSBrZXlzO1xuICAgICAgUmVjb3JkVHlwZVByb3RvdHlwZS5fZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRWYWx1ZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0ga2V5c1tpXTtcbiAgICAgICAgaW5kaWNlc1twcm9wTmFtZV0gPSBpO1xuICAgICAgICBpZiAoUmVjb3JkVHlwZVByb3RvdHlwZVtwcm9wTmFtZV0pIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgdHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm4gJiZcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ0Nhbm5vdCBkZWZpbmUgJyArXG4gICAgICAgICAgICAgICAgcmVjb3JkTmFtZSh0aGlzKSArXG4gICAgICAgICAgICAgICAgJyB3aXRoIHByb3BlcnR5IFwiJyArXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgICdcIiBzaW5jZSB0aGF0IHByb3BlcnR5IG5hbWUgaXMgcGFydCBvZiB0aGUgUmVjb3JkIEFQSS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFByb3AoUmVjb3JkVHlwZVByb3RvdHlwZSwgcHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX19vd25lcklEID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlcyA9IExpc3QoKS53aXRoTXV0YXRpb25zKGZ1bmN0aW9uIChsKSB7XG4gICAgICBsLnNldFNpemUodGhpcyQxLl9rZXlzLmxlbmd0aCk7XG4gICAgICBLZXllZENvbGxlY3Rpb24odmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIGwuc2V0KHRoaXMkMS5faW5kaWNlc1trXSwgdiA9PT0gdGhpcyQxLl9kZWZhdWx0VmFsdWVzW2tdID8gdW5kZWZpbmVkIDogdik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgUmVjb3JkVHlwZVByb3RvdHlwZSA9IChSZWNvcmRUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoXG4gICAgUmVjb3JkUHJvdG90eXBlXG4gICkpO1xuICBSZWNvcmRUeXBlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjb3JkVHlwZTtcblxuICBpZiAobmFtZSkge1xuICAgIFJlY29yZFR5cGUuZGlzcGxheU5hbWUgPSBuYW1lO1xuICB9XG5cbiAgcmV0dXJuIFJlY29yZFR5cGU7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgc3RyID0gcmVjb3JkTmFtZSh0aGlzKSArICcgeyAnO1xuICB2YXIga2V5cyA9IHRoaXMuX2tleXM7XG4gIHZhciBrO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpICE9PSBsOyBpKyspIHtcbiAgICBrID0ga2V5c1tpXTtcbiAgICBzdHIgKz0gKGkgPyAnLCAnIDogJycpICsgayArICc6ICcgKyBxdW90ZVN0cmluZyh0aGlzLmdldChrKSk7XG4gIH1cbiAgcmV0dXJuIHN0ciArICcgfSc7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgcmV0dXJuIChcbiAgICB0aGlzID09PSBvdGhlciB8fFxuICAgIChvdGhlciAmJlxuICAgICAgdGhpcy5fa2V5cyA9PT0gb3RoZXIuX2tleXMgJiZcbiAgICAgIHJlY29yZFNlcSh0aGlzKS5lcXVhbHMocmVjb3JkU2VxKG90aGVyKSkpXG4gICk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLmhhc2hDb2RlKCk7XG59O1xuXG4vLyBAcHJhZ21hIEFjY2Vzc1xuXG5SZWNvcmQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoaykge1xuICByZXR1cm4gdGhpcy5faW5kaWNlcy5oYXNPd25Qcm9wZXJ0eShrKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrLCBub3RTZXRWYWx1ZSkge1xuICBpZiAoIXRoaXMuaGFzKGspKSB7XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9XG4gIHZhciBpbmRleCA9IHRoaXMuX2luZGljZXNba107XG4gIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlcy5nZXQoaW5kZXgpO1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gOiB2YWx1ZTtcbn07XG5cbi8vIEBwcmFnbWEgTW9kaWZpY2F0aW9uXG5cblJlY29yZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChrLCB2KSB7XG4gIGlmICh0aGlzLmhhcyhrKSkge1xuICAgIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuc2V0KFxuICAgICAgdGhpcy5faW5kaWNlc1trXSxcbiAgICAgIHYgPT09IHRoaXMuX2RlZmF1bHRWYWx1ZXNba10gPyB1bmRlZmluZWQgOiB2XG4gICAgKTtcbiAgICBpZiAobmV3VmFsdWVzICE9PSB0aGlzLl92YWx1ZXMgJiYgIXRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlY29yZC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChrKSB7XG4gIHJldHVybiB0aGlzLnNldChrKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuY2xlYXIoKS5zZXRTaXplKHRoaXMuX2tleXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IG1ha2VSZWNvcmQodGhpcywgbmV3VmFsdWVzKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUud2FzQWx0ZXJlZCA9IGZ1bmN0aW9uIHdhc0FsdGVyZWQgKCkge1xuICByZXR1cm4gdGhpcy5fdmFsdWVzLndhc0FsdGVyZWQoKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUudG9TZXEgPSBmdW5jdGlvbiB0b1NlcSAoKSB7XG4gIHJldHVybiByZWNvcmRTZXEodGhpcyk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLnRvSlMgPSBmdW5jdGlvbiB0b0pTJDEgKCkge1xuICByZXR1cm4gdG9KUyh0aGlzKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMgKCkge1xuICByZXR1cm4gdGhpcy5fX2l0ZXJhdG9yKElURVJBVEVfRU5UUklFUyk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLl9faXRlcmF0b3IgPSBmdW5jdGlvbiBfX2l0ZXJhdG9yICh0eXBlLCByZXZlcnNlKSB7XG4gIHJldHVybiByZWNvcmRTZXEodGhpcykuX19pdGVyYXRvcih0eXBlLCByZXZlcnNlKTtcbn07XG5cblJlY29yZC5wcm90b3R5cGUuX19pdGVyYXRlID0gZnVuY3Rpb24gX19pdGVyYXRlIChmbiwgcmV2ZXJzZSkge1xuICByZXR1cm4gcmVjb3JkU2VxKHRoaXMpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSk7XG59O1xuXG5SZWNvcmQucHJvdG90eXBlLl9fZW5zdXJlT3duZXIgPSBmdW5jdGlvbiBfX2Vuc3VyZU93bmVyIChvd25lcklEKSB7XG4gIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBuZXdWYWx1ZXMgPSB0aGlzLl92YWx1ZXMuX19lbnN1cmVPd25lcihvd25lcklEKTtcbiAgaWYgKCFvd25lcklEKSB7XG4gICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgIHRoaXMuX3ZhbHVlcyA9IG5ld1ZhbHVlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gbWFrZVJlY29yZCh0aGlzLCBuZXdWYWx1ZXMsIG93bmVySUQpO1xufTtcblxuUmVjb3JkLmlzUmVjb3JkID0gaXNSZWNvcmQ7XG5SZWNvcmQuZ2V0RGVzY3JpcHRpdmVOYW1lID0gcmVjb3JkTmFtZTtcbnZhciBSZWNvcmRQcm90b3R5cGUgPSBSZWNvcmQucHJvdG90eXBlO1xuUmVjb3JkUHJvdG90eXBlW0lTX1JFQ09SRF9TWU1CT0xdID0gdHJ1ZTtcblJlY29yZFByb3RvdHlwZVtERUxFVEVdID0gUmVjb3JkUHJvdG90eXBlLnJlbW92ZTtcblJlY29yZFByb3RvdHlwZS5kZWxldGVJbiA9IFJlY29yZFByb3RvdHlwZS5yZW1vdmVJbiA9IGRlbGV0ZUluO1xuUmVjb3JkUHJvdG90eXBlLmdldEluID0gZ2V0SW4kMTtcblJlY29yZFByb3RvdHlwZS5oYXNJbiA9IENvbGxlY3Rpb25Qcm90b3R5cGUuaGFzSW47XG5SZWNvcmRQcm90b3R5cGUubWVyZ2UgPSBtZXJnZTtcblJlY29yZFByb3RvdHlwZS5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VJbiA9IG1lcmdlSW47XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwID0gbWVyZ2VEZWVwJDE7XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VEZWVwV2l0aCA9IG1lcmdlRGVlcFdpdGgkMTtcblJlY29yZFByb3RvdHlwZS5tZXJnZURlZXBJbiA9IG1lcmdlRGVlcEluO1xuUmVjb3JkUHJvdG90eXBlLnNldEluID0gc2V0SW4kMTtcblJlY29yZFByb3RvdHlwZS51cGRhdGUgPSB1cGRhdGUkMTtcblJlY29yZFByb3RvdHlwZS51cGRhdGVJbiA9IHVwZGF0ZUluJDE7XG5SZWNvcmRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IHdpdGhNdXRhdGlvbnM7XG5SZWNvcmRQcm90b3R5cGUuYXNNdXRhYmxlID0gYXNNdXRhYmxlO1xuUmVjb3JkUHJvdG90eXBlLmFzSW1tdXRhYmxlID0gYXNJbW11dGFibGU7XG5SZWNvcmRQcm90b3R5cGVbSVRFUkFUT1JfU1lNQk9MXSA9IFJlY29yZFByb3RvdHlwZS5lbnRyaWVzO1xuUmVjb3JkUHJvdG90eXBlLnRvSlNPTiA9IFJlY29yZFByb3RvdHlwZS50b09iamVjdCA9XG4gIENvbGxlY3Rpb25Qcm90b3R5cGUudG9PYmplY3Q7XG5SZWNvcmRQcm90b3R5cGUuaW5zcGVjdCA9IFJlY29yZFByb3RvdHlwZS50b1NvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xufTtcblxuZnVuY3Rpb24gbWFrZVJlY29yZChsaWtlUmVjb3JkLCB2YWx1ZXMsIG93bmVySUQpIHtcbiAgdmFyIHJlY29yZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGxpa2VSZWNvcmQpKTtcbiAgcmVjb3JkLl92YWx1ZXMgPSB2YWx1ZXM7XG4gIHJlY29yZC5fX293bmVySUQgPSBvd25lcklEO1xuICByZXR1cm4gcmVjb3JkO1xufVxuXG5mdW5jdGlvbiByZWNvcmROYW1lKHJlY29yZCkge1xuICByZXR1cm4gcmVjb3JkLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHJlY29yZC5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdSZWNvcmQnO1xufVxuXG5mdW5jdGlvbiByZWNvcmRTZXEocmVjb3JkKSB7XG4gIHJldHVybiBrZXllZFNlcUZyb21WYWx1ZShyZWNvcmQuX2tleXMubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBbaywgcmVjb3JkLmdldChrKV07IH0pKTtcbn1cblxuZnVuY3Rpb24gc2V0UHJvcChwcm90b3R5cGUsIG5hbWUpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQobmFtZSk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpbnZhcmlhbnQodGhpcy5fX293bmVySUQsICdDYW5ub3Qgc2V0IG9uIGFuIGltbXV0YWJsZSByZWNvcmQuJyk7XG4gICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IGZhaWxlZC4gUHJvYmFibHkgSUU4LlxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGxhenkgU2VxIG9mIGB2YWx1ZWAgcmVwZWF0ZWQgYHRpbWVzYCB0aW1lcy4gV2hlbiBgdGltZXNgIGlzXG4gKiB1bmRlZmluZWQsIHJldHVybnMgYW4gaW5maW5pdGUgc2VxdWVuY2Ugb2YgYHZhbHVlYC5cbiAqL1xudmFyIFJlcGVhdCA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEluZGV4ZWRTZXEkJDEpIHtcbiAgZnVuY3Rpb24gUmVwZWF0KHZhbHVlLCB0aW1lcykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXBlYXQpKSB7XG4gICAgICByZXR1cm4gbmV3IFJlcGVhdCh2YWx1ZSwgdGltZXMpO1xuICAgIH1cbiAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuc2l6ZSA9IHRpbWVzID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoRU1QVFlfUkVQRUFUKSB7XG4gICAgICAgIHJldHVybiBFTVBUWV9SRVBFQVQ7XG4gICAgICB9XG4gICAgICBFTVBUWV9SRVBFQVQgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIGlmICggSW5kZXhlZFNlcSQkMSApIFJlcGVhdC5fX3Byb3RvX18gPSBJbmRleGVkU2VxJCQxO1xuICBSZXBlYXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW5kZXhlZFNlcSQkMSAmJiBJbmRleGVkU2VxJCQxLnByb3RvdHlwZSApO1xuICBSZXBlYXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwZWF0O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICdSZXBlYXQgW10nO1xuICAgIH1cbiAgICByZXR1cm4gJ1JlcGVhdCBbICcgKyB0aGlzLl92YWx1ZSArICcgJyArIHRoaXMuc2l6ZSArICcgdGltZXMgXSc7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhpbmRleCkgPyB0aGlzLl92YWx1ZSA6IG5vdFNldFZhbHVlO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAoc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKGJlZ2luLCBlbmQpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICByZXR1cm4gd2hvbGVTbGljZShiZWdpbiwgZW5kLCBzaXplKVxuICAgICAgPyB0aGlzXG4gICAgICA6IG5ldyBSZXBlYXQoXG4gICAgICAgICAgdGhpcy5fdmFsdWUsXG4gICAgICAgICAgcmVzb2x2ZUVuZChlbmQsIHNpemUpIC0gcmVzb2x2ZUJlZ2luKGJlZ2luLCBzaXplKVxuICAgICAgICApO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHNlYXJjaFZhbHVlKSB7XG4gICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mIChzZWFyY2hWYWx1ZSkge1xuICAgIGlmIChpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgUmVwZWF0LnByb3RvdHlwZS5fX2l0ZXJhdGUgPSBmdW5jdGlvbiBfX2l0ZXJhdGUgKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpICE9PSBzaXplKSB7XG4gICAgICBpZiAoZm4odGhpcy5fdmFsdWUsIHJldmVyc2UgPyBzaXplIC0gKytpIDogaSsrLCB0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9O1xuXG4gIFJlcGVhdC5wcm90b3R5cGUuX19pdGVyYXRvciA9IGZ1bmN0aW9uIF9faXRlcmF0b3IgKHR5cGUsIHJldmVyc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzaXplID0gdGhpcy5zaXplO1xuICAgIHZhciBpID0gMDtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yKFxuICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gaSA9PT0gc2l6ZVxuICAgICAgICAgID8gaXRlcmF0b3JEb25lKClcbiAgICAgICAgICA6IGl0ZXJhdG9yVmFsdWUodHlwZSwgcmV2ZXJzZSA/IHNpemUgLSArK2kgOiBpKyssIHRoaXMkMS5fdmFsdWUpOyB9XG4gICAgKTtcbiAgfTtcblxuICBSZXBlYXQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBSZXBlYXRcbiAgICAgID8gaXModGhpcy5fdmFsdWUsIG90aGVyLl92YWx1ZSlcbiAgICAgIDogZGVlcEVxdWFsKG90aGVyKTtcbiAgfTtcblxuICByZXR1cm4gUmVwZWF0O1xufShJbmRleGVkU2VxKSk7XG5cbnZhciBFTVBUWV9SRVBFQVQ7XG5cbmZ1bmN0aW9uIGZyb21KUyh2YWx1ZSwgY29udmVydGVyKSB7XG4gIHJldHVybiBmcm9tSlNXaXRoKFxuICAgIFtdLFxuICAgIGNvbnZlcnRlciB8fCBkZWZhdWx0Q29udmVydGVyLFxuICAgIHZhbHVlLFxuICAgICcnLFxuICAgIGNvbnZlcnRlciAmJiBjb252ZXJ0ZXIubGVuZ3RoID4gMiA/IFtdIDogdW5kZWZpbmVkLFxuICAgIHsgJyc6IHZhbHVlIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gZnJvbUpTV2l0aChzdGFjaywgY29udmVydGVyLCB2YWx1ZSwga2V5LCBrZXlQYXRoLCBwYXJlbnRWYWx1ZSkge1xuICB2YXIgdG9TZXEgPSBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgID8gSW5kZXhlZFNlcVxuICAgIDogaXNQbGFpbk9iaih2YWx1ZSlcbiAgICAgID8gS2V5ZWRTZXFcbiAgICAgIDogbnVsbDtcbiAgaWYgKHRvU2VxKSB7XG4gICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEltbXV0YWJsZScpO1xuICAgIH1cbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICBrZXlQYXRoICYmIGtleSAhPT0gJycgJiYga2V5UGF0aC5wdXNoKGtleSk7XG4gICAgdmFyIGNvbnZlcnRlZCA9IGNvbnZlcnRlci5jYWxsKFxuICAgICAgcGFyZW50VmFsdWUsXG4gICAgICBrZXksXG4gICAgICB0b1NlcSh2YWx1ZSkubWFwKGZ1bmN0aW9uICh2LCBrKSB7IHJldHVybiBmcm9tSlNXaXRoKHN0YWNrLCBjb252ZXJ0ZXIsIHYsIGssIGtleVBhdGgsIHZhbHVlKTsgfVxuICAgICAgKSxcbiAgICAgIGtleVBhdGggJiYga2V5UGF0aC5zbGljZSgpXG4gICAgKTtcbiAgICBzdGFjay5wb3AoKTtcbiAgICBrZXlQYXRoICYmIGtleVBhdGgucG9wKCk7XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb252ZXJ0ZXIoaywgdikge1xuICByZXR1cm4gaXNLZXllZCh2KSA/IHYudG9NYXAoKSA6IHYudG9MaXN0KCk7XG59XG5cbnZhciB2ZXJzaW9uID0gXCI0LjAuMC1yYy4xMVwiO1xuXG52YXIgSW1tdXRhYmxlID0ge1xuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuXG4gIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXG4gIC8vIE5vdGU6IEl0ZXJhYmxlIGlzIGRlcHJlY2F0ZWRcbiAgSXRlcmFibGU6IENvbGxlY3Rpb24sXG5cbiAgU2VxOiBTZXEsXG4gIE1hcDogTWFwLFxuICBPcmRlcmVkTWFwOiBPcmRlcmVkTWFwLFxuICBMaXN0OiBMaXN0LFxuICBTdGFjazogU3RhY2ssXG4gIFNldDogU2V0LFxuICBPcmRlcmVkU2V0OiBPcmRlcmVkU2V0LFxuXG4gIFJlY29yZDogUmVjb3JkLFxuICBSYW5nZTogUmFuZ2UsXG4gIFJlcGVhdDogUmVwZWF0LFxuXG4gIGlzOiBpcyxcbiAgZnJvbUpTOiBmcm9tSlMsXG4gIGhhc2g6IGhhc2gsXG5cbiAgaXNJbW11dGFibGU6IGlzSW1tdXRhYmxlLFxuICBpc0NvbGxlY3Rpb246IGlzQ29sbGVjdGlvbixcbiAgaXNLZXllZDogaXNLZXllZCxcbiAgaXNJbmRleGVkOiBpc0luZGV4ZWQsXG4gIGlzQXNzb2NpYXRpdmU6IGlzQXNzb2NpYXRpdmUsXG4gIGlzT3JkZXJlZDogaXNPcmRlcmVkLFxuICBpc1ZhbHVlT2JqZWN0OiBpc1ZhbHVlT2JqZWN0LFxuICBpc1NlcTogaXNTZXEsXG4gIGlzTGlzdDogaXNMaXN0LFxuICBpc01hcDogaXNNYXAsXG4gIGlzT3JkZXJlZE1hcDogaXNPcmRlcmVkTWFwLFxuICBpc1N0YWNrOiBpc1N0YWNrLFxuICBpc1NldDogaXNTZXQsXG4gIGlzT3JkZXJlZFNldDogaXNPcmRlcmVkU2V0LFxuICBpc1JlY29yZDogaXNSZWNvcmQsXG5cbiAgZ2V0OiBnZXQsXG4gIGdldEluOiBnZXRJbixcbiAgaGFzOiBoYXMsXG4gIGhhc0luOiBoYXNJbixcbiAgbWVyZ2U6IG1lcmdlJDEsXG4gIG1lcmdlRGVlcDogbWVyZ2VEZWVwLFxuICBtZXJnZVdpdGg6IG1lcmdlV2l0aCQxLFxuICBtZXJnZURlZXBXaXRoOiBtZXJnZURlZXBXaXRoLFxuICByZW1vdmU6IHJlbW92ZSxcbiAgcmVtb3ZlSW46IHJlbW92ZUluLFxuICBzZXQ6IHNldCxcbiAgc2V0SW46IHNldEluLFxuICB1cGRhdGU6IHVwZGF0ZSxcbiAgdXBkYXRlSW46IHVwZGF0ZUluLFxufTtcblxuLy8gTm90ZTogSXRlcmFibGUgaXMgZGVwcmVjYXRlZFxudmFyIEl0ZXJhYmxlID0gQ29sbGVjdGlvbjtcblxuZXhwb3J0IGRlZmF1bHQgSW1tdXRhYmxlO1xuZXhwb3J0IHsgdmVyc2lvbiwgQ29sbGVjdGlvbiwgSXRlcmFibGUsIFNlcSwgTWFwLCBPcmRlcmVkTWFwLCBMaXN0LCBTdGFjaywgU2V0LCBPcmRlcmVkU2V0LCBSZWNvcmQsIFJhbmdlLCBSZXBlYXQsIGlzLCBmcm9tSlMsIGhhc2gsIGlzSW1tdXRhYmxlLCBpc0NvbGxlY3Rpb24sIGlzS2V5ZWQsIGlzSW5kZXhlZCwgaXNBc3NvY2lhdGl2ZSwgaXNPcmRlcmVkLCBpc1ZhbHVlT2JqZWN0LCBnZXQsIGdldEluLCBoYXMsIGhhc0luLCBtZXJnZSQxIGFzIG1lcmdlLCBtZXJnZURlZXAsIG1lcmdlV2l0aCQxIGFzIG1lcmdlV2l0aCwgbWVyZ2VEZWVwV2l0aCwgcmVtb3ZlLCByZW1vdmVJbiwgc2V0LCBzZXRJbiwgdXBkYXRlLCB1cGRhdGVJbiB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==